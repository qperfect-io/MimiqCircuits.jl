<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basics · MimiqCircuits.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MimiqCircuits.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../about/">About</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Basics</a><ul class="internal"><li><a class="tocitem" href="#Quantum-Circuit"><span>Quantum Circuit</span></a></li><li><a class="tocitem" href="#Bit-States"><span>Bit States</span></a></li><li><a class="tocitem" href="#Executing-the-Circuit"><span>Executing the Circuit</span></a></li><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li><li><a class="tocitem" href="#Amplitudes"><span>Amplitudes</span></a></li><li><a class="tocitem" href="#Classical-Registries-and-Mid-Circuit-Measurements"><span>Classical Registries and Mid-Circuit Measurements</span></a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../library/outline/">Contents</a></li><li><a class="tocitem" href="../library/public/">Public</a></li><li><a class="tocitem" href="../library/internals/">Private</a></li><li><a class="tocitem" href="../library/function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Basics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/qperfect-io/MimiqCircuits.jl/blob/main/docs/src/basics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-Concepts"><a class="docs-heading-anchor" href="#Basic-Concepts">Basic Concepts</a><a id="Basic-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Concepts" title="Permalink"></a></h1><p>This section provides an overview of how the circuit simulation works in our framework.</p><h2 id="Quantum-Circuit"><a class="docs-heading-anchor" href="#Quantum-Circuit">Quantum Circuit</a><a id="Quantum-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Circuit" title="Permalink"></a></h2><p>A quantum circuit is a sequence of quantum gates and operations acting on qubits, the basic units of quantum information.</p><p>Every computation, in MIMIQ Circuits starts with the construction of a quantum circuit. You can construct the circuit using the tools provided by the &quot;MimiqCircuits&quot; library, including gates and various quantum operations. Once you have built the circuit, you can proceed with the simulation.</p><p>A simple circuit with 4 Hadamard gates on 4 different qubits is given by</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = Circuit()</code><code class="nohighlight hljs ansi" style="display:block;">empty circuit</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i in 1:4
           push!(c, GateH(), i)
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>or simply</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = Circuit()</code><code class="nohighlight hljs ansi" style="display:block;">empty circuit</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; push!(c, GateH(), 1:4)</code><code class="nohighlight hljs ansi" style="display:block;">4-qubit circuit with 4 instructions:
├── H @ q1
├── H @ q2
├── H @ q3
└── H @ q4</code></pre><p>We are using a <code>@</code> notation to indicates that a quantum operation, in this case a Hadamard gate <code>H</code>, is applied to one or many qubits. Hadamard gates are single qubit gates, so they can be applied only to one qubit at a time (e.g. <code>H @ q0</code> in the example). In this notation we indicate with <code>q0, q1, q2...</code> qubits or quantum bit targets and with <code>c0, c1, c2, ...</code> classical bit targets.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Indexing of targets is different between Julia and Python. Julia indices starts from 1, while Python indices start from 0. Pay extra attention when translating code from Python or to Julia and vice versa (e.g. when importing code from other frameworks).</p></div></div><p>Quantum circuits can be easily manipulated in <code>MimiqCircuits</code>. Some common operations include:</p><ul><li>Adding gates or quantum operations (e.g. with <code>push!(circuit, operation, targets...)</code>),</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = Circuit()</code><code class="nohighlight hljs ansi" style="display:block;">empty circuit</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; push!(c, GateH(), 1)</code><code class="nohighlight hljs ansi" style="display:block;">1-qubit circuit with 1 instructions:
└── H @ q1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; push!(c, GateCX(), 1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">2-qubit circuit with 2 instructions:
├── H @ q1
└── CX @ q1, q2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; push!(c, GateRX(π / 4), 2)</code><code class="nohighlight hljs ansi" style="display:block;">2-qubit circuit with 3 instructions:
├── H @ q1
├── CX @ q1, q2
└── RX(θ=0.7853981633974483) @ q2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; push!(c, GateCH(), 2, 1)</code><code class="nohighlight hljs ansi" style="display:block;">2-qubit circuit with 4 instructions:
├── H @ q1
├── CX @ q1, q2
├── RX(θ=0.7853981633974483) @ q2
└── CH @ q2, q1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; push!(c, Barrier(2), 1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">2-qubit circuit with 5 instructions:
├── H @ q1
├── CX @ q1, q2
├── RX(θ=0.7853981633974483) @ q2
├── CH @ q2, q1
└── Barrier @ q1, q2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; push!(c, Measure(), 1, 1)</code><code class="nohighlight hljs ansi" style="display:block;">2-qubit circuit with 6 instructions:
├── H @ q1
├── CX @ q1, q2
├── RX(θ=0.7853981633974483) @ q2
├── CH @ q2, q1
├── Barrier @ q1, q2
└── Measure @ q1c1</code></pre><ul><li>Taking the inverse of a circuit or any other object (with <code>inverse(op or circuit)</code>)</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = let c = Circuit()
           push!(c, GateH(), 1:2)
           push!(c, GateCRX(π / 4), 1, 2)
           push!(c, GateS(), 1)
           c
       end</code><code class="nohighlight hljs ansi" style="display:block;">2-qubit circuit with 4 instructions:
├── H @ q1
├── H @ q2
├── CRX(θ=0.7853981633974483) @ q1, q2
└── S @ q1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cinv = inverse(c)</code><code class="nohighlight hljs ansi" style="display:block;">2-qubit circuit with 4 instructions:
├── SDG @ q1
├── CRX(θ=-0.7853981633974483) @ q1, q2
├── H @ q2
└── H @ q1</code></pre><ul><li>Appending a circuit to another (with <code>append!(circuit, other)</code>)</li></ul><pre><code class="language- hljs">c = let c = Circuit()
    push!(c, GateH(), 1:4)
end
c1 = let c = Circuit()
    push!(c1, GateCH(), 1, 2:4)
end
append!(c, c1)</code></pre><p>For a full list of functions see <a href="../library/public/#MimiqCircuitsBase.Circuit"><code>MimiqCircuitsBase.Circuit</code></a>.</p><h2 id="Bit-States"><a class="docs-heading-anchor" href="#Bit-States">Bit States</a><a id="Bit-States-1"></a><a class="docs-heading-anchor-permalink" href="#Bit-States" title="Permalink"></a></h2><p>We define <em>bit states</em> as the computational states of a multi qubit system in which each qubit state is determined. These states are often indicated by the notation</p><p class="math-container">\[\ket{01001010\cdots}
\equiv
\ket{0}\ket{1}\ket{0}\ket{0}\ket{1}\ket{0}\ket{1}\ket{0}\cdots.\]</p><p>Each bit state is fully specified a string of zeros and ones, and hence they are sometimes also referred to as &quot;bitstrings&quot;.</p><p>The set of all the possible bit states form an complete and orthogonal basis for the quantum state of a multiqubit system, meaning that an arbitrary quantum state of such system can be written as a sum over <em>bit states</em> with complex coefficients.  For example, for a 2 qubit system:</p><p class="math-container">\[\ket{\psi} =
c_0 \ket{00} + c_1 \ket{10} + c_2 \ket{01} + c_3 \ket{11}
\qquad
\forall c_0, c_1, c_2, c_3, \sum_0^3 c_i^2 = 1.\]</p><p><code>MimiqCircuits</code> provides users with a set of utilities to handle, construct and manipulate bit states. </p><p>Few things you can do with <code>BitState</code>:</p><ul><li>Create a bit state for a :math<code>N</code>-qubit system (:math:<code>N=4</code> in the example)</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = BitState(4)</code><code class="nohighlight hljs ansi" style="display:block;">4-qubit BitState with 0 non-zero qubits:
└── |0000⟩</code></pre><ul><li>Create a bit state from a list of nonzero qubits, or from an integer (converting from its binary representation)</li></ul><pre><code class="nohighlight hljs">x = BitState(10, [1,3,8])
y = BitState(10, 5)</code></pre><ul><li>Create a bit state using a generator function (lambda function in this case):</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = BitState(10) do i
           iseven(x)
       end</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching iseven(::BitState)

Closest candidates are:
  iseven(!Matched::AbstractFloat)
   @ Base float.jl:933
  iseven(!Matched::Missing)
   @ Base missing.jl:101
  iseven(!Matched::BigInt)
   @ Base gmp.jl:356
  ...</code></pre><ul><li>Convert a BitState to a string, index or integer (<strong>remember</strong> in Julia,</li></ul><p>indices starts from 1)</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bs = BitState(10, 534)</code><code class="nohighlight hljs ansi" style="display:block;">10-qubit BitState with 4 non-zero qubits:
├── |0110100001⟩
└── non-zero qubits: [2, 3, 5, 10]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; to01(bs)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;0110100001&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstate_to_index(bs)</code><code class="nohighlight hljs ansi" style="display:block;">535</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstate_to_integer(bs)</code><code class="nohighlight hljs ansi" style="display:block;">534</code></pre><ul><li>Get the state of each qubit, the list of nonzero qubits, or even iterate over the qubits</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bs = BitState(10, 534)</code><code class="nohighlight hljs ansi" style="display:block;">10-qubit BitState with 4 non-zero qubits:
├── |0110100001⟩
└── non-zero qubits: [2, 3, 5, 10]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bs[10]</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nonzeros(bs)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int64}:
  2
  3
  5
 10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i in bs
           print(i)
       end</code><code class="nohighlight hljs ansi" style="display:block;">falsetruetruefalsetruefalsefalsefalsefalsetrue</code></pre><p>Besides accessing the quantum state amplitudes corresponding to different bit states, with MIMIQ Circuits, you also have the flexibility to sample the final state in much the same way as is the case for a real quantum computer. </p><h2 id="Executing-the-Circuit"><a class="docs-heading-anchor" href="#Executing-the-Circuit">Executing the Circuit</a><a id="Executing-the-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-the-Circuit" title="Permalink"></a></h2><p>The simulation of a circuit is then performed via the <a href="../library/public/#MimiqCircuits.execute-Tuple{Connection, Circuit}"><code>MimiqCircuits.execute</code></a> function, which start a remote job on the MIMIQ Remote Services. When a job is completed, results can be retrieved by the <a href="../library/public/#MimiqCircuits.getresults-Tuple{Connection, Execution}"><code>MimiqCircuits.getresults</code></a> function. Upon execution, you can specify the algorithm used in the simulation, the number of samples to be performed or the bit states for which the amplitudes should be computed.</p><p>A simulation performs the computation</p><p class="math-container">\[\ket{\psi} = U \ket{000\cdots}\]</p><p>The starting state is always the one where all the qubits are in the <span>$\ket{0}$</span> state. After the circuit execution, the final state <span>$\ket{\psi}$</span> is used for extracting amplitudes and for sampling.</p><p>Below we show a graphical representation of the circuit execution.</p><p><img src="../assets/circuit_execute.svg" alt="Circuit execution example"/></p><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><p>Sampling is performed by applying a measurements operation to the final state on each and every qubit. With MIMIQ Circuits many samples can be obtained very efficiently without necessarily recomputing the whole circuit. The number of samples to obtain is specified through the <code>samples</code> keyword argument when executing a job.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The maximum number of samples a user can request is of <code>2^16</code></p></div></div><h2 id="Amplitudes"><a class="docs-heading-anchor" href="#Amplitudes">Amplitudes</a><a id="Amplitudes-1"></a><a class="docs-heading-anchor-permalink" href="#Amplitudes" title="Permalink"></a></h2><p>Amplitudes corresponding to the bit states specified when submitting a simulation, are computed just before the sampling process, right after having applied the circuit provided by the user.</p><h2 id="Classical-Registries-and-Mid-Circuit-Measurements"><a class="docs-heading-anchor" href="#Classical-Registries-and-Mid-Circuit-Measurements">Classical Registries and Mid-Circuit Measurements</a><a id="Classical-Registries-and-Mid-Circuit-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-Registries-and-Mid-Circuit-Measurements" title="Permalink"></a></h2><p>At present, MIMIQ Circuits does not support classical registers or measurements in the middle of the circuit. However, we are continuously working to enhance our framework with the plan to introduce these features in a coming update.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../library/outline/">Contents »</a><div class="flexbox-break"></div><p class="footer-message">Copyright 2021-2023 QPerfect. All rights reserved.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 3 August 2023 15:01">Thursday 3 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
