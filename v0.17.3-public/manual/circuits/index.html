<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Circuits · MimiqCircuits.jl</title><meta name="title" content="Circuits · MimiqCircuits.jl"/><meta property="og:title" content="Circuits · MimiqCircuits.jl"/><meta property="twitter:title" content="Circuits · MimiqCircuits.jl"/><meta name="description" content="Documentation for MimiqCircuits.jl."/><meta property="og:description" content="Documentation for MimiqCircuits.jl."/><meta property="twitter:description" content="Documentation for MimiqCircuits.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MimiqCircuits.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MimiqCircuits.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">MIMIQ Documentation</a></li><li><a class="tocitem" href="../../quick_start/">Quick start</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>Circuits</a><ul class="internal"><li><a class="tocitem" href="#What-is-a-circuit-and-what-are-instructions"><span>What is a circuit and what are instructions</span></a></li><li><a class="tocitem" href="#Registers:-quantum/classical/Z-register"><span>Registers: quantum/classical/Z-register</span></a></li><li><a class="tocitem" href="#Creating-a-circuit"><span>Creating a circuit</span></a></li><li><a class="tocitem" href="#Adding-Gates"><span>Adding Gates</span></a></li><li><a class="tocitem" href="#Visualizing-circuits"><span>Visualizing circuits</span></a></li><li><a class="tocitem" href="#Decompose"><span>Decompose</span></a></li></ul></li><li><a class="tocitem" href="../unitary_gates/">Unitary Gates</a></li><li><a class="tocitem" href="../non_unitary_ops/">Non-unitary Operations</a></li><li><a class="tocitem" href="../noise/">Noise</a></li><li><a class="tocitem" href="../symbolic_ops/">Symbolic Operations</a></li><li><a class="tocitem" href="../statistical_ops/">Statistical Operations</a></li><li><a class="tocitem" href="../special_ops/">Special Operations</a></li><li><a class="tocitem" href="../simulation/">Simulating Circuits</a></li><li><a class="tocitem" href="../remote_execution/">Cloud Execution</a></li><li><a class="tocitem" href="../import_export/">Import &amp; Export Circuits</a></li><li><a class="tocitem" href="../special_topics/">Special Topics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/outline/">Outline</a></li><li><a class="tocitem" href="../../library/mimiqcircuits/">MimiqCircuits</a></li><li><a class="tocitem" href="../../library/mimiqlink/">MimiqLink</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">MimiqCircuitsBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/mimiqcircuitsbase/general/">General functions</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/circuits/">Quantum Circuits and Instructions</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/operations/">Operations</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/standard/">Standard Gates</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/generalized/">Generalized gates</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/other/">Other Operations</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/noise/">Noise</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/operators/">Operators</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/bitstrings/">Bit Strings</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/results/">Quantum Circuit Simulation Results</a></li></ul></li><li><a class="tocitem" href="../../library/internals/">Internals</a></li><li><a class="tocitem" href="../../library/function_index/">Function Index</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Circuits</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Circuits</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/qperfect-io/MimiqCircuits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/qperfect-io/MimiqCircuits.jl/blob/main/docs/src/manual/circuits.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Circuits"><a class="docs-heading-anchor" href="#Circuits">Circuits</a><a id="Circuits-1"></a><a class="docs-heading-anchor-permalink" href="#Circuits" title="Permalink"></a></h1><p>On this page you can find all the information needed to build a circuit using MIMIQ. Every useful function will be presented below, accompanied by an explanation of their purpose and examples of use.</p><ul><li><a href="#circuits">Circuits</a><ul><li><a href="#what-is-a-circuit-and-what-are-instructions">What is a circuit and what are instructions</a><ul><li><a href="#circuits--instructions-in-mimiq">Circuits \&amp; Instructions in MIMIQ</a></li></ul></li><li><a href="#registers-quantumclassicalz-register">Registers: quantum/classical/Z-register</a></li><li><a href="#creating-a-circuit">Creating a circuit</a></li><li><a href="#adding-gates">Adding Gates</a><ul><li><a href="#push">Push</a><ul><li><a href="#push-specifics"><code>Push!</code> specifics</a></li></ul></li><li><a href="#insert">Insert</a></li><li><a href="#append">Append</a></li></ul></li><li><a href="#visualizing-circuits">Visualizing circuits</a></li><li><a href="#decompose">Decompose</a></li></ul></li></ul><h2 id="What-is-a-circuit-and-what-are-instructions"><a class="docs-heading-anchor" href="#What-is-a-circuit-and-what-are-instructions">What is a circuit and what are instructions</a><a id="What-is-a-circuit-and-what-are-instructions-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-a-circuit-and-what-are-instructions" title="Permalink"></a></h2><p>A quantum circuit, similar to a classical circuit, represents a sequence of quantum gates applied to qubits, which are the carriers of quantum information. Quantum circuits are essential for designing quantum algorithms. The complexity of a quantum circuit is typically measured by two key metrics: width and depth. Width refers to the number of qubits in the circuit, while depth indicates the maximum number of sequential gates applied to any single qubit.</p><p>Here is a representation of a simple GHZ circuit on 4 qubits:</p><pre><code class="language-julia hljs">using MimiqCircuits
ghz = Circuit()
push!(ghz, GateH(), 1)
for i in 2:4
  push!(ghz, GateCX(), 1, i)
end
draw(ghz)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">       ┌─┐
q[1]: ╶┤H├─●──●──●─╴
       └─┘┌┴┐ │  │
q[2]: ╶───┤X├─┼──┼─╴
          └─┘┌┴┐ │
q[3]: ╶──────┤X├─┼─╴
             └─┘┌┴┐
q[4]: ╶─────────┤X├╴
                └─┘</code></pre><p>In this representation, each qubit is depicted by a horizontal line labeled q[x], where x is the qubit’s index. The circuit is read from left to right, with each &#39;block&#39; or symbol along a line representing an operation applied to that specific qubit.</p><h3 id="Circuits-and-Instructions-in-MIMIQ"><a class="docs-heading-anchor" href="#Circuits-and-Instructions-in-MIMIQ">Circuits &amp; Instructions in MIMIQ</a><a id="Circuits-and-Instructions-in-MIMIQ-1"></a><a class="docs-heading-anchor-permalink" href="#Circuits-and-Instructions-in-MIMIQ" title="Permalink"></a></h3><p>MIMIQ implements a circuit using the <a href="../../library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.Circuit"><code>Circuit</code></a> structure, in essence this structure is a wrapper for a vector of <a href="../../library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.Instruction"><code>Instruction</code></a> to be applied on the qubits in the order of the vector. Since it is a vector a circuit can be manipulated as such, for example you can use for loops to iterate over the different instructions of the circuit, do vector comprehension or access all common vector attributes such as the length.</p><p>An <a href="../../library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.Instruction"><code>Instruction</code></a> is composed of the quantum operation to be applied to the qubits, and the targets on which to apply it. There are many types of quantum operations, as discussed in the <a href="../unitary_gates/">unitary gates</a>, <a href="../non_unitary_ops/">non-unitary operations</a> and other pages of the manual. The targets can be qubits, as well as boolean or complex number vectors where classical information can be stored. You will generally not need to interact with the <a href="../../library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.Instruction"><code>Instruction</code></a> class directly (for exceptions, see <a href="../special_ops/">special operations</a>), but it is useful to understand how MIMIQ works.</p><p>See the following sections to learn how to add operations to your circuit.</p><h2 id="Registers:-quantum/classical/Z-register"><a class="docs-heading-anchor" href="#Registers:-quantum/classical/Z-register">Registers: quantum/classical/Z-register</a><a id="Registers:-quantum/classical/Z-register-1"></a><a class="docs-heading-anchor-permalink" href="#Registers:-quantum/classical/Z-register" title="Permalink"></a></h2><p>Before explaining how to build a circuit it is important to make a distinction between the different target registers your operations will be applied to. </p><p>The circuits in MIMIQ are composed of three registers that can be used by the instructions:</p><ul><li>The Quantum Register: Used to store the <strong>qubits</strong> state. Most of the operators in MIMIQ will interact with the quantum register. When printing or drawing a circuit (with the function <a href="../../library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.draw"><code>draw</code></a>) the quantum registers will be denoted as <code>q[x]</code> with x being the index of the qubit in the quantum register.</li><li>The classical register: Used to store the <strong>bits</strong> state. Some gates will need to interact with classical bits (ex: <a href="../non_unitary_ops/#Measure"><code>Measure</code></a>) and the state of the classical bits is stored in the classical register, which is a vector of booleans. When printing or drawing a circuit the classical register will be denoted by the letter <code>c</code>.</li><li>The Z-register: Used to store the result of some specific operations when the expected result is a <strong>complex number</strong> (ex: <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ExpectationValue"><code>ExpectationValue</code></a>). The Z-register is basically a vector of complex numbers. When printing or drawing a circuit the Z-Register will be denoted by the letter <code>z</code>.</li></ul><p>For the three registers operators can be applied on an arbitrary index starting from 1 (as does Julia in general contrary to python). When possible you should always use the minimal index available as going for an arbitrary high index <span>$N$</span> will imply that <span>$N$</span> qubits will be simulated and might result in a loss of performance and will also make the circuit drawing more complex to understand. </p><p>Here is a circuit interacting with all registers:</p><pre><code class="language-julia hljs">using MimiqCircuits
# create empty circuit
circuit = Circuit()

# add X to the first qubit of the Quantum register
push!(circuit, GateX(), 1)

# compute Expectation value of qubit 1 and store complex number on the first Z-Register
ev = ExpectationValue(GateZ())
push!(circuit, ev, 1, 1)

# Measure the qubit state and store bit into the first classical register
push!(circuit, Measure(), 1, 1)

#drw the circuit
draw(circuit)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">       ┌─┐┌───┐┌─┐
q[1]: ╶┤X├┤⟨Z⟩├┤M├╴
       └─┘└─╥─┘└╥┘
            ║   ║
c:    ══════╬═══╩═
            ║   1
z:    ══════╩═════
            1</code></pre><p>As you can see in the code above the indexing of the different registers always starts by the quantum register. If your operator interacts with the three registers the index will have to be provided in the following order: </p><ol><li>Index of the quantum register.</li><li>Index of the classical register.</li><li>Index of the z-register.</li></ol><p>Be careful when writing information to the z-register or to the classical register as the information can be easily overwritten if the same index is used multiple times. For example if you measure two different qubits and store both in the same classical bit the results of the sampling will only report the last measurement.</p><p>To retrieve information on the number of element of each register you can use the <a href="../../library/mimiqcircuitsbase/general/#MimiqCircuitsBase.numqubits"><code>numqubits</code></a>, <a href="../../library/mimiqcircuitsbase/general/#MimiqCircuitsBase.numbits"><code>numbits</code></a> and <a href="../../library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.numzvars-Tuple{Vector{&lt;:Instruction}}"><code>numzvars</code></a>.</p><pre><code class="language-julia hljs">numqubits(circuit), numbits(circuit), numzvars(circuit)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1, 1, 1)</code></pre><p>In the following sections you will learn in details how to build a circuit in MIMIQ.</p><h2 id="Creating-a-circuit"><a class="docs-heading-anchor" href="#Creating-a-circuit">Creating a circuit</a><a id="Creating-a-circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-circuit" title="Permalink"></a></h2><p>The first step in executing quantum algorithm on MIMIQ always consists in implementing the corresponding quantum circuit, a sequence of quantum operations (quantum gates, measurements, resets, etc...) that acts on a set of qubits. In MIMIQ we always start by defining an empty circuit</p><pre><code class="language-julia hljs">circuit = Circuit()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">empty circuit</code></pre><p>There is no need to give any arguments. Not even the number of qubits, classical or Z-registers is necessary as it will be directly inferred from the operations added to the circuit.</p><h2 id="Adding-Gates"><a class="docs-heading-anchor" href="#Adding-Gates">Adding Gates</a><a id="Adding-Gates-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Gates" title="Permalink"></a></h2><p>Once a circuit is instantiated operations can be added to it. To see the list of gates available head to <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.OPERATIONS"><code>OPERATIONS</code></a>, <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.GATES"><code>GATES</code></a>, <code>NOISECHANNELS</code> and <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.GENERALIZED"><code>GENERALIZED</code></a> or enter the following command in your Julia session:</p><pre><code class="nohighlight hljs">?GATES</code></pre><p>To know more about the types of operations you can use in a circuit head to the <a href="../unitary_gates/">unitary gates</a>, <a href="../non_unitary_ops/">non-unitary operations</a>, <a href="../noise/">noise</a>, <a href="../symbolic_ops/">symbolic operations</a> and <a href="../special_ops/">special operations</a> pages.</p><h3 id="Push"><a class="docs-heading-anchor" href="#Push">Push</a><a id="Push-1"></a><a class="docs-heading-anchor-permalink" href="#Push" title="Permalink"></a></h3><p>To add gates to circuits in Julia we will mainly be using the <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> function. The arguments needed by <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> can vary, but in general it expects the following: </p><ol><li>The circuit to add the operation to.</li><li>The operator to be added. </li><li>As many targets as needed by the operator (qubits/bits/zvars).</li></ol><p>For instance you can add the gate <code>X</code> by simply running the following command</p><pre><code class="language-julia hljs">push!(circuit, GateX(), 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-qubit circuit with 1 instructions:
└── X @ q[1]</code></pre><p>The text representation <code>H @ q[1]</code> informs us that there is an instruction which applies the Hadamard gate to the qubit of index 1.</p><p>Some gates require multiple target qubits such as the <code>CX</code> gate. Here is how to add such a gate to the circuit:</p><pre><code class="language-julia hljs">push!(circuit, GateCX(), 1, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-qubit circuit with 1 instructions:
└── CX @ q[1], q[2]</code></pre><p>This will add the gate <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCX"><code>GateCX</code></a> using the qubit number <code>1</code> as the control qubit and number <code>2</code> as the target qubit in the <code>circuit</code>.</p><h4 id="Push!-specifics"><a class="docs-heading-anchor" href="#Push!-specifics"><code>Push!</code> specifics</a><a id="Push!-specifics-1"></a><a class="docs-heading-anchor-permalink" href="#Push!-specifics" title="Permalink"></a></h4><p><a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> is very versatile, it can be used to add multiple operators to multiple targets at once using iterators.</p><p>To add one type of gate to multiple qubits use:</p><pre><code class="language-julia hljs">push!(circuit, GateX(), 1:10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-qubit circuit with 10 instructions:
├── X @ q[1]
├── X @ q[2]
├── X @ q[3]
├── X @ q[4]
├── X @ q[5]
├── X @ q[6]
├── X @ q[7]
├── X @ q[8]
├── X @ q[9]
└── X @ q[10]</code></pre><p>This will add one <code>X</code> gate on each qubit from number 1 to 10.</p><p>This also works on 2-qubit gates:</p><pre><code class="language-julia hljs"># Adds 3 CX gates using respectively 1, 2 &amp; 3 as the control qubits and 4 as the target qubit for all
push!(circuit, GateCX(), 1:3, 4)
# Adds 3 CX gates using respectively 2, 3 &amp; 4 qubits as the target and 1 as the control qubit for all
push!(circuit, GateCX(), 1, 2:4)

# adds 3 CX gates using respectively the couples (1, 4), (2, 5), (3, 6) as the control and target qubits
push!(circuit, GateCX(), 1:3, 4:6)

draw(circuit)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
q[1]: ╶─●────────●──●──●──●───────╴
        │       ┌┴┐ │  │  │
q[2]: ╶─┼──●────┤X├─┼──┼──┼──●────╴
        │  │    └─┘┌┴┐ │  │  │
q[3]: ╶─┼──┼──●────┤X├─┼──┼──┼──●─╴
       ┌┴┐┌┴┐┌┴┐   └─┘┌┴┐┌┴┐ │  │
q[4]: ╶┤X├┤X├┤X├──────┤X├┤X├─┼──┼─╴
       └─┘└─┘└─┘      └─┘└─┘┌┴┐ │
q[5]: ╶─────────────────────┤X├─┼─╴
                            └─┘┌┴┐
q[6]: ╶────────────────────────┤X├╴
                               └─┘</code></pre><p>Be careful when using vectors for both control and target, if one of the two vectors in longer than the other only the <code>N</code> first element of the vector will be accounted for with <code>N = min(length.(vector1, vector2))</code>. See the output of the code below to see the implication in practice:</p><pre><code class="language-julia hljs">circuit = Circuit()
# Adds only 3 CX gates
push!(circuit, GateCX(), 1:3, 4:18)

draw(circuit)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
q[1]: ╶─●───────╴
        │
q[2]: ╶─┼──●────╴
        │  │
q[3]: ╶─┼──┼──●─╴
       ┌┴┐ │  │
q[4]: ╶┤X├─┼──┼─╴
       └─┘┌┴┐ │
q[5]: ╶───┤X├─┼─╴
          └─┘┌┴┐
q[6]: ╶──────┤X├╴
             └─┘</code></pre><p>You can also use tuples or vectors in the exact same fashion:</p><pre><code class="language-julia hljs">push!(circuit, GateCX(), (1, 2), (3, 4))
push!(circuit, GateCX(), [1, 3], [2, 4])

draw(circuit)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
q[1]: ╶─●─────●────╴
        │    ┌┴┐
q[2]: ╶─┼──●─┤X├───╴
       ┌┴┐ │ └─┘
q[3]: ╶┤X├─┼─────●─╴
       └─┘┌┴┐   ┌┴┐
q[4]: ╶───┤X├───┤X├╴
          └─┘   └─┘</code></pre><h3 id="Insert"><a class="docs-heading-anchor" href="#Insert">Insert</a><a id="Insert-1"></a><a class="docs-heading-anchor-permalink" href="#Insert" title="Permalink"></a></h3><p>You can also insert an operation at a given index in the circuit using the <a href="../../library/internals/#Base.insert!-Tuple{Circuit, Any, Instruction}">insert!</a> function:</p><pre><code class="language-julia hljs">circuit = Circuit()
push!(circuit, GateX(), 1)
push!(circuit, GateZ(), 1)

# Insert the gate at a specific index
insert!(circuit, 2, GateY(), 1)
circuit</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-qubit circuit with 3 instructions:
├── X @ q[1]
├── Y @ q[1]
└── Z @ q[1]</code></pre><p>This will insert <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateY"><code>GateY</code></a> applied on qubit <code>1</code> at the second position in the circuit.</p><h3 id="Append"><a class="docs-heading-anchor" href="#Append">Append</a><a id="Append-1"></a><a class="docs-heading-anchor-permalink" href="#Append" title="Permalink"></a></h3><p>To append one circuit to another you can use the <a href="../../library/internals/#Base.append!-Tuple{Circuit, Circuit}">append!</a> function:</p><pre><code class="language-julia hljs"># Build a first circuit
circuit1 = Circuit()
push!(circuit1, GateX(), 1:3)

# Build a second circuit
circuit2 = Circuit()
push!(circuit2, GateY(), 1:3)

# Append the second circuit to the first one
append!(circuit1, circuit2)
circuit1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-qubit circuit with 6 instructions:
├── X @ q[1]
├── X @ q[2]
├── X @ q[3]
├── Y @ q[1]
├── Y @ q[2]
└── Y @ q[3]</code></pre><p>This will modify <code>circuit1</code> by appending all the operations from <code>circuit2</code>.</p><p>This function is particularly useful for building circuits by combining smaller circuit blocks.</p><h2 id="Visualizing-circuits"><a class="docs-heading-anchor" href="#Visualizing-circuits">Visualizing circuits</a><a id="Visualizing-circuits-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-circuits" title="Permalink"></a></h2><p>To visualize a circuit use the <a href="../../library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.draw"><code>draw</code></a> method.</p><pre><code class="language-julia hljs">draw(circuit)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">       ┌─┐
q[1]: ╶┤X├────────────╴
       └─┘┌─┐
q[2]: ╶───┤X├─────────╴
          └─┘┌─┐
q[3]: ╶──────┤X├──────╴
             └─┘┌─┐
q[4]: ╶─────────┤X├───╴
                └─┘┌─┐
q[5]: ╶────────────┤X├╴
                   └─┘</code></pre><p>Information such as the <a href="../../library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.depth-Tuple{Circuit}"><code>depth</code></a> and the width (<a href="../../library/mimiqcircuitsbase/general/#MimiqCircuitsBase.numqubits"><code>numqubits</code></a>) can be extracted from the circuit:</p><pre><code class="language-julia hljs">depth(circuit), numqubits(circuit)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1, 5)</code></pre><h2 id="Decompose"><a class="docs-heading-anchor" href="#Decompose">Decompose</a><a id="Decompose-1"></a><a class="docs-heading-anchor-permalink" href="#Decompose" title="Permalink"></a></h2><p>Most gates can be decomposed into a combination of <code>U</code> and <code>CX</code> gates, the <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.decompose"><code>decompose</code></a> function extracts such decomposition from a given circuit:</p><pre><code class="language-julia hljs">circuit = Circuit()
push!(circuit, GateX(), 1)

# decompose the circuit
decompose(circuit)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-qubit circuit with 1 instructions:
└── U(π,0,π) @ q[1]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../unitary_gates/">Unitary Gates »</a><div class="flexbox-break"></div><p class="footer-message">Copyright 2021-2024 QPerfect. All rights reserved.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 24 November 2024 20:55">Sunday 24 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
