<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Unitary Gates · MimiqCircuits.jl</title><meta name="title" content="Unitary Gates · MimiqCircuits.jl"/><meta property="og:title" content="Unitary Gates · MimiqCircuits.jl"/><meta property="twitter:title" content="Unitary Gates · MimiqCircuits.jl"/><meta name="description" content="Documentation for MimiqCircuits.jl."/><meta property="og:description" content="Documentation for MimiqCircuits.jl."/><meta property="twitter:description" content="Documentation for MimiqCircuits.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MimiqCircuits.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MimiqCircuits.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">MIMIQ Documentation</a></li><li><a class="tocitem" href="../../quick_start/">Quick start</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../circuits/">Circuits</a></li><li class="is-active"><a class="tocitem" href>Unitary Gates</a><ul class="internal"><li><a class="tocitem" href="#Mathematical-background"><span>Mathematical background</span></a></li><li><a class="tocitem" href="#Unitary-gates-in-MIMIQ."><span>Unitary gates in MIMIQ.</span></a></li><li><a class="tocitem" href="#Custom-Gates"><span>Custom Gates</span></a></li><li><a class="tocitem" href="#Composition:-Control,-Power,-Inverse,-Parallel"><span>Composition: Control, Power, Inverse, Parallel</span></a></li><li><a class="tocitem" href="#Extract-information-of-unitary-gates"><span>Extract information of unitary gates</span></a></li></ul></li><li><a class="tocitem" href="../non_unitary_ops/">Non-unitary Operations</a></li><li><a class="tocitem" href="../noise/">Noise</a></li><li><a class="tocitem" href="../symbolic_ops/">Symbolic Operations</a></li><li><a class="tocitem" href="../statistical_ops/">Statistical Operations</a></li><li><a class="tocitem" href="../special_ops/">Special Operations</a></li><li><a class="tocitem" href="../simulation/">Simulating Circuits</a></li><li><a class="tocitem" href="../remote_execution/">Cloud Execution</a></li><li><a class="tocitem" href="../import_export/">Import &amp; Export Circuits</a></li><li><a class="tocitem" href="../special_topics/">Special Topics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/outline/">Outline</a></li><li><a class="tocitem" href="../../library/mimiqcircuits/">MimiqCircuits</a></li><li><a class="tocitem" href="../../library/mimiqlink/">MimiqLink</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">MimiqCircuitsBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/mimiqcircuitsbase/general/">General functions</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/circuits/">Quantum Circuits and Instructions</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/operations/">Operations</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/standard/">Standard Gates</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/generalized/">Generalized gates</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/other/">Other Operations</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/noise/">Noise</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/operators/">Operators</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/bitstrings/">Bit Strings</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/results/">Quantum Circuit Simulation Results</a></li></ul></li><li><a class="tocitem" href="../../library/internals/">Internals</a></li><li><a class="tocitem" href="../../library/function_index/">Function Index</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Unitary Gates</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Unitary Gates</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/qperfect-io/MimiqCircuits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/qperfect-io/MimiqCircuits.jl/blob/main/docs/src/manual/unitary_gates.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Unitary-Gates"><a class="docs-heading-anchor" href="#Unitary-Gates">Unitary Gates</a><a id="Unitary-Gates-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-Gates" title="Permalink"></a></h1><p>Unitary gates are fundamental components of quantum circuits. Here we explain how to work with unitary gates in MIMIQ.</p><ul><li><a href="#unitary-gates">Unitary Gates</a><ul><li><a href="#mathematical-background">Mathematical background</a><ul><li><a href="#state-vector-and-probability">State vector and probability</a></li><li><a href="#unitary-transformation">Unitary transformation</a></li></ul></li><li><a href="#unitary-gates-in-mimiq">Unitary gates in MIMIQ.</a><ul><li><a href="#single-qubit-gates">Single-qubit gates</a></li><li><a href="#single-qubit-parametric-gates">Single-qubit parametric gates</a></li><li><a href="#two-qubit-gates">Two qubit gates</a></li><li><a href="#two-qubit-parametric-gates">Two-qubit parametric gates</a></li><li><a href="#multi-qubit-gates">Multi-qubit gates</a></li><li><a href="#generalized-gates">Generalized gates</a></li></ul></li><li><a href="#custom-gates">Custom Gates</a></li><li><a href="#composition-control-power-inverse-parallel">Composition: Control, Power, Inverse, Parallel</a><ul><li><a href="#control">Control</a></li><li><a href="#power">Power</a></li><li><a href="#inverse">Inverse</a></li><li><a href="#parallel">Parallel</a></li></ul></li><li><a href="#extract-information-of-unitary-gates">Extract information of unitary gates</a><ul><li><a href="#matrix">Matrix</a></li><li><a href="#number-of-targets">Number of targets</a></li></ul></li></ul></li></ul><h2 id="Mathematical-background"><a class="docs-heading-anchor" href="#Mathematical-background">Mathematical background</a><a id="Mathematical-background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-background" title="Permalink"></a></h2><h3 id="State-vector-and-probability"><a class="docs-heading-anchor" href="#State-vector-and-probability">State vector and probability</a><a id="State-vector-and-probability-1"></a><a class="docs-heading-anchor-permalink" href="#State-vector-and-probability" title="Permalink"></a></h3><p>In quantum mechanics, every transformation applied to a quantum state must be unitary (in a closed system). To understand why, we can expand the quantum state as  </p><p class="math-container">\[\begin{aligned}
\ket{\psi} = \sum_{i=1}^{k} c_{i} \ket{\psi_{i}}
\end{aligned}\]</p><p>where <span>$\ket{\psi_i}$</span> are orthonormal basis states. For this state, the following condition must hold true:  </p><p class="math-container">\[\begin{aligned}
\sum_{i=1}^{k} |c_i|² = 1 
\end{aligned}\]</p><p>Since <span>$|c_i|^2$</span> corresponds to the probability of measuring state <span>$\ket{\psi_i}$</span>, this condition simply says that the probabilities must add up to one. Unitary gates preserve this normalization condition, see below.</p><h3 id="Unitary-transformation"><a class="docs-heading-anchor" href="#Unitary-transformation">Unitary transformation</a><a id="Unitary-transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-transformation" title="Permalink"></a></h3><p>An alternative way to compute the probability is through the inner product. Given two states in Hilbert space, <span>$\ket{\alpha}$</span> and <span>$\ket{\psi}$</span>, the squared inner product <span>$|\braket{\alpha|\psi}|^2$</span> reflects the probability of measuring the system in state <span>$\ket{\alpha}$</span>.  Thus, the normalization condition can be written as<span>$|\braket{\psi|\psi}|^2 = 1$</span>. In other words, the length of the state vector in complex space must be one.</p><p>When evolving the state <span>$\ket{\psi}$</span> using an operator U, the normalization condition becomes (omitting the square):  </p><p class="math-container">\[\begin{aligned}
\bra{\psi} U^\dagger U \ket{\psi} = 1
\end{aligned}\]</p><p>To fulfill this, the operator U must satisfy the condition:  </p><p class="math-container">\[\begin{aligned}
U^\dagger U = I
\end{aligned}\]</p><p>An operator that fulfills this requirement is called a unitary operator and its matrix representation is unitary too.</p><h2 id="Unitary-gates-in-MIMIQ."><a class="docs-heading-anchor" href="#Unitary-gates-in-MIMIQ.">Unitary gates in MIMIQ.</a><a id="Unitary-gates-in-MIMIQ.-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-gates-in-MIMIQ." title="Permalink"></a></h2><p>MIMIQ offers a large number of gates to build quantum circuits. For an overview, type the following line in your Julia session:</p><pre><code class="nohighlight hljs">?GATES</code></pre><p>Similarly, to get more information about a specific gate, you can type the following command in your Julia session using the gate of your choice:</p><pre><code class="nohighlight hljs">?GateID</code></pre><p>There are different categories of gates depending on the number of targets, parameters etc. We discuss how to implement them in the following.</p><h3 id="Single-qubit-gates"><a class="docs-heading-anchor" href="#Single-qubit-gates">Single-qubit gates</a><a id="Single-qubit-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Single-qubit-gates" title="Permalink"></a></h3><p>List of single-qubit gates: <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateID"><code>GateID</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateX"><code>GateX</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateY"><code>GateY</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateZ"><code>GateZ</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateH"><code>GateH</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateS"><code>GateS</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateSDG"><code>GateSDG</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateT"><code>GateT</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateTDG"><code>GateTDG</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateSX"><code>GateSX</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateSXDG"><code>GateSXDG</code></a>. <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.GateSY"><code>GateSY</code></a>, <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.GateSYDG"><code>GateSYDG</code></a>.</p><p>For single-qubit gates you don&#39;t need to give any argument to the gate constructor (ex: <code>GateX()</code>). You only need to give the index of the target qubit when adding it to your circuit with the <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> function.</p><pre><code class="language-julia hljs">push!(circuit, GateX(), 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-qubit circuit with 1 instructions:
└── X @ q[1]</code></pre><h3 id="Single-qubit-parametric-gates"><a class="docs-heading-anchor" href="#Single-qubit-parametric-gates">Single-qubit parametric gates</a><a id="Single-qubit-parametric-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Single-qubit-parametric-gates" title="Permalink"></a></h3><p>List of single-qubit parametric gates:  <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateU"><code>GateU</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateP"><code>GateP</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRX"><code>GateRX</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRY"><code>GateRY</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRZ"><code>GateRZ</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateR"><code>GateR</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateU1"><code>GateU1</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateU2"><code>GateU2</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateU3"><code>GateU3</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Delay"><code>Delay</code></a>.</p><p>For single-qubit parametric gates you need to give the expected number of parameters to the gate constructor (ex: <code>GateU(0.5, 0.5, 0.5)</code> or <code>GateU1(0.5)</code>), if you are unsure of the expected number of parameters type <code>?</code> before the name of the gate in your Julia session (ex: <code>?GateU</code>). As for any single qubit gates you can add it to your circuit by using the <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> function and give the index of the target qubit.</p><pre><code class="language-julia hljs">push!(circuit, GateRX(pi/2), 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-qubit circuit with 1 instructions:
└── RX(π/2) @ q[1]</code></pre><h3 id="Two-qubit-gates"><a class="docs-heading-anchor" href="#Two-qubit-gates">Two qubit gates</a><a id="Two-qubit-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Two-qubit-gates" title="Permalink"></a></h3><p>List of two qubits gates: <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCX"><code>GateCX</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCY"><code>GateCY</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCZ"><code>GateCZ</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCH"><code>GateCH</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateSWAP"><code>GateSWAP</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateISWAP"><code>GateISWAP</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCS"><code>GateCS</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCSDG"><code>GateCSDG</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCSX"><code>GateCSX</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCSXDG"><code>GateCSXDG</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateECR"><code>GateECR</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateDCX"><code>GateDCX</code></a>.</p><p>Two-qubit gates can be instantiated without any arguments just like single-qubit gates (ex: <code>GateCX()</code>). You will need to give the index of both qubits to the <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> function to add it to the circuit. To understand the ordering of the targets check the documentation of each particular gate. For controlled gates we use the convention that the first register corresponds to the control and the second to the target.</p><pre><code class="language-julia hljs">push!(circuit, GateCH(), 1, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-qubit circuit with 1 instructions:
└── CH @ q[1], q[2]</code></pre><h3 id="Two-qubit-parametric-gates"><a class="docs-heading-anchor" href="#Two-qubit-parametric-gates">Two-qubit parametric gates</a><a id="Two-qubit-parametric-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Two-qubit-parametric-gates" title="Permalink"></a></h3><p>List of two qubits parametric gates : <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCP"><code>GateCP</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCU"><code>GateCU</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCRX"><code>GateCRX</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCRY"><code>GateCRY</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCRZ"><code>GateCRZ</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRXX"><code>GateRXX</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRYY"><code>GateRYY</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRZZ"><code>GateRZZ</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRZX"><code>GateRZX</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateXXplusYY"><code>GateXXplusYY</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateXXminusYY"><code>GateXXminusYY</code></a>.</p><p>Two-qubit parametric gates are instantiated exactly like single-qubit parametric gates. You will need to give the expected number of parameters of the gate to its constructor (ex: <code>GateCU(pi, pi, pi)</code>). You can then add it to the circuit just like a two-qubit gate by giving the index of the target qubits to the <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> function. Again, check each gate&#39;s documentation to understand the qubit ordering; for controlled gates the first qubit corresponds to the control qubit, the second to the target.</p><pre><code class="language-julia hljs">push!(circuit, GateRXX(pi/2), 1, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-qubit circuit with 1 instructions:
└── RXX(π/2) @ q[1:2]</code></pre><h3 id="Multi-qubit-gates"><a class="docs-heading-anchor" href="#Multi-qubit-gates">Multi-qubit gates</a><a id="Multi-qubit-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-qubit-gates" title="Permalink"></a></h3><p>List of multi-qubit gates: <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCCX"><code>GateCCX</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateC3X"><code>GateC3X</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCCP"><code>GateCCP</code></a>, <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCSWAP"><code>GateCSWAP</code></a>.</p><p>For the multi-qubit controlled gates you will need to give the index of each qubit to the <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> function. As usual, first the control qubits, then the targets; check the specific documentation of each gate.</p><pre><code class="language-julia hljs">push!(circuit, GateC3X(), 1, 2, 3, 4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-qubit circuit with 1 instructions:
└── C₃X @ q[1:3], q[4]</code></pre><h3 id="Generalized-gates"><a class="docs-heading-anchor" href="#Generalized-gates">Generalized gates</a><a id="Generalized-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-gates" title="Permalink"></a></h3><p>Some common gate combinations are available as generalized gates: <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PauliString"><code>PauliString</code></a>, <a href="../../library/mimiqcircuitsbase/generalized/#MimiqCircuitsBase.QFT"><code>QFT</code></a>, <a href="../../library/mimiqcircuitsbase/generalized/#MimiqCircuitsBase.PhaseGradient"><code>PhaseGradient</code></a>, <a href="../special_ops/#Diffusion"><code>Diffusion</code></a>, <a href="../../library/mimiqcircuitsbase/generalized/#MimiqCircuitsBase.PolynomialOracle"><code>PolynomialOracle</code></a>.</p><p>Generalized gates can be applied to a variable number of qubits. It is highly recommended to check their docstrings to understand their usage <code>?QFT</code>.</p><p>Here is an example of use:</p><pre><code class="language-julia hljs">push!(circuit, PhaseGradient(10), 1:10...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-qubit circuit with 1 instructions:
└── PhaseGradient @ q[1:10]</code></pre><p>These gates target a variable number of gates, so you have to specify in the constructor how many target qubits will be used, and give to the <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> function one index per target qubit.</p><p>More about generalized gates on <a href="../special_ops/">special operations</a>.</p><h2 id="Custom-Gates"><a class="docs-heading-anchor" href="#Custom-Gates">Custom Gates</a><a id="Custom-Gates-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Gates" title="Permalink"></a></h2><p>If you need to use a specific unitary gate that is not provided by MIMIQ, you can use <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.GateCustom">GateCustom</a> to create your own unitary gate.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only <strong>one</strong> qubit or <strong>two</strong> qubits gates can be created using MIMIQ&#39;s <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.GateCustom"><code>GateCustom</code></a>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Avoid using <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.GateCustom"><code>GateCustom</code></a> if you can define the same gate using a pre-defined gate from MIMIQ&#39;s library, as it could impact negatively peformance.</p></div></div><p>To create a custom unitary gate you first have to define the matrix of your gate in Julia:</p><pre><code class="language-julia hljs"># define the matrix for a 2 qubits gate
custom_matrix = [exp(im*pi/3) 0 0 0; 0 exp(im*pi/5) 0 0; 0 0 exp(im*pi/7) 0; 0 0 0 exp(im*pi/11)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 Matrix{ComplexF64}:
 0.5+0.866025im       0.0+0.0im       …       0.0+0.0im
 0.0+0.0im       0.809017+0.587785im          0.0+0.0im
 0.0+0.0im            0.0+0.0im               0.0+0.0im
 0.0+0.0im            0.0+0.0im          0.959493+0.281733im</code></pre><p>Then you can create your unitary gate and use it like any other gate using <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a></p><pre><code class="language-julia hljs"># creates the custom gate
custom_gate = GateCustom(custom_matrix)
# Add the gate to the circuit
push!(circuit, custom_gate, 1, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-qubit circuit with 1 instructions:
└── Custom(…) @ q[1:2]</code></pre><h2 id="Composition:-Control,-Power,-Inverse,-Parallel"><a class="docs-heading-anchor" href="#Composition:-Control,-Power,-Inverse,-Parallel">Composition: Control, Power, Inverse, Parallel</a><a id="Composition:-Control,-Power,-Inverse,-Parallel-1"></a><a class="docs-heading-anchor-permalink" href="#Composition:-Control,-Power,-Inverse,-Parallel" title="Permalink"></a></h2><p>Gates in MIMIQ can be combined to create more complex gates using <a href="#Control"><code>Control</code></a>, <a href="#Power"><code>Power</code></a>, <a href="#Inverse"><code>Inverse</code></a>, <a href="#Parallel"><code>Parallel</code></a>.</p><h3 id="Control"><a class="docs-heading-anchor" href="#Control">Control</a><a id="Control-1"></a><a class="docs-heading-anchor-permalink" href="#Control" title="Permalink"></a></h3><p>A controlled version of every gate can be built using the <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.control"><code>control</code></a> function.   For example, <code>CX</code> can be built with the following instruction:</p><pre><code class="language-julia hljs">CX = control(1, GateX())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CX</code></pre><p>The first argument indicates the number of control qubits and is completely up to the user. For example a CCCCCX can be built with the following instruction:</p><pre><code class="language-julia hljs">CCCCCX = control(5, GateX())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">C₅X</code></pre><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>A wrapper for <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCX"><code>GateCX</code></a> is already provided by MIMIQ. Whenever possible, it is recommended to use the gates already provided by the framework instead of creating your own composite gate to prevent performances loss.</p></div></details><p>Be careful when adding the new control gate to your circuit. When using the <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> function, the first expected indices should be the control qubits specified in <a href="#Control"><code>Control</code></a> and the last indices the target qubits of the gate, for instance:</p><pre><code class="language-julia hljs"># here the first 5 indices are the control qubit and the last index is the target qubit of X.
push!(circuit, CCCCCX, 1, 2, 3, 4, 5, 6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-qubit circuit with 1 instructions:
└── C₅X @ q[1:5], q[6]</code></pre><h3 id="Power"><a class="docs-heading-anchor" href="#Power">Power</a><a id="Power-1"></a><a class="docs-heading-anchor-permalink" href="#Power" title="Permalink"></a></h3><p>To raise the power of a gate you can use the <a href="../../library/mimiqcircuitsbase/general/#MimiqCircuitsBase.power"><code>power</code></a> function. For example, <span>$\sqrt{\mathrm{GateS}} = \mathrm{GateT}$</span>, therefore, the following instruction can be used to generate the GateS:</p><pre><code class="language-julia hljs">power(GateS(), 1//2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">T</code></pre><details class="admonition is-details"><summary class="admonition-header">Details</summary><div class="admonition-body"><p>The power method will attempt to realize simplifications whenever it can, for example asking for the square of <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateX"><code>GateX</code></a> will directly give you <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateID"><code>GateID</code></a>.</p></div></details><h3 id="Inverse"><a class="docs-heading-anchor" href="#Inverse">Inverse</a><a id="Inverse-1"></a><a class="docs-heading-anchor-permalink" href="#Inverse" title="Permalink"></a></h3><p>To get the inverse of an operator you can use the <a href="../../library/mimiqcircuitsbase/general/#Symbolics.inverse"><code>inverse</code></a> method. Remember that the inverse of a unitary matrix is the same as the adjoint (conjugate transpose), so this is a simple way to get the adjoint of a gate. For example here is how to get the inverse of a <a href="../../library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateH"><code>GateH</code></a></p><pre><code class="language-julia hljs">inv_H = inverse(GateH())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">H</code></pre><h3 id="Parallel"><a class="docs-heading-anchor" href="#Parallel">Parallel</a><a id="Parallel-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel" title="Permalink"></a></h3><p>To create a composite gate applying a specific gate to multiple qubits at once you can use the <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.parallel"><code>parallel</code></a> method.</p><pre><code class="language-julia hljs">X_gate_4 = parallel(4, GateX())

push!(circuit, X_gate_4, 1, 2, 3, 4)

draw(circuit)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">       ┌─┐
q[1]: ╶┤X├╴
       ├─┤
q[2]: ╶┤X├╴
       ├─┤
q[3]: ╶┤X├╴
       ├─┤
q[4]: ╶┤X├╴
       └─┘</code></pre><p>To check the number of repetition of your custom parallel gate you can use the <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.numrepeats"><code>numrepeats</code></a> method:</p><pre><code class="language-julia hljs">numrepeats(X_gate_4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4</code></pre><p>Be careful when using a multi-qubit gate with <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.parallel"><code>parallel</code></a> as the index of the targeted qubits in <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> can become confusing. for example see below the parallel applicatoin of a <code>CX</code> gate:</p><pre><code class="language-julia hljs">double_CX = Parallel(2, GateCX())
push!(circuit, double_CX, 1, 2, 3, 4)
draw(circuit)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
q[1]: ╶─●─╴
       ┌┴┐
q[2]: ╶┤X├╴
       └─┘
q[3]: ╶─●─╴
       ┌┴┐
q[4]: ╶┤X├╴
       └─┘</code></pre><p>Here the index 1 and 2 correspond to the control and target of the first <code>CX</code> gate and 3 and 4 correspond to the second <code>CX</code> gate.</p><h2 id="Extract-information-of-unitary-gates"><a class="docs-heading-anchor" href="#Extract-information-of-unitary-gates">Extract information of unitary gates</a><a id="Extract-information-of-unitary-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Extract-information-of-unitary-gates" title="Permalink"></a></h2><p>MIMIQ priovides a few methods to extract information about the unitary gates.</p><h3 id="Matrix"><a class="docs-heading-anchor" href="#Matrix">Matrix</a><a id="Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix" title="Permalink"></a></h3><p>To get the matrix of a unitary gate you can use the <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.matrix"><code>matrix</code></a>:</p><pre><code class="language-julia hljs">matrix(GateCX())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 Matrix{Float64}:
 1.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0
 0.0  0.0  0.0  1.0
 0.0  0.0  1.0  0.0</code></pre><h3 id="Number-of-targets"><a class="docs-heading-anchor" href="#Number-of-targets">Number of targets</a><a id="Number-of-targets-1"></a><a class="docs-heading-anchor-permalink" href="#Number-of-targets" title="Permalink"></a></h3><p>Another way to know how many qubits, bits or z-variables are targeted by one unitary gate you can use <a href="../../library/mimiqcircuitsbase/general/#MimiqCircuitsBase.numqubits"><code>numqubits</code></a>, <a href="../../library/mimiqcircuitsbase/general/#MimiqCircuitsBase.numbits"><code>numbits</code></a> and <a href="../../library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.numzvars-Tuple{Vector{&lt;:Instruction}}"><code>numzvars</code></a>, respectively.</p><pre><code class="language-julia hljs">numqubits(GateCX()), numbits(GateCX()), numzvars(GateCX())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(2, 0, 0)</code></pre><pre><code class="language-julia hljs">numqubits(Measure()), numbits(Measure()), numzvars(Measure())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1, 1, 0)</code></pre><pre><code class="language-julia hljs">numqubits(Amplitude(bs&quot;01&quot;)), numbits(Amplitude(bs&quot;01&quot;)), numzvars(Amplitude(bs&quot;01&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0, 0, 1)</code></pre><p>See <a href="../non_unitary_ops/">non-unitary operations</a> and <a href="../statistical_ops/">statistical operations</a> pages for more information on <a href="../non_unitary_ops/#Measure"><code>Measure</code></a> and <a href="../statistical_ops/#Amplitude"><code>Amplitude</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../circuits/">« Circuits</a><a class="docs-footer-nextpage" href="../non_unitary_ops/">Non-unitary Operations »</a><div class="flexbox-break"></div><p class="footer-message">Copyright 2021-2024 QPerfect. All rights reserved.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 24 November 2024 20:55">Sunday 24 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
