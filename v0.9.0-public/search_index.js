var documenterSearchIndex = {"docs":
[{"location":"library/mimiqcircuitsbase/standard/#Standard-Gates","page":"Standard Gates","title":"Standard Gates","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/standard/","page":"Standard Gates","title":"Standard Gates","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\n    \"operations/gates/standard/u.jl\",\n    \"operations/gates/standard/phase.jl\",\n    \"operations/gates/standard/deprecated.jl\",\n    \"operations/gates/standard/pauli.jl\",\n    \"operations/gates/standard/hadamard.jl\",\n    \"operations/gates/standard/id.jl\",\n    \"operations/gates/standard/s.jl\",\n    \"operations/gates/standard/t.jl\",\n    \"operations/gates/standard/sx.jl\",\n    \"operations/gates/standard/rotations.jl\",\n    \"operations/gates/standard/swap.jl\",\n    \"operations/gates/standard/iswap.jl\",\n    \"operations/gates/standard/cpauli.jl\",\n    \"operations/gates/standard/chadamard.jl\",\n    \"operations/gates/standard/cs.jl\",\n    \"operations/gates/standard/csx.jl\",\n    \"operations/gates/standard/cu.jl\",\n    \"operations/gates/standard/cphase.jl\",\n    \"operations/gates/standard/crotations.jl\",\n    \"operations/gates/standard/ecr.jl\",\n    \"operations/gates/standard/dcx.jl\",\n    \"operations/gates/standard/interactions.jl\",\n    \"operations/gates/standard/cswap.jl\",\n    \"operations/gates/standard/cnx.jl\",\n    \"operations/gates/standard/cnp.jl\",\n]","category":"page"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateU","page":"Standard Gates","title":"MimiqCircuitsBase.GateU","text":"GateU(θ, ϕ, λ)\n\nSingle qubit generic unitary gate U(theta phi lambda), where theta, phi, and lambda are the Euler angles specified in radians.\n\nSee also GateU3, GateP, GateU2, GateU1\n\nMatrix representation\n\noperatornameU(theta phi lambda) = \n        frac12\n        beginpmatrix\n        1 + e^itheta  -i e^ilambda(1 - e^itheta) \n        i e^iphi(1 - e^itheta)  e^i(phi + lambda)(1 + e^itheta)\n        endpmatrix\n\nExamples\n\njulia> @variables θ ϕ λ\n3-element Vector{Symbolics.Num}:\n θ\n ϕ\n λ\n\njulia> GateU(θ, ϕ, λ)\nU(θ, ϕ, λ)\n\njulia> matrix(GateU(2.023, 0.5, 0.1))\n2×2 Matrix{ComplexF64}:\n  0.281526+0.449743im  -0.375769-0.759784im\n 0.0502318+0.846139im  -0.021591+0.53015im\n\njulia> c = push!(Circuit(), GateU(θ, ϕ, λ), 1)\n1-qubit circuit with 1 instructions:\n└── U(θ, ϕ, λ) @ q[1]\n\njulia> push!(c, GateU(π/8, π/2, π/4), 2)\n2-qubit circuit with 2 instructions:\n├── U(θ, ϕ, λ) @ q[1]\n└── U(π/8, π/2, π/4) @ q[2]\n\njulia> power(GateU(θ, ϕ, λ), 2), inverse(GateU(θ, ϕ, λ))\n(U(θ, ϕ, λ)^2, U(-θ, -λ, -ϕ))\n\n\nDecomposition\n\nSince, up to a global phase, the U matrix, is the most general single qubit unitary matrix, all other matrices are defined from it.\n\njulia> decompose(GateU(θ, λ, ϕ))\n1-qubit circuit with 1 instructions:\n└── U(θ, λ, ϕ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateUPhase","page":"Standard Gates","title":"MimiqCircuitsBase.GateUPhase","text":"GateUPhase(θ, ϕ, λ, γ)\n\nSingle qubit generic unitary gate U(theta phi lambda gamma), where theta, phi, and lambda are the Euler angles specified in radians, and gamma is a global phase.\n\nSee also GateU, GPhase\n\nMatrix representation\n\noperatornameU(theta phi lambda gamma) = frac12 e^igamma beginpmatrix\n        1 + e^itheta  -i e^ilambda(1 - e^itheta) \n        i e^iphi(1 - e^itheta)  e^i(phi + lambda)(1 + e^itheta)\n        endpmatrix\n\nExamples\n\njulia> @variables θ ϕ λ γ\n4-element Vector{Symbolics.Num}:\n θ\n ϕ\n λ\n γ\n\njulia> GateUPhase(θ, ϕ, λ, γ)\nU(θ, ϕ, λ, γ)\n\njulia> matrix(GateUPhase(2.023, 0.5, 0.1, 0.2))\n2×2 Matrix{ComplexF64}:\n  0.186564+0.496709im  -0.217332-0.819293im\n -0.118871+0.839252im  -0.126485+0.515293im\n\njulia> c = push!(Circuit(), GateUPhase(θ, ϕ, λ, γ), 1)\n1-qubit circuit with 1 instructions:\n└── U(θ, ϕ, λ, γ) @ q[1]\n\njulia> push!(c, GateUPhase(π/8, π/2, π/4, π/7), 2)\n2-qubit circuit with 2 instructions:\n├── U(θ, ϕ, λ, γ) @ q[1]\n└── U(π/8, π/2, π/4, π/7) @ q[2]\n\njulia> power(GateUPhase(θ, ϕ, λ, γ), 2), inverse(GateUPhase(θ, ϕ, λ, γ))\n(U(θ, ϕ, λ, γ)^2, U(-θ, -λ, -ϕ, -γ))\n\n\nDecomposition\n\nSince, up to a global phase, the U matrix, is the most general single qubit unitary matrix, all other matrices are defined from it.\n\njulia> decompose(GateUPhase(θ, λ, ϕ, γ))\n1-qubit circuit with 2 instructions:\n├── GPhase(γ) @ q[1]\n└── U(θ, λ, ϕ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateP","page":"Standard Gates","title":"MimiqCircuitsBase.GateP","text":"GateP(λ)\n\nSingle qubit Phase gate.\n\nλ is the phase angle in radians.\n\nMatrix representation\n\noperatornameP(lambda) =\noperatornameU(0 0 gλ) =\nbeginpmatrix\n    1  0 \n    0  e^ilambda\nendpmatrix\n\nExamples\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> GateP(λ)\nP(λ)\n\njulia> matrix(GateP(1.989))\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  -0.40612+0.91382im\n\njulia> c = push!(Circuit(), GateP(λ), 1)\n1-qubit circuit with 1 instructions:\n└── P(λ) @ q[1]\n\njulia> push!(c, GateP(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── P(λ) @ q[1]\n└── P(π/2) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateP(λ))\n1-qubit circuit with 1 instructions:\n└── U(0, 0, λ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateU1","page":"Standard Gates","title":"MimiqCircuitsBase.GateU1","text":"GateU1(λ)\n\nSingle qubit rotation \\operatorname{U1}(\\lambda) about the Z axis.\n\nEquivalent to GateP.\n\nMatrix representation\n\noperatornameU1(lambda) =\nbeginpmatrix\n    1  0 \n    0  e^ilambda\nendpmatrix\n\nExamples\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> GateU1(λ)\nU1(λ)\n\njulia> matrix(GateU1(0.519))\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.868316+0.496012im\n\njulia> c = push!(Circuit(), GateU1(λ), 1)\n1-qubit circuit with 1 instructions:\n└── U1(λ) @ q[1]\n\njulia> push!(c, GateU1(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── U1(λ) @ q[1]\n└── U1(π/2) @ q[2]\n\njulia> power(GateU1(λ), 2), inverse(GateU1(λ))\n(U1(λ)^2, U1(-λ))\n\n\nDecomposition\n\njulia> decompose(GateU1(λ))\n1-qubit circuit with 1 instructions:\n└── U(0, 0, λ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateU2","page":"Standard Gates","title":"MimiqCircuitsBase.GateU2","text":"GateU2(ϕ, λ)\n\nSingle qubit rotation \\operatorname{U2}(\\phi, \\lambda) about the X+Z axis.\n\nMatrix representation\n\noperatornameU2(philambda) = frac1sqrt2e^-(phi+lambda)2beginpmatrix\n1  -e^ilambda \ne^iphi  e^i(phi+lambda)\nendpmatrix\n\nExamples\n\njulia> @variables ϕ λ\n2-element Vector{Symbolics.Num}:\n ϕ\n λ\n\njulia> GateU2(ϕ, λ)\nU2(ϕ, λ)\n\njulia> matrix(GateU2(2.023, 0.5))\n2×2 Matrix{ComplexF64}:\n 0.215235-0.673553im  -0.511805+0.487909im\n 0.511805+0.487909im   0.215235+0.673553im\n\njulia> c = push!(Circuit(), GateU2(ϕ, λ), 1)\n1-qubit circuit with 1 instructions:\n└── U2(ϕ, λ) @ q[1]\n\njulia> push!(c, GateU2(π/2, π/4), 2)\n2-qubit circuit with 2 instructions:\n├── U2(ϕ, λ) @ q[1]\n└── U2(π/2, π/4) @ q[2]\n\njulia> power(GateU2(ϕ, λ), 2), inverse(GateU2(ϕ, λ))\n(U2(ϕ, λ)^2, U2(-3.141592653589793 - λ, π - ϕ))\n\n\nDecomposition\n\njulia> decompose(GateU2(ϕ, λ))\n1-qubit circuit with 2 instructions:\n├── GPhase((1//2)*(-1.5707963267948966 - λ - ϕ)) @ q[1]\n└── U(π/2, ϕ, λ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateU3","page":"Standard Gates","title":"MimiqCircuitsBase.GateU3","text":"GateU3(θ, ϕ, λ)\n\nSingle qubit generic unitary gate U3(\\theta, \\phi, \\lambda).\n\nThis gate is equivalent to the generic unitary gate GateU, differing from it only by a global phase of fracphi + lambda + theta2.\n\nMatrix representation\n\noperatornameU3(thetaphilambda) = frac12e^-i(phi + lambda + theta)2\n        beginpmatrix\n        1 + e^itheta  -i e^ilambda(1 - e^itheta) \n        i e^iphi(1 - e^itheta)  e^i(phi + lambda)(1 + e^itheta)\n        endpmatrix\n\nExamples\n\njulia> @variables θ ϕ λ\n3-element Vector{Symbolics.Num}:\n θ\n ϕ\n λ\n\njulia> GateU3(θ, ϕ, λ)\nU3(θ, ϕ, λ)\n\njulia> matrix(GateU3(2.023, 0.5, 0.1))\n2×2 Matrix{ComplexF64}:\n 0.506892-0.1568im    -0.830733+0.168398im\n 0.830733+0.168398im   0.506892+0.1568im\n\njulia> c = push!(Circuit(), GateU3(θ, ϕ, λ), 1)\n1-qubit circuit with 1 instructions:\n└── U3(θ, ϕ, λ) @ q[1]\n\njulia> push!(c, GateU3(π/8, π/2, π/4), 2)\n2-qubit circuit with 2 instructions:\n├── U3(θ, ϕ, λ) @ q[1]\n└── U3(π/8, π/2, π/4) @ q[2]\n\njulia> power(GateU3(θ, ϕ, λ), 2), inverse(GateU3(θ, ϕ, λ))\n(U3(θ, ϕ, λ)^2, U3(-θ, -λ, -ϕ))\n\n\nDecomposition\n\njulia> decompose(GateU3(θ, ϕ, λ))\n1-qubit circuit with 2 instructions:\n├── GPhase((1//2)*(-θ - λ - ϕ)) @ q[1]\n└── U(θ, ϕ, λ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateX","page":"Standard Gates","title":"MimiqCircuitsBase.GateX","text":"GateX()\n\nSingle qubit Pauli-X gate.\n\nMatrix representation\n\noperatornameX =\nbeginpmatrix\n    0  1 \n    1  0\nendpmatrix\n\nExamples\n\njulia> GateX()\nX\n\njulia> matrix(GateX())\n2×2 Matrix{Float64}:\n 0.0  1.0\n 1.0  0.0\n\njulia> c = push!(Circuit(), GateX(), 1)\n1-qubit circuit with 1 instructions:\n└── X @ q[1]\n\njulia> push!(c, GateX, 2)\n2-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── X @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateX())\n1-qubit circuit with 2 instructions:\n├── U(π, 0, π) @ q[1]\n└── GPhase(-1π/2) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateY","page":"Standard Gates","title":"MimiqCircuitsBase.GateY","text":"GateY()\n\nSingle qubit Pauli-Y gate.\n\nMatrix representation\n\noperatornameY =\nbeginpmatrix\n    0  -i \n    i  0\nendpmatrix\n\nExamples\n\njulia> GateY()\nY\n\njulia> matrix(GateY())\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0-1.0im\n 0.0+1.0im  0.0+0.0im\n\njulia> c = push!(Circuit(), GateY(), 1)\n1-qubit circuit with 1 instructions:\n└── Y @ q[1]\n\njulia> push!(c, GateY, 2)\n2-qubit circuit with 2 instructions:\n├── Y @ q[1]\n└── Y @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateY())\n1-qubit circuit with 2 instructions:\n├── U(π, π/2, π/2) @ q[1]\n└── GPhase(-1π/2) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateZ","page":"Standard Gates","title":"MimiqCircuitsBase.GateZ","text":"GateZ()\n\nSingle qubit Pauli-Z gate.\n\nMatrix representation\n\noperatornameZ =\nbeginpmatrix\n    1  0 \n    0  -1\nendpmatrix\n\nExamples\n\njulia> GateZ()\nZ\n\njulia> matrix(GateZ())\n2×2 Matrix{Float64}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> c = push!(Circuit(), GateZ(), 1)\n1-qubit circuit with 1 instructions:\n└── Z @ q[1]\n\njulia> push!(c, GateZ, 2)\n2-qubit circuit with 2 instructions:\n├── Z @ q[1]\n└── Z @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateZ())\n1-qubit circuit with 1 instructions:\n└── P(π) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateH","page":"Standard Gates","title":"MimiqCircuitsBase.GateH","text":"GateH()\n\nSingle qubit Hadamard gate.\n\nMatrix representation\n\noperatorname H =\nfrac1sqrt2\nbeginpmatrix\n    1  1 \n    1  -1\nendpmatrix\n\nExamples\n\njulia> GateH()\nH\n\njulia> matrix(GateH())\n2×2 Matrix{Float64}:\n 0.707107   0.707107\n 0.707107  -0.707107\n\njulia> c = push!(Circuit(), GateH(), 1)\n1-qubit circuit with 1 instructions:\n└── H @ q[1]\n\njulia> push!(c, GateH, 1)\n1-qubit circuit with 2 instructions:\n├── H @ q[1]\n└── H @ q[1]\n\njulia> power(GateH(), 2), inverse(GateH())\n(H^2, H)\n\n\nDecomposition\n\njulia> decompose(GateH())\n1-qubit circuit with 2 instructions:\n├── U(π/2, 0, π) @ q[1]\n└── GPhase(-1π/4) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateID","page":"Standard Gates","title":"MimiqCircuitsBase.GateID","text":"GateID()\n\nSingle qubit identity gate\n\nMatrix representation\n\noperatornameI =\nbeginpmatrix\n    1  0 \n    0  1\nendpmatrix\n\nExamples\n\njulia> GateID()\nID\n\njulia> matrix(GateID())\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\njulia> c = push!(Circuit(), GateID(), 1)\n1-qubit circuit with 1 instructions:\n└── ID @ q[1]\n\njulia> power(GateID(), 2), inverse(GateID())\n(ID, ID)\n\n\nDecomposition\n\njulia> decompose(GateID())\n1-qubit circuit with 1 instructions:\n└── U(0, 0, 0) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateID2","page":"Standard Gates","title":"MimiqCircuitsBase.GateID2","text":"GateID2()\n\nTwo-qubit identity gate\n\nSee also GateID, Parallel\n\nThe gate is implemented as a parallel application of a GateID.\n\nMatrix representation\n\noperatornameI =\nbeginpmatrix\n    1  0  0  0\n    0  1  0  0\n    0  0  1  0\n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> GateID2()\nCID\n\njulia> matrix(GateID2())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> c = push!(Circuit(), GateID2(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CID @ q[1], q[2]\n\njulia> power(GateID2(), 2), inverse(GateID2())\n(CID, CID)\n\n\nDecomposition\n\njulia> decompose(GateID2())\n2-qubit circuit with 1 instructions:\n└── CU(0, 0, 0) @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateS","page":"Standard Gates","title":"MimiqCircuitsBase.GateS","text":"GateS()\n\nSingle qubit S gate (or phase gate). It is defined as the square root of the Z gate.\n\nSee also GateSDG, GateZ, Power\n\nMatrix representation\n\noperatornameS =\nsqrtoperatornameZ =\nbeginpmatrix\n    1  0 \n    0  i\nendpmatrix\n\nExamples\n\njulia> GateS()\nS\n\njulia> matrix(GateS())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+1.0im\n\njulia> c = push!(Circuit(), GateS(), 1)\n1-qubit circuit with 1 instructions:\n└── S @ q[1]\n\njulia> push!(c, GateS, 2)\n2-qubit circuit with 2 instructions:\n├── S @ q[1]\n└── S @ q[2]\n\njulia> power(GateS(), 2), inverse(GateS())\n(Z, S†)\n\n\nDecomposition\n\njulia> decompose(GateS())\n1-qubit circuit with 1 instructions:\n└── U(0, 0, π/2) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateSDG","page":"Standard Gates","title":"MimiqCircuitsBase.GateSDG","text":"GateSDG()\n\nSingle qubit S-dagger gate (conjugate transpose of the S gate).\n\nSee also GateS, GateZ, Power, Inverse\n\nMatrix representation\n\noperatorname S^dagger =\nbeginpmatrix\n    1  0 \n    0  -i\nendpmatrix\n\nExamples\n\njulia> GateSDG()\nS†\n\njulia> matrix(GateSDG())\n2×2 adjoint(::Matrix{ComplexF64}) with eltype ComplexF64:\n 1.0-0.0im  0.0-0.0im\n 0.0-0.0im  0.0-1.0im\n\njulia> c = push!(Circuit(), GateSDG(), 1)\n1-qubit circuit with 1 instructions:\n└── S† @ q[1]\n\njulia> push!(c, GateSDG, 2)\n2-qubit circuit with 2 instructions:\n├── S† @ q[1]\n└── S† @ q[2]\n\njulia> power(GateSDG(), 2), inverse(GateSDG())\n(S†^2, S)\n\n\nDecomposition\n\njulia> decompose(GateSDG())\n1-qubit circuit with 1 instructions:\n└── U(0, 0, -1π/2) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateT","page":"Standard Gates","title":"MimiqCircuitsBase.GateT","text":"GateT()\n\nSingle qubit T gate. It is defined as the square root of the S gate, Z^frac14.\n\nSee also GateTDG, GateS, GateZ, Power\n\nMatrix representation\n\noperatornameZ =\noperatornameZ^frac14 =\nbeginpmatrix\n    1  0 \n    0  exp(fracipi4)\nendpmatrix\n\nExamples\n\njulia> GateT()\nT\n\njulia> matrix(GateT())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.707107+0.707107im\n\njulia> c = push!(Circuit(), GateT(), 1)\n1-qubit circuit with 1 instructions:\n└── T @ q[1]\n\njulia> push!(c, GateT, 2)\n2-qubit circuit with 2 instructions:\n├── T @ q[1]\n└── T @ q[2]\n\njulia> power(GateT(), 2), power(GateT(), 4), inverse(GateT())\n(S, Z, T†)\n\n\nDecomposition\n\njulia> decompose(GateT())\n1-qubit circuit with 1 instructions:\n└── U(0, 0, π/4) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateTDG","page":"Standard Gates","title":"MimiqCircuitsBase.GateTDG","text":"GateTDG()\n\nSingle qubit T-dagger gate (conjugate transpose of the T gate).\n\nSee also GateT\n\nMatrix Representation\n\noperatorname T^dagger =\nbeginpmatrix\n    1  0 \n    0  exp(frac-ipi4)\nendpmatrix\n\nExamples\n\njulia> GateTDG()\nT†\n\njulia> matrix(GateTDG())\n2×2 adjoint(::Matrix{ComplexF64}) with eltype ComplexF64:\n 1.0-0.0im       0.0-0.0im\n 0.0-0.0im  0.707107-0.707107im\n\njulia> c = push!(Circuit(), GateTDG(), 1)\n1-qubit circuit with 1 instructions:\n└── T† @ q[1]\n\njulia> push!(c, GateTDG, 2)\n2-qubit circuit with 2 instructions:\n├── T† @ q[1]\n└── T† @ q[2]\n\njulia> power(GateTDG(), 2), power(GateTDG(), 4), inverse(GateTDG())\n(T†^2, T†^4, T)\n\n\nDecomposition\n\njulia> decompose(GateTDG())\n1-qubit circuit with 1 instructions:\n└── U(0, 0, -1π/4) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateSX","page":"Standard Gates","title":"MimiqCircuitsBase.GateSX","text":"GateSX()\n\nSingle qubit sqrtX gate.\n\nSee also GateSXDG, GateX, Power\n\nMatrix representation\n\noperatornameSX =\nsqrtoperatornameX =\nfrac12\nbeginpmatrix\n    1+i  1-i \n    1-i  1+i\nendpmatrix\n\nExamples\n\njulia> GateSX()\nSX\n\njulia> matrix(GateSX())\n2×2 LinearAlgebra.Symmetric{ComplexF64, Matrix{ComplexF64}}:\n 0.5+0.5im  0.5-0.5im\n 0.5-0.5im  0.5+0.5im\n\njulia> c = push!(Circuit(), GateSX(), 1)\n1-qubit circuit with 1 instructions:\n└── SX @ q[1]\n\njulia> push!(c, GateSX, 2)\n2-qubit circuit with 2 instructions:\n├── SX @ q[1]\n└── SX @ q[2]\n\njulia> power(GateSX(), 2), inverse(GateSX())\n(X, SX†)\n\n\nDecomposition\n\njulia> decompose(GateSX())\n1-qubit circuit with 4 instructions:\n├── S† @ q[1]\n├── H @ q[1]\n├── S† @ q[1]\n└── GPhase(π/4) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateSXDG","page":"Standard Gates","title":"MimiqCircuitsBase.GateSXDG","text":"GateSXDG()\n\nSingle qubit sqrtX^dagger gate (conjugate transpose of the sqrtX gate)\n\nSee also GateSX, GateX, Power, Inverse\n\nMatrix representation\n\noperatornameSXDG =\nsqrtoperatornameX^dagger =\nfrac12\nbeginpmatrix\n    1-i  1+i \n    1+i  1-i\nendpmatrix\n\nExamples\n\njulia> GateSXDG()\nSX†\n\njulia> matrix(GateSXDG())\n2×2 adjoint(::LinearAlgebra.Symmetric{ComplexF64, Matrix{ComplexF64}}) with eltype ComplexF64:\n 0.5-0.5im  0.5+0.5im\n 0.5+0.5im  0.5-0.5im\n\njulia> c = push!(Circuit(), GateSXDG(), 1)\n1-qubit circuit with 1 instructions:\n└── SX† @ q[1]\n\njulia> push!(c, GateSXDG, 2)\n2-qubit circuit with 2 instructions:\n├── SX† @ q[1]\n└── SX† @ q[2]\n\njulia> power(GateSXDG(), 2), inverse(GateSXDG())\n(SX†^2, SX)\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateR","page":"Standard Gates","title":"MimiqCircuitsBase.GateR","text":"GateR(θ, ϕ)\n\nSingle qubit parametric rotation operatornameR(theta lambda) gate.\n\nIt performs a rotation of theta radians for the target qubit around an XY-plane axis of the Bloch sphere determined by cos(phi)mathbfx + sin(phi)mathbfy.\n\nMatrix representation\n\noperatornameR(thetaphi) =\nbeginpmatrix\n    cosfractheta2  -ie^-iphisinfractheta2 \n    -ie^-iphisinfractheta2  cosfractheta2\nendpmatrix\n\nExamples\n\njulia> @variables θ ϕ\n2-element Vector{Symbolics.Num}:\n θ\n ϕ\n\njulia> GateR(θ, ϕ)\nR(θ, ϕ)\n\njulia> matrix(GateR(2.023, 1.989))\n2×2 Matrix{ComplexF64}:\n 0.53059-2.77556e-17im  -0.77458+0.344239im\n 0.77458+0.344239im      0.53059-2.77556e-17im\n\njulia> c = push!(Circuit(), GateR(θ, ϕ), 1)\n1-qubit circuit with 1 instructions:\n└── R(θ, ϕ) @ q[1]\n\njulia> push!(c, GateR(π/2, π/4), 2)\n2-qubit circuit with 2 instructions:\n├── R(θ, ϕ) @ q[1]\n└── R(π/2, π/4) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateR(θ, ϕ))\n1-qubit circuit with 1 instructions:\n└── U3(θ, -1.5707963267948966 + ϕ, 1.5707963267948966 - ϕ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRX","page":"Standard Gates","title":"MimiqCircuitsBase.GateRX","text":"GateRX(θ)\n\nSingle qubit parametric rotation operatornameR_X(theta) gate.\n\nIt performs a rotation of theta radians around the X-axis of the Bloch sphere of the target qubit.\n\nMatrix representation\n\noperatornameR_X(theta) =\nbeginpmatrix\n    cosfractheta2  -isinfractheta2 \n    -isinfractheta2  cosfractheta2\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRX(θ)\nRX(θ)\n\njulia> matrix(GateRX(1.989))\n2×2 Matrix{ComplexF64}:\n    0.544922+0.0im       -5.55112e-17-0.838487im\n 5.55112e-17-0.838487im      0.544922+0.0im\n\njulia> c = push!(Circuit(), GateRX(θ), 1)\n1-qubit circuit with 1 instructions:\n└── RX(θ) @ q[1]\n\njulia> push!(c, GateRX(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── RX(θ) @ q[1]\n└── RX(π/2) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateRX(θ))\n1-qubit circuit with 2 instructions:\n├── U(θ, -1π/2, π/2) @ q[1]\n└── GPhase((-1//2)*θ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRY","page":"Standard Gates","title":"MimiqCircuitsBase.GateRY","text":"GateRY(θ)\n\nSingle qubit parametric rotation operatornameR_Y(theta) gate.\n\nIt performss a rotation of theta radians around the Y-axis of the Bloch sphere of the target qubit.\n\nMatrix representation\n\noperatornameR_Y(theta) =\nbeginpmatrix\n    cosfractheta2  -sinfractheta2 \n    sinfractheta2  cosfractheta2\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRY(θ)\nRY(θ)\n\njulia> matrix(GateRY(1.989))\n2×2 Matrix{ComplexF64}:\n 0.544922+0.0im  -0.838487+0.0im\n 0.838487+0.0im   0.544922+0.0im\n\njulia> c = push!(Circuit(), GateRY(θ), 1)\n1-qubit circuit with 1 instructions:\n└── RY(θ) @ q[1]\n\njulia> push!(c, GateRY(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── RY(θ) @ q[1]\n└── RY(π/2) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateRY(θ))\n1-qubit circuit with 2 instructions:\n├── U(θ, 0, 0) @ q[1]\n└── GPhase((-1//2)*θ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRZ","page":"Standard Gates","title":"MimiqCircuitsBase.GateRZ","text":"GateRZ(λ)\n\nSingle qubit parametric rotation operatornameR_Z(lambda) gate.\n\nIt performs a rotation of lambda radians around the Z-axis of the Bloch sphere for the target qubit.\n\nMatrix representation\n\noperatornameRZ(lambda) =\nbeginpmatrix\n    e^-ifraclambda2  0 \n    0  e^ifraclambda2\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRZ(θ)\nRZ(θ)\n\njulia> matrix(GateRZ(1.989))\n2×2 Matrix{ComplexF64}:\n 0.544922-0.838487im       0.0+0.0im\n      0.0+0.0im       0.544922+0.838487im\n\njulia> c = push!(Circuit(), GateRZ(θ), 1)\n1-qubit circuit with 1 instructions:\n└── RZ(θ) @ q[1]\n\njulia> push!(c, GateRZ(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── RZ(θ) @ q[1]\n└── RZ(π/2) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateRZ(θ))\n1-qubit circuit with 2 instructions:\n├── U(0, 0, θ) @ q[1]\n└── GPhase((-1//2)*θ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateSWAP","page":"Standard Gates","title":"MimiqCircuitsBase.GateSWAP","text":"GateSWAP()\n\nTwo qubit SWAP gate.\n\nSee also GateISWAP, GateCSWAP\n\nMatrix representation\n\noperatornameSWAP = frac1sqrt2\nbeginpmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  1  0  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> GateSWAP()\nSWAP\n\njulia> matrix(GateSWAP())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> c = push!(Circuit(), GateSWAP(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── SWAP @ q[1:2]\n\njulia> push!(c, GateSWAP, 3, 4)\n4-qubit circuit with 2 instructions:\n├── SWAP @ q[1:2]\n└── SWAP @ q[3:4]\n\njulia> power(GateSWAP(), 2), inverse(GateSWAP())\n(CID, SWAP)\n\n\nDecomposition\n\njulia> decompose(GateSWAP())\n2-qubit circuit with 3 instructions:\n├── CX @ q[1], q[2]\n├── CX @ q[2], q[1]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateISWAP","page":"Standard Gates","title":"MimiqCircuitsBase.GateISWAP","text":"GateISWAP()\n\nTwo qubit ISWAP gate.\n\nSee also GateSWAP.\n\nMatrix representation\n\noperatornameISWAP = frac1sqrt2\nbeginpmatrix\n    1  0  0  0 \n    0  0  i  0 \n    0  i  0  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> GateISWAP()\nISWAP\n\njulia> matrix(GateISWAP())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im\n 0.0+0.0im  0.0+1.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im\n\njulia> c = push!(Circuit(), GateISWAP(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── ISWAP @ q[1:2]\n\njulia> push!(c, GateISWAP, 3, 4)\n4-qubit circuit with 2 instructions:\n├── ISWAP @ q[1:2]\n└── ISWAP @ q[3:4]\n\njulia> power(GateISWAP(), 2), inverse(GateISWAP())\n(ISWAP^2, ISWAP†)\n\n\nDecomposition\n\njulia> decompose(GateISWAP())\n2-qubit circuit with 6 instructions:\n├── S @ q[1]\n├── S @ q[2]\n├── H @ q[1]\n├── CX @ q[1], q[2]\n├── CX @ q[2], q[1]\n└── H @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCX","page":"Standard Gates","title":"MimiqCircuitsBase.GateCX","text":"GateCX()\n\nTwo qubit Controlled-X gate (or CNOT).\n\ndetails: Details\nImplemented as an alias to Control(1, GateX()).\n\nnote: Note\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nMatrix representation\n\noperatornameCX =\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\nendpmatrix\n\nExamples\n\njulia> GateCX(), numcontrols(GateCX()), numtargets(GateCX())\n(CX, 1, 1)\n\njulia> matrix(GateCX())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n 0.0  0.0  1.0  0.0\n\njulia> c = push!(Circuit(), GateCX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CX @ q[1], q[2]\n\njulia> power(GateCX(), 2), inverse(GateCX())\n(CID, CX)\n\n\nDecomposition\n\njulia> decompose(GateCX())\n2-qubit circuit with 2 instructions:\n├── CU(π, 0, π) @ q[1], q[2]\n└── CGPhase(-1π/2) @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCY","page":"Standard Gates","title":"MimiqCircuitsBase.GateCY","text":"GateCY()\n\nTwo qubit Controlled-Y gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateY()).\n\nnote: Note\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nMatrix representation\n\noperatornameCY = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  -i \n    0  0  i  0\nendpmatrix\n\nExamples\n\njulia> GateCY(), numcontrols(GateCY()), numtargets(GateCY())\n(CY, 1, 1)\n\njulia> matrix(GateCY())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im\n\njulia> c = push!(Circuit(), GateCY(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CY @ q[1], q[2]\n\njulia> power(GateCY(), 2), inverse(GateCY())\n(CID, CY)\n\n\nDecomposition\n\njulia> decompose(GateCY())\n2-qubit circuit with 3 instructions:\n├── S† @ q[2]\n├── CX @ q[1], q[2]\n└── S @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCZ","page":"Standard Gates","title":"MimiqCircuitsBase.GateCZ","text":"GateCZ()\n\nTwo qubit Controlled-Z gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateZ()).\n\nnote: Note\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nMatrix representation\n\noperatornameCZ = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\nendpmatrix\n\nExamples\n\njulia> GateCZ(), numcontrols(GateCZ()), numtargets(GateCZ())\n(CZ, 1, 1)\n\njulia> matrix(GateCZ())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0   0.0\n 0.0  1.0  0.0   0.0\n 0.0  0.0  1.0   0.0\n 0.0  0.0  0.0  -1.0\n\njulia> c = push!(Circuit(), GateCZ(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CZ @ q[1], q[2]\n\njulia> power(GateCZ(), 2), inverse(GateCZ())\n(CID, CZ)\n\n\nDecomposition\n\njulia> decompose(GateCZ())\n2-qubit circuit with 3 instructions:\n├── H @ q[2]\n├── CX @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCH","page":"Standard Gates","title":"MimiqCircuitsBase.GateCH","text":"GateCH()\n\nTwo qubit controlled-Hadamard gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateH()).\n\nnote: Note\nBy convention, the first qubit is the control and the second is the target.\n\nMatrix representation\n\noperatornameCH = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  frac1sqrt2  frac1sqrt2 \n    0  0  frac1sqrt2  -frac1sqrt2\nendpmatrix\n\nExamples\n\njulia> GateCH(), numcontrols(GateCH), numtargets(GateCH)\n(CH, 1, 1)\n\njulia> matrix(GateCH())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0        0.0\n 0.0  1.0  0.0        0.0\n 0.0  0.0  0.707107   0.707107\n 0.0  0.0  0.707107  -0.707107\n\njulia> c = push!(Circuit(), GateCH(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CH @ q[1], q[2]\n\njulia> power(GateCH(), 2), inverse(GateCH())\n(C(H^2), CH)\n\n\nDecomposition\n\njulia> decompose(GateCH())\n2-qubit circuit with 7 instructions:\n├── S @ q[2]\n├── H @ q[2]\n├── T @ q[2]\n├── CX @ q[1], q[2]\n├── T† @ q[2]\n├── H @ q[2]\n└── S† @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCS","page":"Standard Gates","title":"MimiqCircuitsBase.GateCS","text":"GateCS()\n\nTwo qubit Controlled-S gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateS()).\n\nSee also GateS, Control.\n\nMatrix representation\n\noperatornameCS =beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  i\nendpmatrix\n\nExamples\n\njulia> GateCS(), numcontrols(GateCS()), numtargets(GateCS())\n(CS, 1, 1)\n\njulia> matrix(GateCS())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im\n\njulia> c = push!(Circuit(), GateCS(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CS @ q[1], q[2]\n\njulia> power(GateCS(), 2), inverse(GateCS())\n(CZ, C(S†))\n\n\nDecomposition\n\njulia> decompose(GateCS())\n2-qubit circuit with 1 instructions:\n└── CP(π/2) @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCSDG","page":"Standard Gates","title":"MimiqCircuitsBase.GateCSDG","text":"GateCSDG()\n\nAdjoint of two qubit Controlled-S gate.\n\ndetails: Details\nImplemented as an alias to inverse(Control(1, GateS())).\n\nSee also GateS, Control.\n\nMatrix representation\n\noperatornameCS^dagger = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -i\nendpmatrix\n\nExamples\n\njulia> GateCSDG(), numcontrols(GateCSDG()), numtargets(GateCSDG())\n(C(S†), 1, 1)\n\njulia> matrix(GateCSDG())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0-0.0im  0.0-0.0im\n 0.0+0.0im  0.0+0.0im  0.0-0.0im  0.0-1.0im\n\njulia> c = push!(Circuit(), GateCSDG(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── C(S†) @ q[1], q[2]\n\njulia> power(GateCSDG(), 2), inverse(GateCSDG())\n(C(S†^2), CS)\n\n\nDecomposition\n\njulia> decompose(GateCSDG())\n2-qubit circuit with 1 instructions:\n└── CP(-1π/2) @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCSX","page":"Standard Gates","title":"MimiqCircuitsBase.GateCSX","text":"GateCSX()\n\nTwo qubit Controled-SX gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateSX()).\n\nSee also GateSX, GateCSXDG, Control.\n\nMatrix representation\n\noperatornameCSX =beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  frac1+i2  frac1-i2 \n    0  0  frac1-i2  frac1+i2\nendpmatrix\n\nExamples\n\njulia> GateCSX(), numcontrols(GateCSX()), numtargets(GateCSX())\n(CSX, 1, 1)\n\njulia> matrix(GateCSX())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.5+0.5im  0.5-0.5im\n 0.0+0.0im  0.0+0.0im  0.5-0.5im  0.5+0.5im\n\njulia> c = push!(Circuit(), GateCSX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CSX @ q[1], q[2]\n\njulia> power(GateCSX(), 2), inverse(GateCSX())\n(CX, C(SX†))\n\n\nDecomposition\n\njulia> decompose(GateCSX())\n2-qubit circuit with 3 instructions:\n├── H @ q[2]\n├── CU1(π/2) @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCSXDG","page":"Standard Gates","title":"MimiqCircuitsBase.GateCSXDG","text":"GateCSXDG()\n\nTwo qubit CSX-dagger gate. (Control on second qubit)\n\ndetails: Details\nImplemented as an alias to Control(1, GateSXDG()).\n\nSee also GateSX, GateCSXDG, Control.\n\nMatrix representation\n\noperatornameCSX^dagger = beginpmatrix\n    1  0  0  0 \n    0  1  0  0\n    0  0  frac1-i2  frac1+i2 \n    0  0  frac1+i2  frac1-i2\nendpmatrix\n\nExamples\n\njulia> GateCSXDG(), numcontrols(GateCSXDG()), numtargets(GateCSXDG())\n(C(SX†), 1, 1)\n\njulia> matrix(GateCSXDG())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.5-0.5im  0.5+0.5im\n 0.0+0.0im  0.0+0.0im  0.5+0.5im  0.5-0.5im\n\njulia> c = push!(Circuit(), GateCSXDG(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── C(SX†) @ q[1], q[2]\n\njulia> power(GateCSXDG(), 2), inverse(GateCSXDG())\n(C(SX†^2), CSX)\n\n\nDecomposition\n\njulia> decompose(GateCSXDG())\n2-qubit circuit with 3 instructions:\n├── H @ q[2]\n├── CU1(-1π/2) @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCU","page":"Standard Gates","title":"MimiqCircuitsBase.GateCU","text":"GateCU(θ, ϕ, λ)\n\nControlled-operatornameU(theta phi lambda) gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateUPhase(θ, ϕ, λ, γ)).\n\nSee also Control, GateUPhase.\n\noperatornameCU(theta phi lambda gamma) = frac12 e^igamma beginpmatrix\n            1  0  0  0 \n            0  1  0  0 \n            0  0  1 + e^itheta  -i e^ilambda(1 - e^itheta) \n            0  0  i e^iphi(1 - e^itheta)  e^i(phi + lambda)(1 + e^itheta)\n        endpmatrix\n\nExamples\n\njulia> @variables θ ϕ λ γ\n4-element Vector{Symbolics.Num}:\n θ\n ϕ\n λ\n γ\n\njulia> GateCU(θ, ϕ, λ, γ), numcontrols(GateCU(θ, ϕ, λ, γ)), numtargets(GateCU(θ, ϕ, λ, γ))\n(CU(θ, ϕ, λ, γ), 1, 1)\n\njulia> matrix(GateCU(2.023, 0.5, 0.1, 0.2))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im        0.0+0.0im             0.0+0.0im\n 0.0+0.0im  1.0+0.0im        0.0+0.0im             0.0+0.0im\n 0.0+0.0im  0.0+0.0im   0.186564+0.496709im  -0.217332-0.819293im\n 0.0+0.0im  0.0+0.0im  -0.118871+0.839252im  -0.126485+0.515293im\n\njulia> c = push!(Circuit(), GateCU(θ, ϕ, λ, γ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CU(θ, ϕ, λ, γ) @ q[1], q[2]\n\njulia> push!(c, GateCU(π/8, π/2, π/4, π/7), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CU(θ, ϕ, λ, γ) @ q[1], q[2]\n└── CU(π/8, π/2, π/4, π/7) @ q[1], q[2]\n\njulia> power(GateCU(θ, ϕ, λ, γ), 2), inverse(GateCU(θ, ϕ, λ, γ))\n(C(U(θ, ϕ, λ, γ)^2), CU(-θ, -λ, -ϕ, -γ))\n\n\nDecomposition\n\njulia> decompose(GateCU(θ, λ, ϕ, γ))\n2-qubit circuit with 8 instructions:\n├── CGPhase(γ) @ q[1], q[2]\n├── U((1//2)*θ, 0, ϕ) @ q[2]\n├── CX @ q[1], q[2]\n├── U((1//2)*θ, (1//2)*(6.283185307179586 - λ - ϕ), π) @ q[2]\n├── CX @ q[1], q[2]\n├── P((1//2)*(λ - ϕ)) @ q[2]\n├── P((1//2)*(θ + λ + ϕ)) @ q[1]\n└── GPhase((-1//2)*θ) @ q[1:2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCP","page":"Standard Gates","title":"MimiqCircuitsBase.GateCP","text":"GateCP(θ)\n\nControlled-operatornameP(lambda) gate.\n\ndetails: Details\nImplemented as an alias to Control(GateP(θ)).\n\nSee also Control, GateRZ.\n\nExamples\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> GateCP(λ), numcontrols(GateCP(λ)), numtargets(GateCP(λ))\n(CP(λ), 1, 1)\n\njulia> matrix(GateCP(1.989))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  -0.40612+0.91382im\n\njulia> c = push!(Circuit(), GateCP(λ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CP(λ) @ q[1], q[2]\n\njulia> push!(c, GateCP(π/8), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CP(λ) @ q[1], q[2]\n└── CP(π/8) @ q[1], q[2]\n\njulia> power(GateCP(λ), 2), inverse(GateCP(λ))\n(CP(2λ), CP(-λ))\n\n\nDecomposition\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> decompose(GateCP(θ))\n2-qubit circuit with 5 instructions:\n├── P((1//2)*θ) @ q[1]\n├── CX @ q[1], q[2]\n├── P((-1//2)*θ) @ q[1]\n├── CX @ q[1], q[2]\n└── P((1//2)*θ) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCRX","page":"Standard Gates","title":"MimiqCircuitsBase.GateCRX","text":"GateCRX(θ)\n\nControlled-operatornameR_X(theta) gate.\n\ndetails: Details\nImplemented as an alias to Control(GateRX(θ)).\n\nSee also Control, GateRX.\n\nMatrix representation\n\noperatornameCRX(theta) = beginpmatrix\n            1  0  0  0 \n            0  1  0  0 \n            0  0  cosfractheta2  -isinfractheta2 \n            0  0  -isinfractheta2  cosfractheta2\n        endpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateCRX(θ), numcontrols(GateCRX(θ)), numtargets(GateCRX(θ))\n(CRX(θ), 1, 1)\n\njulia> matrix(GateCRX(1.989))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im          0.0+0.0im                0.0+0.0im\n 0.0+0.0im  1.0+0.0im          0.0+0.0im                0.0+0.0im\n 0.0+0.0im  0.0+0.0im     0.544922+0.0im       -5.55112e-17-0.838487im\n 0.0+0.0im  0.0+0.0im  5.55112e-17-0.838487im      0.544922+0.0im\n\njulia> c = push!(Circuit(), GateCRX(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CRX(θ) @ q[1], q[2]\n\njulia> push!(c, GateCRX(π/8), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CRX(θ) @ q[1], q[2]\n└── CRX(π/8) @ q[1], q[2]\n\njulia> power(GateCRX(θ), 2), inverse(GateCRX(θ))\n(CRX(2θ), CRX(-θ))\n\n\nDecomposition\n\njulia> decompose(GateCRX(θ))\n2-qubit circuit with 5 instructions:\n├── P(π/2) @ q[2]\n├── CX @ q[1], q[2]\n├── U((-1//2)*θ, 0, 0) @ q[2]\n├── CX @ q[1], q[2]\n└── U((1//2)*θ, -1π/2, 0) @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCRY","page":"Standard Gates","title":"MimiqCircuitsBase.GateCRY","text":"GateCRY(θ)\n\nControlled-operatornameR_Y(theta) gate.\n\ndetails: Details\nImplemented as an alias to Control(GateRY(θ)).\n\nSee also Control, GateRY.\n\nMatrix representation\n\noperatornameCRY(theta) = beginpmatrix\n            1  0  0  0 \n            0  1  0  0 \n            0  0  cosfractheta2  -sinfractheta2 \n            0  0   sinfractheta2  cosfractheta2\n        endpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateCRY(θ), numcontrols(GateCRY(θ)), numtargets(GateCRY(θ))\n(CRY(θ), 1, 1)\n\njulia> matrix(GateCRY(1.989))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im       0.0+0.0im        0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im        0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.544922+0.0im  -0.838487+0.0im\n 0.0+0.0im  0.0+0.0im  0.838487+0.0im   0.544922+0.0im\n\njulia> c = push!(Circuit(), GateCRY(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CRY(θ) @ q[1], q[2]\n\njulia> push!(c, GateCRY(π/8), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CRY(θ) @ q[1], q[2]\n└── CRY(π/8) @ q[1], q[2]\n\njulia> power(GateCRY(θ), 2), inverse(GateCRY(θ))\n(CRY(2θ), CRY(-θ))\n\n\nDecomposition\n\njulia> decompose(GateCRY(θ))\n2-qubit circuit with 4 instructions:\n├── RY((1//2)*θ) @ q[2]\n├── CX @ q[1], q[2]\n├── RY((-1//2)*θ) @ q[2]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCRZ","page":"Standard Gates","title":"MimiqCircuitsBase.GateCRZ","text":"GateCRZ(θ)\n\nControlled-operatornameR_Z(theta) gate.\n\ndetails: Details\nImplemented as an alias to Control(GateRZ(θ)).\n\nSee also Control, GateRZ.\n\nMatrix representation\n\n    operatornameCRZ(theta) = beginpmatrix\n            1  0  0  0 \n            0  1  0  0 \n            0  0  e^-ifraclambda2  0 \n            0  0  0  e^ifraclambda2\n        endpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateCRZ(θ), numcontrols(GateCRZ(θ)), numtargets(GateCRZ(θ))\n(CRZ(θ), 1, 1)\n\njulia> matrix(GateCRZ(1.989))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.544922-0.838487im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im       0.0+0.0im       0.544922+0.838487im\n\njulia> c = push!(Circuit(), GateCRZ(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CRZ(θ) @ q[1], q[2]\n\njulia> push!(c, GateCRZ(π/8), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CRZ(θ) @ q[1], q[2]\n└── CRZ(π/8) @ q[1], q[2]\n\njulia> power(GateCRZ(θ), 2), inverse(GateCRZ(θ))\n(CRZ(2θ), CRZ(-θ))\n\n\nDecomposition\n\njulia> decompose(GateCRZ(θ))\n2-qubit circuit with 4 instructions:\n├── RZ((1//2)*θ) @ q[2]\n├── CX @ q[1], q[2]\n├── RZ((-1//2)*θ) @ q[2]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateECR","page":"Standard Gates","title":"MimiqCircuitsBase.GateECR","text":"GateECR()\n\nTwo qubit ECR echo gate.\n\nMatrix representation\n\noperatornameECR = frac1sqrt2\nbeginpmatrix\n    0  1  0  i \n    1  0  -i  0 \n    0  i  0  1 \n    -i  0  1  0\nendpmatrix\n\nExamples\n\njulia> GateECR()\nECR\n\njulia> matrix(GateECR())\n4×4 Matrix{ComplexF64}:\n      0.0+0.0im       0.707107+0.0im       …       0.0+0.707107im\n 0.707107+0.0im            0.0+0.0im               0.0+0.0im\n      0.0+0.0im            0.0+0.707107im     0.707107+0.0im\n      0.0-0.707107im       0.0+0.0im               0.0+0.0im\n\njulia> c = push!(Circuit(), GateECR(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── ECR @ q[1:2]\n\njulia> power(GateECR(), 2), inverse(GateECR())\n(ID, ECR)\n\n\nDecomposition\n\njulia> decompose(GateECR())\n2-qubit circuit with 3 instructions:\n├── RZX(π/4) @ q[1:2]\n├── X @ q[1]\n└── RZX(-1π/4) @ q[1:2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateDCX","page":"Standard Gates","title":"MimiqCircuitsBase.GateDCX","text":"GateDCX()\n\nTwo qubit double-CNOT (control on first qubit and then second) OR DCX gate.\n\nMatrix representation\n\noperatornameDCX= beginpmatrix\n    1  0  0  0 \n    0  0  0  1 \n    0  1  0  0 \n    0  0  1  0\nendpmatrix\n\nExamples\n\njulia> GateDCX()\nDCX\n\njulia> matrix(GateDCX())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n\njulia> c = push!(Circuit(), GateDCX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── DCX @ q[1:2]\n\njulia> power(GateDCX(), 2), inverse(GateDCX())\n(DCX†, DCX†)\n\n\nDecomposition\n\njulia> decompose(GateDCX())\n2-qubit circuit with 2 instructions:\n├── CX @ q[1], q[2]\n└── CX @ q[2], q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRXX","page":"Standard Gates","title":"MimiqCircuitsBase.GateRXX","text":"GateRXX(θ)\n\nParametric two qubit X otimes X interaction \\operatorname{R}_{XX}(\\theta) gate.\n\nIt corresponds to a rotation of theta radians along the XX axis of the two-qubit Bloch sphere.\n\nSee also GateRYY, GateRZZ, GateRZX, GateXXplusYY, GateXXminusYY.\n\nMatrix representation\n\noperatornameR_XX(theta) =\nbeginpmatrix\n    cos(fractheta2)  0  0  -isin(fractheta2) \n    0  cos(fractheta2)  -isin(fractheta2)  0 \n    0  -isin(fractheta2)  cos(fractheta2)  0 \n    -isin(fractheta2)  0  0  cos(fractheta2)\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRXX(θ)\nRXX(θ)\n\njulia> matrix(GateRXX(θ))\n4×4 Matrix{Complex{Symbolics.Num}}:\n     cos((1//2)*θ)                  0                  0  -im*sin((1//2)*θ)\n                 0      cos((1//2)*θ)  -im*sin((1//2)*θ)                  0\n                 0  -im*sin((1//2)*θ)      cos((1//2)*θ)                  0\n -im*sin((1//2)*θ)                  0                  0      cos((1//2)*θ)\n\njulia> c = push!(Circuit(), GateRXX(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RXX(θ) @ q[1:2]\n\njulia> push!(c, GateRXX(π/2), 1, 2)\n2-qubit circuit with 2 instructions:\n├── RXX(θ) @ q[1:2]\n└── RXX(π/2) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateRXX(θ))\n2-qubit circuit with 7 instructions:\n├── H @ q[1]\n├── H @ q[2]\n├── CX @ q[1], q[2]\n├── RZ(θ) @ q[2]\n├── CX @ q[1], q[2]\n├── H @ q[2]\n└── H @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRYY","page":"Standard Gates","title":"MimiqCircuitsBase.GateRYY","text":"GateRYY(θ)\n\nParametric two qubit Y otimes Y interaction \\operatorname{R}_{YY}(\\theta) gate.\n\nIt corresponds to a rotation of theta radians along the YY axis of the two-qubit Bloch sphere.\n\nSee also GateRXX, GateRZZ, GateRZX, GateXXplusYY, GateXXminusYY.\n\nMatrix representation\n\noperatornameR_YY(theta) =\nbeginpmatrix\n    cos(fractheta2)  0  0  isin(fractheta2) \n    0  cos(fractheta2)  -isin(fractheta2)  0 \n    0  -isin(fractheta2)  cos(fractheta2)  0 \n    isin(fractheta2)  0  0  cos(fractheta2)\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRYY(θ)\nRYY(θ)\n\njulia> matrix(GateRYY(θ))\n4×4 Matrix{Complex{Symbolics.Num}}:\n    cos((1//2)*θ)                  0                  0  im*sin((1//2)*θ)\n                0      cos((1//2)*θ)  -im*sin((1//2)*θ)                 0\n                0  -im*sin((1//2)*θ)      cos((1//2)*θ)                 0\n im*sin((1//2)*θ)                  0                  0     cos((1//2)*θ)\n\njulia> c = push!(Circuit(), GateRYY(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RYY(θ) @ q[1:2]\n\njulia> push!(c, GateRYY(π/2), 1, 2)\n2-qubit circuit with 2 instructions:\n├── RYY(θ) @ q[1:2]\n└── RYY(π/2) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateRYY(θ))\n2-qubit circuit with 7 instructions:\n├── RX(π/2) @ q[1]\n├── RX(π/2) @ q[2]\n├── CX @ q[1], q[2]\n├── RZ(θ) @ q[2]\n├── CX @ q[1], q[2]\n├── RX(-1π/2) @ q[1]\n└── RX(-1π/2) @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRZX","page":"Standard Gates","title":"MimiqCircuitsBase.GateRZX","text":"GateRZX(θ)\n\nParametric two qubit Z otimes X interaction \\operatorname{R}_{ZX}(\\theta) gate.\n\nIt corresponds to a rotation of theta radians about ZX.\n\nSee also GateRXX, GateRYY, GateRZZ, GateXXplusYY, GateXXminusYY.\n\nMatrix representation\n\noperatornameRZX(theta) =beginpmatrix\n            cos(fractheta2)  -isin(fractheta2)  0  0 \n            -isin(fractheta2)  cos(fractheta2)  0  0 \n            0  0  cos(fractheta2)  isin(fractheta2) \n            0  0  isin(fractheta2)  cos(fractheta2)\n        endpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRZX(θ)\nRZX(θ)\n\njulia> matrix(GateRZX(θ))\n4×4 Matrix{Complex{Symbolics.Num}}:\n     cos((1//2)*θ)  -im*sin((1//2)*θ)                 0                 0\n -im*sin((1//2)*θ)      cos((1//2)*θ)                 0                 0\n                 0                  0     cos((1//2)*θ)  im*sin((1//2)*θ)\n                 0                  0  im*sin((1//2)*θ)     cos((1//2)*θ)\n\njulia> c = push!(Circuit(), GateRZX(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RZX(θ) @ q[1:2]\n\njulia> push!(c, GateRZX(π/2), 1, 2)\n2-qubit circuit with 2 instructions:\n├── RZX(θ) @ q[1:2]\n└── RZX(π/2) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateRZX(θ))\n2-qubit circuit with 5 instructions:\n├── H @ q[2]\n├── CX @ q[1], q[2]\n├── RZ(θ) @ q[2]\n├── CX @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRZZ","page":"Standard Gates","title":"MimiqCircuitsBase.GateRZZ","text":"GateRZZ(θ)\n\nParametric two qubit Z otimes Z interaction \\operatorname{R}_{ZZ}(\\theta) gate.\n\nIt corresponds to a rotation of theta radians along the ZZ axis of the two-qubit Bloch sphere.\n\nSee also GateRXX, GateRYY, GateRZX, GateXXplusYY, GateXXminusYY.\n\nMatrix representation\n\noperatornameR_ZZ(theta) =\nbeginpmatrix\n    e^-ifractheta2  0  0  0 \n    0  e^ifractheta2  0  0 \n    0  0  e^ifractheta2  0 \n    0  0  0  e^-ifractheta2\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRZZ(θ)\nRZZ(θ)\n\njulia> matrix(GateRZZ(θ))\n4×4 Matrix{Complex{Symbolics.Num}}:\n cos((-1//2)*θ) + im*sin((-1//2)*θ)  …                           0\n                          0                                      0\n                          0                                      0\n                          0             cos((-1//2)*θ) + im*sin((-1//2)*θ)\n\njulia> c = push!(Circuit(), GateRZZ(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RZZ(θ) @ q[1:2]\n\njulia> push!(c, GateRZZ(π/2), 1, 2)\n2-qubit circuit with 2 instructions:\n├── RZZ(θ) @ q[1:2]\n└── RZZ(π/2) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateRZZ(θ))\n2-qubit circuit with 3 instructions:\n├── CX @ q[1], q[2]\n├── RZ(θ) @ q[2]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateXXminusYY","page":"Standard Gates","title":"MimiqCircuitsBase.GateXXminusYY","text":"GateXXminusYY(θ, β)\n\nParametric two qubit X otimes X - Y otimes Y interaction operatorname(XX-YY)(theta beta) gate, where theta and beta are the rotation and phase angles.\n\nSee also GateRXX, GateRYY, GateRZZ, GateRZX, GateXXplusYY.\n\nMatrix Representation\n\noperatorname(XX-YY)(theta beta) =\nbeginpmatrix\n    cos(fractheta2)  0  0  -isin(fractheta2)e^-ibeta \n    0  1  0  0 \n    0  0  1  0 \n    -isin(fractheta2)e^ibeta  0  0  cos(fractheta2)\nendpmatrix\n\nExamples\n\njulia> @variables θ β\n2-element Vector{Symbolics.Num}:\n θ\n β\n\njulia> GateXXminusYY(θ, β)\nXXminusYY(θ, β)\n\njulia> matrix(GateXXminusYY(θ, β))\n4×4 Matrix{Complex{Symbolics.Num}}:\n          cos((1//2)*θ)                          …  sin(-β)*sin((1//2)*θ) - im*cos(-β)*sin((1//2)*θ)\n                      0                                                            0\n                      0                                                            0\n sin(β)*sin((1//2)*θ) - im*cos(β)*sin((1//2)*θ)                        cos((1//2)*θ)\n\njulia> c = push!(Circuit(), GateXXminusYY(θ, β), 1, 2)\n2-qubit circuit with 1 instructions:\n└── XXminusYY(θ, β) @ q[1:2]\n\njulia> push!(c, GateXXminusYY(π/2, 0.0), 1, 2)\n2-qubit circuit with 2 instructions:\n├── XXminusYY(θ, β) @ q[1:2]\n└── XXminusYY(π/2, 0π) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateXXminusYY(θ, β))\n2-qubit circuit with 14 instructions:\n├── RZ(-β) @ q[2]\n├── RZ(-1π/2) @ q[1]\n├── SX @ q[1]\n├── RZ(π/2) @ q[1]\n├── S @ q[2]\n├── CX @ q[1], q[2]\n├── RY((1//2)*θ) @ q[1]\n├── RY((-1//2)*θ) @ q[2]\n├── CX @ q[1], q[2]\n├── S† @ q[2]\n├── RZ(-1π/2) @ q[1]\n├── SX† @ q[1]\n├── RZ(π/2) @ q[1]\n└── RZ(β) @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateXXplusYY","page":"Standard Gates","title":"MimiqCircuitsBase.GateXXplusYY","text":"GateXXplusYY(θ, β)\n\nParametric two qubit X otimes X + Y otimes Y interaction operatorname(XX+YY)(theta beta) gate, where theta and beta are the rotation and phase angles.\n\nSee also GateRXX, GateRYY, GateRZZ, GateRZX, GateXXminusYY.\n\nMatrix representation\n\noperatorname(XX+YY)(theta beta) =\nbeginpmatrix\n    1  0  0  0 \n    0  cos(fractheta2)  -isin(fractheta2)e^-ibeta  0 \n    0  -isin(fractheta2)e^ibeta  cos(fractheta2)  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> @variables θ β\n2-element Vector{Symbolics.Num}:\n θ\n β\n\njulia> GateXXplusYY(θ, β)\nXXplusYY(θ, β)\n\njulia> matrix(GateXXplusYY(θ, β))\n4×4 Matrix{Complex{Symbolics.Num}}:\n 1                       0                          …  0\n 0           cos((1//2)*θ)                             0\n 0  sin(β)*sin((1//2)*θ) - im*cos(β)*sin((1//2)*θ)     0\n 0                       0                             1\n\njulia> c = push!(Circuit(), GateXXplusYY(θ, β), 1, 2)\n2-qubit circuit with 1 instructions:\n└── XXplusYY(θ, β) @ q[1:2]\n\njulia> push!(c, GateXXplusYY(π/2, 0), 1, 2)\n2-qubit circuit with 2 instructions:\n├── XXplusYY(θ, β) @ q[1:2]\n└── XXplusYY(π/2, 0) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateXXplusYY(θ, β))\n2-qubit circuit with 14 instructions:\n├── RZ(β) @ q[1]\n├── RZ(-1π/2) @ q[2]\n├── SX @ q[2]\n├── RZ(π/2) @ q[2]\n├── S @ q[1]\n├── CX @ q[2], q[1]\n├── RY((-1//2)*θ) @ q[2]\n├── RY((-1//2)*θ) @ q[1]\n├── CX @ q[2], q[1]\n├── S† @ q[1]\n├── RZ(-1π/2) @ q[2]\n├── SX† @ q[2]\n├── RZ(π/2) @ q[2]\n└── RZ(-β) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCSWAP","page":"Standard Gates","title":"MimiqCircuitsBase.GateCSWAP","text":"GateCSWAP()\n\nThree-qubit, controlled-operatornameSWAP gate.\n\ndetails: Details\nImplemented as an alias to Control{1,2,3,GateSWAP}.\n\nSee also Control, GateU.\n\nnote: Note\nBy convention, the first qubit is the control and the last two are targets.\n\nExamples\n\njulia> GateCSWAP(), numcontrols(GateCSWAP()), numtargets(GateCSWAP())\n(CSWAP, 1, 2)\n\njulia> matrix(GateCSWAP())\n8×8 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0\n\njulia> c = push!(Circuit(), GateCSWAP(), 1, 2, 3)\n3-qubit circuit with 1 instructions:\n└── CSWAP @ q[1], q[2:3]\n\njulia> power(GateCSWAP(), 2), inverse(GateCSWAP())\n(C₂ID, CSWAP)\n\n\nDecomposition\n\njulia> decompose(GateCSWAP())\n3-qubit circuit with 3 instructions:\n├── CX @ q[3], q[2]\n├── C₂X @ q[1:2], q[3]\n└── CX @ q[3], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateC3X","page":"Standard Gates","title":"MimiqCircuitsBase.GateC3X","text":"GateC3X()\n\nFour qubit, triply-controlled X gate.\n\ndetails: Details\nImplemented as an alias to Control(3 GateX()).\n\nnote: Note\nBy convention, the first three qubits are the controls and the fourth is the target.\n\nExamples\n\njulia> GateC3X(), numcontrols(GateC3X()), numtargets(GateC3X())\n(C₃X, 3, 1)\n\njulia> matrix(GateC3X())\n16×16 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  1.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n\njulia> c = push!(Circuit(), GateC3X(), 1, 2, 3, 4)\n4-qubit circuit with 1 instructions:\n└── C₃X @ q[1:3], q[4]\n\njulia> power(GateC3X(), 2), inverse(GateC3X())\n(C₃ID, C₃X)\n\n\nDecomposition\n\njulia> decompose(GateC3X())\n4-qubit circuit with 31 instructions:\n├── H @ q[4]\n├── P(π/8) @ q[1]\n├── P(π/8) @ q[2]\n├── P(π/8) @ q[3]\n├── P(π/8) @ q[4]\n├── CX @ q[1], q[2]\n├── P(-1π/8) @ q[2]\n├── CX @ q[1], q[2]\n├── CX @ q[2], q[3]\n⋮   ⋮\n├── CX @ q[1], q[4]\n├── P(π/8) @ q[4]\n├── CX @ q[3], q[4]\n├── P(-1π/8) @ q[4]\n├── CX @ q[2], q[4]\n├── P(π/8) @ q[4]\n├── CX @ q[3], q[4]\n├── P(-1π/8) @ q[4]\n├── CX @ q[1], q[4]\n└── H @ q[4]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCCX","page":"Standard Gates","title":"MimiqCircuitsBase.GateCCX","text":"GateCCX()\n\nThree-qubit, doubly-controlled X gate.\n\ndetails: Details\nImplemented as an alias to Control(2 GateX()).\n\nnote: Note\nBy convention, the first two qubits are the controls and the third is the target.\n\nExamples\n\njulia> GateCCX(), numcontrols(GateCCX()), numtargets(GateCCX())\n(C₂X, 2, 1)\n\njulia> matrix(GateCCX())\n8×8 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n\njulia> c = push!(Circuit(), GateCCX(), 1, 2, 3)\n3-qubit circuit with 1 instructions:\n└── C₂X @ q[1:2], q[3]\n\njulia> power(GateCCX(), 2), inverse(GateCCX())\n(C₂ID, C₂X)\n\n\nDecomposition\n\njulia> decompose(GateCCX())\n3-qubit circuit with 15 instructions:\n├── H @ q[3]\n├── CX @ q[2], q[3]\n├── T† @ q[3]\n├── CX @ q[1], q[3]\n├── T @ q[3]\n├── CX @ q[2], q[3]\n├── T† @ q[3]\n├── CX @ q[1], q[3]\n├── T @ q[2]\n├── T @ q[3]\n├── H @ q[3]\n├── CX @ q[1], q[2]\n├── T @ q[1]\n├── T† @ q[2]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCCP","page":"Standard Gates","title":"MimiqCircuitsBase.GateCCP","text":"GateCCP(λ)\n\nThree-qubit, doubly-controlled phase gate.\n\ndetails: Details\nImplemented as an alias to Control(2 GateP(λ)).\n\nnote: Note\nBy convention, the first two qubits are the controls and the third is the target.\n\nExamples\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> GateCCP(λ), numcontrols(GateCCP(λ)), numtargets(GateCCP(λ))\n(C₂P(λ), 2, 1)\n\njulia> matrix(GateCCP(1.989))\n8×8 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  …  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im     0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im     0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  …  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im     1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im  -0.40612+0.91382im\n\njulia> c = push!(Circuit(), GateCCP(λ), 1, 2, 3)\n3-qubit circuit with 1 instructions:\n└── C₂P(λ) @ q[1:2], q[3]\n\njulia> push!(c, GateCCP(π/8), 1, 2, 3)\n3-qubit circuit with 2 instructions:\n├── C₂P(λ) @ q[1:2], q[3]\n└── C₂P(π/8) @ q[1:2], q[3]\n\njulia> power(GateCCP(λ), 2), inverse(GateCCP(λ))\n(C₂P(2λ), C₂P(-λ))\n\n\nDecomposition\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> decompose(GateCCP(λ))\n3-qubit circuit with 5 instructions:\n├── CP((1//2)*λ) @ q[2], q[3]\n├── CX @ q[1], q[2]\n├── CP((-1//2)*λ) @ q[2], q[3]\n├── CX @ q[1], q[2]\n└── CP((1//2)*λ) @ q[1], q[3]\n\n\n\n\n\n","category":"type"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A. Barenco, C. H. Bennett, R. Cleve, D. P. DiVincenzo, N. Margolus, P. Shor, T. Sleator, J. A. Smolin and H. Weinfurter. Elementary gates for quantum computation. Phys. Rev. A 52, 3457–3467 (1995).\n\n\n\n","category":"page"},{"location":"library/mimiqlink/#Connections-to-MIMIQ","page":"MimiqLink","title":"Connections to MIMIQ","text":"","category":"section"},{"location":"library/mimiqlink/","page":"MimiqLink","title":"MimiqLink","text":"Modules = [MimiqLink]\nPrivate = false","category":"page"},{"location":"library/mimiqlink/#MimiqLink.MimiqLink","page":"MimiqLink","title":"MimiqLink.MimiqLink","text":"module MimiqLink end\n\nThis module contains convenience tools to establish and keep up a connection to the QPerfect MIMIQ services, both remote or on premises.\n\nIt allows for three different connection modes: via login page, via token, via credentials.\n\nLogin Page\n\nThis method will open a browser pointing to a login page. The user will be asked to insert username/email and password.\n\njulia> using MimiqLink\n\njulia> connection = MimiqLink.connect()\n\noptionally an address for the MIMIQ services can be specified\n\njulia> connection = MimiqLink.connect(url = \"http://127.0.0.1/api\")\n\nToken\n\nThis method will allow the user to save a token file (by login via a login page), and then load it also from another julia session.\n\njulia> using MimiqLink\n\njulia> MimiqLink.savetoken(url = \"http://127.0.0.1/api\")\n\nthis will save a token in the qperfect.json file in the current directory. In another julia session is then possible to do:\n\njulia> using MimiqLink\n\njulia> connection = MimiqLink.loadtoken(\"path/to/my/qperfect.json\")\n\nCredentials\n\nThis method will allow users to access by directly use their own credentials.\n\nwarning: Warning\nIt is strongly discuraged to use this method. If files with credentials will be shared the access to the qperfect account might be compromised.\n\njulia> using MimiqLink\n\njulia> connection = MimiqLink.connect(\"me@mymail.com\", \"myweakpassword\")\n\njulia> MimiqLink.connect(\"me@mymail.com\", \"myweakpassword\"; url = \"http://127.0.0.1/api\")\n\n\n\n\n\n","category":"module"},{"location":"library/mimiqlink/#MimiqLink.QPERFECT_CLOUD","page":"MimiqLink","title":"MimiqLink.QPERFECT_CLOUD","text":"const QPERFECT_CLOUD\n\nAddress for the QPerfect Cloud services\n\n\n\n\n\n","category":"constant"},{"location":"library/mimiqlink/#MimiqLink.QPERFECT_CLOUD2","page":"MimiqLink","title":"MimiqLink.QPERFECT_CLOUD2","text":"const QPERFECT_CLOUD2\n\nAddressfor secondary QPerfect Cloud services\n\n\n\n\n\n","category":"constant"},{"location":"library/mimiqlink/#MimiqLink.connect","page":"MimiqLink","title":"MimiqLink.connect","text":"connect([; url=QPREFECT_CLOUD])\nconnect(token[; url=QPREFECT_CLOUD])\nconnect(username, password[; url=QPREFECT_CLOUD])\n\nEstablish a connection to the MIMIQ Services.\n\nA refresh process will be spawned in the background to refresh the access credentials. An active connection can be closed by using the close(connection) method. As an example:\n\nconnection = connect(\"john.doe@example.com\", \"johnspassword\")\nclose(connection)\n\nwarning: Warning\nThe first method will open a login page in the default browser and ask for your email and password. This method is encouraged, as it will avoid saving your password as plain text in your scripts or notebooks.\n\nThere are two main servers for the MIMIQ Services: the main one and a secondary one. Users are supposed to use the main one.\n\njulia> QPERFECT_CLOUD\nURI(\"https://mimiq.qperfect.io/api\")\n\njulia> QPERFECT_CLOUD2\nURI(\"https://mimiqfast.qperfect.io/api\")\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqlink/#MimiqLink.loadtoken","page":"MimiqLink","title":"MimiqLink.loadtoken","text":"loadtoken([filename])\n\nEstablish a connection to the MIMIQ Services by loading the credentials from a JSON file.\n\nArguments\n\nfilename: file where to load the credentials (default: qperfect.json)\n\nnote: Note\n\n\nThe credentials are usually valid only for a small amount of time, so you may need to regenerate them from time to time.\n\nExamples\n\njulia> savetoken(\"myqperfectcredentials.json\")\n\njulia> connection = loadtoken(\"myqperfectcredentials.json\")\n\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqlink/#MimiqLink.savetoken","page":"MimiqLink","title":"MimiqLink.savetoken","text":"savetoken([filename][; url=QPERFECT_CLOUD)\n\nEstablish a connection to the MIMIQ Services and save the credentials in a JSON file.\n\nArguments\n\nfilename: file where to save the credentials (default: qperfect.json)\n\nKeyword arguments\n\nurl: the uri of the MIMIQ Services (default: QPERFECT_CLOUD value)\n\nExamples\n\njulia> savetoken(\"myqperfectcredentials.json\")\n\njulia> connection = loadtoken(\"myqperfectcredentials.json\")\n\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/generalized/#Generalized-gates","page":"Generalized gates","title":"Generalized gates","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/generalized/","page":"Generalized gates","title":"Generalized gates","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\n    \"operations/gphase.jl\",\n    \"operations/generalized/qft.jl\",\n    \"operations/generalized/phasegradient.jl\",\n    \"operations/generalized/polynomialoracle.jl\",\n    \"operations/generalized/diffusion.jl\",\n]","category":"page"},{"location":"library/mimiqcircuitsbase/generalized/#MimiqCircuitsBase.GPhase","page":"Generalized gates","title":"MimiqCircuitsBase.GPhase","text":"GPhase(λ)\nGPhase(numqubits, λ)\n\nOperations that applies a global phase to the targeted qubits.\n\nApplies mathrme^imath lambda I_N where I_N is 2^N times 2^N identity matrix.\n\nExamples\n\njulia> GPhase(3, λ)\nGPhase(λ)\n\njulia> numqubits(GPhase(3, λ))\n3\n\njulia> matrix(GPhase(2, π/2))\n4×4 Matrix{ComplexF64}:\n 0.0+1.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+1.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/generalized/#MimiqCircuitsBase.QFT","page":"Generalized gates","title":"MimiqCircuitsBase.QFT","text":"QFT(n)\n\nQuantum Fourier transform.\n\nPerforms the quantum Fourier transform on a register of n qubits.\n\nThe inverse quantum Fourier transform is simply given inverse(qft).\n\nIt implements the unitary transformation.\n\nfrac12^n2 sum_x=0^2^n-1 sum_y=0^2^n-1 e^2pi i fracxy2^n ketybrax\n\nExamples\n\njulia> c = push!(Circuit(), QFT(10), 1:10...)\n10-qubit circuit with 1 instructions:\n└── QFT @ q[1:10]\n\njulia> push!(c, inverse(QFT(10)), 1:10...)\n10-qubit circuit with 2 instructions:\n├── QFT @ q[1:10]\n└── QFT† @ q[1:10]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/generalized/#MimiqCircuitsBase.PhaseGradient","page":"Generalized gates","title":"MimiqCircuitsBase.PhaseGradient","text":"PhaseGradient(n)\n\nA phase gradient gate applies a phase shift to a quantum register of n qubits, where each computational basis state ketk experiences a phase proportional to its integer value k:\n\noperatornamePhaseGradient =\nsumk=0^n-1 mathrme^i frac2 piN k ketkbrak\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/generalized/#MimiqCircuitsBase.PolynomialOracle","page":"Generalized gates","title":"MimiqCircuitsBase.PolynomialOracle","text":"PolynomialOracle(xregsize, yregsize, a, b, c, d)\nPolynomialOracle(a, b, c, d) # lazy\n\nQuantum oracle for a polynomial function of two registers.\n\nApplies a pi phase shift to any basis state which satifies a xy + bx + cy + d == 0, where ketx and kety are the states of the two registers.\n\nExamples\n\njulia> c = push!(Circuit(), PolynomialOracle(5,5,1,2,3,4), 1:10...)\n10-qubit circuit with 1 instructions:\n└── PolynomialOracle(1, 2, 3, 4) @ q[1:5], q[6:10]\n\njulia> push!(c, inverse(PolynomialOracle(5,5,1,2,3,4)), 1:10...)\n10-qubit circuit with 2 instructions:\n├── PolynomialOracle(1, 2, 3, 4) @ q[1:5], q[6:10]\n└── PolynomialOracle(1, 2, 3, 4) @ q[1:5], q[6:10]\n\nwarn: Warn\nThis operation is not yet implemented for decomposition. Might not work with some backends, where is not specifically implemented.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/generalized/#MimiqCircuitsBase.Diffusion","page":"Generalized gates","title":"MimiqCircuitsBase.Diffusion","text":"Diffusion(n)\nDiffusion() # lazy\n\nGrover's diffusion operator.\n\nIt implements the unitary transformation.\n\nH^otimes n (1-2bra0^nket0^n) H^otimes n\n\nExamples\n\njulia> c = push!(Circuit(), Diffusion(10), 1:10...)\n10-qubit circuit with 1 instructions:\n└── Diffusion @ q[1:10]\n\njulia> push!(c, inverse(Diffusion(10)), 1:10...)\n10-qubit circuit with 2 instructions:\n├── Diffusion @ q[1:10]\n└── Diffusion† @ q[1:10]\n\njulia> decompose(Diffusion(4))\n4-qubit circuit with 9 instructions:\n├── RY(π/2) @ q[1]\n├── RY(π/2) @ q[2]\n├── RY(π/2) @ q[3]\n├── RY(π/2) @ q[4]\n├── C₃Z @ q[1:3], q[4]\n├── RY(π/2) @ q[1]\n├── RY(π/2) @ q[2]\n├── RY(π/2) @ q[3]\n└── RY(π/2) @ q[4]\n\n\n\n\n\n\n","category":"type"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia is required to use MimiqCircuits.jl. If you do not have it on your system, please refer to the official website. We recommend to install Julia via the juliaup tool, which will manage updates and multiple versions of Julia on the same system automatically.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the latest version of MimiqCircuitsBase.jl, use the Julia's built-in package manager (accessed by pressing ] in the Julia REPL command prompt).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Before installing the package itself, since we didn't add it to the public Julia General registry, make sure to have installed QPerfect's own package registry.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> ]\n(v1.9) pkg> registry update\n(v1.9) pkg> registry add https://github.com/qperfect-io/QPerfectRegistry.git\n(v1.9) pkg> add MimiqCircuits","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"note: Note\nThe ] registry update command will make sure, if this is your first time starting up Julia, to install and download the Julia General registry, where most packages are registered.","category":"page"},{"location":"installation/#Jupyter","page":"Installation","title":"Jupyter","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you want to use Jupyter, you need to install the Julia Jupyter kernel. This can be easily accomplished by running the following command in the julia session:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> ]\n(v1.9) pkg> add IJulia","category":"page"},{"location":"installation/#Extras","page":"Installation","title":"Extras","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Thanks to the Julia's package manager features such as weak dependencies, and extensions features, you can install extra packages that will extend the functionalities of MIMIQ-CIRC. For example, if you want to use the Quantikz package to draw quantum circuits, you can install it by running the following command in the julia session:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> ]\n(v1.9) pkg> add Quantikz","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using MimiqCircuits\nusing ImageShow # hide\nusing Quantikz\n\n# build a simple GHZ(4) circuit\nc = push!(Circuit(), GateH(), 1)\npush!(c, GateCX(), 1, 2:4)\n\n# or displaycircuit(c) if your environment supports it\ncircuit2image(c)","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"With these steps completed, you are now ready to explore the features and capabilities of MIMIQ-CIRC with Julia. Happy coding!","category":"page"},{"location":"manual/openqasm/#OpenQASM-in-MIMIQ-CIRC","page":"OpenQASM","title":"OpenQASM in MIMIQ-CIRC","text":"","category":"section"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"The remote MIMIQ-CIRC services can can readily process and execute OpenQASM files, thanks to fast and feature-complete Julia and C++ parsers and interpreters.","category":"page"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"Here is a simple comprehensive example of executing a QASM file on MIMIQ.","category":"page"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"using MimiqCircuits # hide\nusing Plots # hide\nconn = connect(ENV[\"MIMIQUSER\"], ENV[\"MIMIQPASS\"]; url=QPERFECT_CLOUD2) # hide\n# after connecting to MIMIQ\n#\n# ...\n\nqasm = \"\"\"\n// Implementation of Deutsch algorithm with two qubits for f(x)=x\n// taken from https://github.com/pnnl/QASMBench/blob/master/small/deutsch_n2/deutsch_n2.qasm\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\n\nqreg q[2];\ncreg c[2];\n\nx q[1];\nh q[0];\nh q[1];\ncx q[0],q[1];\nh q[0];\nmeasure q[0] -> c[0];\nmeasure q[1] -> c[1];\n\"\"\"\n\n# Write the OPENQASM as a file\nopen(\"/tmp/deutsch_n2.qasm\", \"w\") do io\n    write(io, qasm)\nend\n\n# actual execution of the QASM file\njob = executeqasm(conn, \"/tmp/deutsch_n2.qasm\"; algorithm=\"statevector\")\nres = getresults(conn, job)\nplot(res)","category":"page"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"For more informations, read the documentation of MimiqCircuits.executeqasm.","category":"page"},{"location":"manual/openqasm/#Behaviour-of-include-files","page":"OpenQASM","title":"Behaviour of include files","text":"","category":"section"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"A common file used by many QASM files is the qelib1.inc file. This file is not defined as being part of OpenQASM 2.0, but its usage is so widespread that it might be considered as de-facto part of the specifications.","category":"page"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"details: Details\nWe remind the careful reader that OpenQASM 2.0 specifications only define 6 operations: U,CX, measure, reset, barrier and if.","category":"page"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"If we would parse every file together with qelib1.inc, we would have at the end just a list of simple U and CX gates, leaving behind any speed improvement that we would gain by using more complex gates as a block. For this reason, if you do not provide us explicitly the include files, we would not parse the common qelib1.inc but a simplified version of it, where almost all gate definitions are replaced by opaque definitions. These opaque definitions will be converted to the corresponding MIMIQ-CIRC gates listed in MimiqCircuitsBase.GATES.","category":"page"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"Another alternative is to use the mimiqlib.inc directly in your file. For now is almost a copy of the modified qelib1.inc but in the future it will be extended to contain more gates and operations, diverging from qelib1.inc.","category":"page"},{"location":"manual/openqasm/#Relations-between-OpenQASM-registers-and-MIMIQ-indices","page":"OpenQASM","title":"Relations between OpenQASM registers and MIMIQ indices","text":"","category":"section"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"During the parsing of the QASM file, we will assign a unique index to each qubit and classical bit. This index will be used to identify the qubit or bit in the MIMIQ-CIRC service. The indices are assigned in the following way:","category":"page"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"The first qubit is assigned index 1 (Julia), the second 2, and so on.\nAll registers retain the same ordering as in the QASM file.\nQubits and classical bits behave similarly but have they have each other its own sequence from indices, starting from 1.","category":"page"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"A simple example will clarify this behaviour:","category":"page"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"OPENQASM 2.0;\nqreg q[2];\ncreg m[10];\nqreg a[10];\ncreg g[2];","category":"page"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"Will be parsed as:","category":"page"},{"location":"manual/openqasm/","page":"OpenQASM","title":"OpenQASM","text":"QASM name MIMIQ Qubit index MIMIQ Bit index\nq[0] 1 \nq[1] 2 \na[0] 3 \na[1] 4 \n... ... ...\na[9] 12 \nm[0]  1\nm[1]  2\n... ... ...\nm[9]  10\ng[0]  11\ng[1]  12","category":"page"},{"location":"library/mimiqcircuits/#Execution-utilities","page":"MimiqCircuits","title":"Execution utilities","text":"","category":"section"},{"location":"library/mimiqcircuits/","page":"MimiqCircuits","title":"MimiqCircuits","text":"Modules = [MimiqCircuits]\nPrivate = false","category":"page"},{"location":"library/mimiqcircuits/#MimiqCircuits.execute-Tuple{Connection, Circuit}","page":"MimiqCircuits","title":"MimiqCircuits.execute","text":"execute(connection, circuit[; kwargs...])\n\nExecute a quantum circuit on the MIMIQ remote services.\n\nThe circuit is applied to the zero state and the resulting state is measured via sampling. Optionally amplitudes corresponding to few selected bit states (or bitstrings) can be returned from the computation.\n\nKeyword Arguments\n\nlabel::String: mnemonic name to give to the simulation, will be visible on the web interface\nalgorithm: algorithm to use by the compuation. By default \"auto\" will select the fastest algorithm between \"statevector\" or \"mps\".\nnsamples::Integer: number of times to sample the circuit (default: 1000, maximum: 2^16)\nbitstrings::Vector{BitString}: list of bit states to compute the amplitudes for (default: BitString[])\ntimelimit: number of minutes before the computation is stopped (default: 5 minutes)\nbonddim::Int64: bond dimension for the MPS algorithm (default: 256, maximum: 4096)\nseed::Int64: a seed for running the simulation (default: random seed)\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuits/#MimiqCircuits.executeqasm-Tuple{Connection, AbstractString}","page":"MimiqCircuits","title":"MimiqCircuits.executeqasm","text":"executeqasm(connection, qasmfilepath[; kwargs...])\n\nExecute a quantum circuit on the MIMIQ remote services.\n\nThe circuit is applied to the zero state and the resulting state is measured via sampling. Optionally amplitudes corresponding to few selected bit states (or bitstrings) can be returned from the computation.\n\nKeyword Arguments\n\nlabel::String: mnemonic name to give to the simulation, will be visible on the web interface\nalgorithm: algorithm to use by the compuation. By default \"auto\" will select the fastest algorithm between \"statevector\" or \"mps\".\nnsamples::Integer: number of times to sample the circuit (default: 1000, maximum: 2^16)\nbitstrings::Vector{BitString}: list of bit states to compute the amplitudes for (default: BitString[])\ntimelimit: number of minutes before the computation is stopped (default: 5 minutes)\nbonddim::Int64: bond dimension for the MPS algorithm (default: 256, maximum: 4096)\nseed::Int64: a seed for running the simulation (default: random seed)\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuits/#MimiqCircuits.getinputs-Tuple{Connection, Execution}","page":"MimiqCircuits","title":"MimiqCircuits.getinputs","text":"getinputs(connection, execution)\n\nReturns the circuit and parameters for the given execution.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuits/#MimiqCircuits.getresults-Tuple{Connection, Execution}","page":"MimiqCircuits","title":"MimiqCircuits.getresults","text":"getresults(connection, execution; kwargs...)\n\nBlock until the given execution is finished and return the results.\n\nKeyword Arguments\n\ninterval: time interval in seconds to check for job completion (default: 1)\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuits/#MimiqCircuits.loadresults-Tuple{AbstractString}","page":"MimiqCircuits","title":"MimiqCircuits.loadresults","text":"loadresults(file)\n\nLoad results from a given file.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuits/#MimiqCircuits.saveresults-Tuple{AbstractString, QCSResults}","page":"MimiqCircuits","title":"MimiqCircuits.saveresults","text":"saveresults(file, results)\n\nSave results to a given file.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/circuits/#Quantum-Circuits-and-Instructions","page":"Quantum Circuits and Instructions","title":"Quantum Circuits and Instructions","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/circuits/","page":"Quantum Circuits and Instructions","title":"Quantum Circuits and Instructions","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\n    \"instruction.jl\",\n    \"circuit.jl\",\n    \"circuit_extras.jl\",\n    \"circuit_macro.jl\",\n    \"emplace.jl\"\n]","category":"page"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.AbstractInstruction","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.AbstractInstruction","text":"AbstractInstruction\n\nAbstract super type for all the instrcutions.\n\nAn instruction applies one or more operations to a set of qubits and classical bits.\n\nMethods\n\ngetqubit, getqubits, getbits, getbit inverse, opname, numqubits, numbits\n\nSee also\n\nInstruction, Operation\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.Instruction","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.Instruction","text":"Instruction(op, qtargets, ctargets) <: AbstractInstruction\n\nRepresentation of an operation applied to specific qubit and bit targets.\n\nExample\n\njulia> Instruction(GateX(), (1,), ())\nX @ q[1]\n\njulia> Instruction(GateCX(), (1,2), ())\nCX @ q[1], q[2]\n\njulia> Instruction(Measure(), (3,), (3,))\nMeasure @ q[3], c[3]\n\n\nSee also\n\nAbstractInstruction, Operation\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.Instruction-Union{Tuple{L}, Tuple{M}, Tuple{N}, Tuple{Operation{N, M}, Vararg{Integer, L}}} where {N, M, L}","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.Instruction","text":"Instruction(op, targets...)\n\nConstructors an instruction from an operation and a list of targets.\n\nBy convention, if op is an N-qubit and M-bit operations, then the first N targets are used as qubits and the last M as bits.\n\nExamples\n\njulia> Instruction(GateX(), 1)\nX @ q[1]\n\njulia> Instruction(GateCX(), 1,2)\nCX @ q[1], q[2]\n\njulia> Instruction(Measure(), 3, 3)\nMeasure @ q[3], c[3]\n\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.getbit","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.getbit","text":"getbit(instruction, i)\n\ni-th target classical bit of an instruction.\n\nExamples\n\njulia> inst = Instruction(Measure(), 1, 3)\nMeasure @ q[1], c[3]\n\njulia> getbit(inst, 1)\n3\n\n\nSee also\n\ngetbits, getqubit, getqubits,\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.getbits","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.getbits","text":"getbits(instruction)\n\nTuple of the classical bits which the instruction is applied to.\n\nExamples\n\njulia> inst = Instruction(Measure(), 1, 3)\nMeasure @ q[1], c[3]\n\njulia> getbits(inst)\n(3,)\n\n\nSee also\n\ngetbit, getqubits, getqubit\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.getqubit","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.getqubit","text":"getqubit(instruction, i)\n\ni-th target qubit of an instruction.\n\nExamples\n\njulia> inst = Instruction(GateCX(), 1, 3)\nCX @ q[1], q[3]\n\njulia> getqubit(inst, 2)\n3\n\n\nSee also\n\ngetqubits, getbit, getbits\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.getqubits","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.getqubits","text":"getqubits(instruction)\n\nTuple of quantum bits which the instruction is applied to.\n\njulia> inst = Instruction(GateCX(), 1, 3)\nCX @ q[1], q[3]\n\njulia> getqubits(inst)\n(1, 3)\n\n\nSee also\n\ngetqubit, getbits, getbit\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.Circuit","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.Circuit","text":"Circuit([instructions])\n\nRepresentation of a quantum circuit as a vector of instructions applied to the qubits.\n\nThe circuit can be initialized with an optional vector of instructions.\n\nSee OPERATIONS, GATES, or GENERALIZED for the list of operations to add to circuits.\n\nExamples\n\nOperation can be added one by one to a circuit with the push!(circuit, operation, targets...) function\n\njulia> c = Circuit()\nempty circuit\n\n\njulia> push!(c, GateH(), 1)\n1-qubit circuit with 1 instructions:\n└── H @ q[1]\n\njulia> push!(c, GateCX(), 1, 2)\n2-qubit circuit with 2 instructions:\n├── H @ q[1]\n└── CX @ q[1], q[2]\n\njulia> push!(c, GateRX(π / 4), 1)\n2-qubit circuit with 3 instructions:\n├── H @ q[1]\n├── CX @ q[1], q[2]\n└── RX(π/4) @ q[1]\n\njulia> push!(c, Barrier(2), 1, 3)\n3-qubit circuit with 4 instructions:\n├── H @ q[1]\n├── CX @ q[1], q[2]\n├── RX(π/4) @ q[1]\n└── Barrier @ q[1,3]\n\njulia> push!(c, Measure(), 1, 1)\n3-qubit circuit with 5 instructions:\n├── H @ q[1]\n├── CX @ q[1], q[2]\n├── RX(π/4) @ q[1]\n├── Barrier @ q[1,3]\n└── Measure @ q[1], c[1]\n\n\nTargets are not restricted to be single values, but also vectors. In this case a single push! will add multiple operations.\n\njulia> push!(Circuit(), GateCCX(), 1, 2:4, 4:10)\n6-qubit circuit with 3 instructions:\n├── C₂X @ q[1:2], q[4]\n├── C₂X @ q[1,3], q[5]\n└── C₂X @ q[1,4], q[6]\n\nis equivalent to\n\nfor (i, j) in zip(2:4, 4:10)\n    push!(c, GateCX(), 1, i)\nend\n\nNotice how the range 4:10 is not fully used, since 2:4 is shorter.\n\nDisplay\n\nTo display a a LaTeX representation of the circuit, we can just use Quantikz.jl\n\nusing Quantikz\nc = Circuit()\n...\ndisplaycircuit(c)\n\nor\n\nsavecircuit(c, \"circuit.pdf\")\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.depth-Tuple{Circuit}","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.depth","text":"depth(circuit)\n\nCompute the depth of a quantum circuit.\n\nThe depth of a quantum circuit is a metric computing the maximum time (in units of quantum gates application) between the input and output of the circuit.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.emplace!","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.emplace!","text":"emplace!(circuit, operation, registers...)\n\nEmplace an operation at the end of a circuit and applies it to the given registers.\n\njulia> emplace!(Circuit(), control(3, GateSWAP()), [1,2,3], [4,5])\n5-qubit circuit with 1 instructions:\n└── C₃SWAP @ q[1:3], q[4:5]\n\njulia> QFT()\nlazy QFT(?)\n\njulia> emplace!(Circuit(), QFT(), [1,2,3])\n3-qubit circuit with 1 instructions:\n└── QFT @ q[1:3]\n\n\n\n\n\n\n","category":"function"},{"location":"library/outline/#Library-Outline","page":"Outline","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Outline","title":"Outline","text":"Pages = [\n    \"mimiqcircuits.md\",\n    \"mimiqlink.md\",\n    \"mimiqcircuitsbase/general.md\",\n    \"mimiqcircuitsbase/circuits.md\",\n    \"mimiqcircuitsbase/operations.md\",\n    \"mimiqcircuitsbase/standard.md\",\n    \"mimiqcircuitsbase/generalized.md\",\n    \"mimiqcircuitsbase/other.md\",\n    \"mimiqcircuitsbase/bitstrings.md\",\n    \"internals.md\",\n]","category":"page"},{"location":"library/internals/#Private-types-and-functions","page":"Internals","title":"Private types and functions","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [MimiqCircuits]\nPublic  = false","category":"page"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [MimiqCircuitsBase]\nPublic  = false","category":"page"},{"location":"library/internals/#MimiqCircuitsBase.LazyArg","page":"Internals","title":"MimiqCircuitsBase.LazyArg","text":"LazyArg()\n\nPlaceholder for a lazy argument in a LazyExpr.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqCircuitsBase.LazyExpr","page":"Internals","title":"MimiqCircuitsBase.LazyExpr","text":"LazyExpr(type, args)\n\nHelps evaluating expressions lazily.\n\nEvaluation occurs only then the LazyExpr is called with some arguments, and the arguments will be passed to the inner part of the expression.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqCircuitsBase.UndefinedParameterError","page":"Internals","title":"MimiqCircuitsBase.UndefinedParameterError","text":"UndefinedParameterError(name, gatename)\n\nThe parameters of the gate are undefined. name is the name of the parameter, gatename the one of the gate.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqCircuitsBase.evaluate!","page":"Internals","title":"MimiqCircuitsBase.evaluate!","text":"evaluate!(circutit, dictionary)\n\nEvaluate the \n\n\n\n\n\n","category":"function"},{"location":"library/internals/#MimiqCircuitsBase.exponent-Union{Tuple{Power{P, N} where N}, Tuple{P}} where P","page":"Internals","title":"MimiqCircuitsBase.exponent","text":"exponent(poweroperation)\n\nExponent associated with a power operation\n\nExamples\n\njulia> MimiqCircuitsBase.exponent(power(GateH(), 2))\n2\n\njulia> MimiqCircuitsBase.exponent(GateSX())\n1//2\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#MimiqCircuitsBase.unwrappedmatrix-Tuple{T} where T<:AbstractGate","page":"Internals","title":"MimiqCircuitsBase.unwrappedmatrix","text":"unwrappedmatrix(gate)\n\nReturns the matrix associated to the specified quantum gate without the Symbolics.Num wrapper.\n\nnote: Note\nIf any of the gate's parameters is symbolic, an error is thrown.\n\nSee also matrix.\n\nExamples\n\njulia> unwrappedmatrix(GateRX(π/2))\n2×2 Matrix{ComplexF64}:\n    0.707107+5.55112e-17im       0.0-0.707107im\n 1.11022e-16-0.707107im     0.707107+5.55112e-17im\n\njulia> unwrappedmatrix(GateH())\n2×2 Matrix{Float64}:\n 0.707107   0.707107\n 0.707107  -0.707107\n\n\n\n\n\n","category":"method"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [MimiqLink]\nPublic  = false","category":"page"},{"location":"library/internals/#MimiqLink.DEFAULT_INTERVAL","page":"Internals","title":"MimiqLink.DEFAULT_INTERVAL","text":"const DEFAULT_INTERVAL\n\nDefault refresh interval for tokens (in seconds)\n\n\n\n\n\n","category":"constant"},{"location":"library/internals/#MimiqLink.Connection","page":"Internals","title":"MimiqLink.Connection","text":"struct Connection\n\nConnection with the MIMIQ Services.\n\nAttributes\n\nuri: the URI of the connected instance\ntokens_channel: channel updated with the latest refreshed token\nrefresher: task that refreshes the token on a configured interval\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqLink.Execution","page":"Internals","title":"MimiqLink.Execution","text":"struct Execution\n\nStructure referring to an execution on the MIMIQ Services.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqLink.Tokens","page":"Internals","title":"MimiqLink.Tokens","text":"struct Tokens\n\nStore access and refresh tokens\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqLink.refresh-Tuple{MimiqLink.Tokens, URIs.URI}","page":"Internals","title":"MimiqLink.refresh","text":"refresh(tokens, uri)\n\nRefresh the tokens at the given uri / instance of MIMIQ.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/bitstrings/#Bit-Strings","page":"Bit Strings","title":"Bit Strings","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/bitstrings/","page":"Bit Strings","title":"Bit Strings","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"bitstrings.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.BitString","page":"Bit Strings","title":"MimiqCircuitsBase.BitString","text":"BitString(numbits)\n\nRepresentation of the state of a register of bits. Can also represent the state of a register of qubits with defined values for each qubit (0 or 1).\n\nExamples\n\njulia> BitString(16)\n16-bits BitString with integer value 0:\n  00000000 00000000\n\njulia> bs = BitString(16, [1,2,3,4])\n16-bits BitString with integer value 15:\n  11110000 00000000\n\njulia> bs[10] = 1\n1\n\njulia> bs\n16-bits BitString with integer value 527:\n  11110000 01000000\n\njulia> bitstring_to_integer(bs)\n527\n\njulia> typeof(ans)\nBigInt\n\njulia> bitstring_to_integer(bs, Int)\n527\n\njulia> typeof(ans)\nInt64\n\nThere are many different ways to get bit states:\n\njulia> bs = BitString(30, 2344574)\n30-bits BitString with integer value 2344574:\n  01111110 01100011 11000100 000000\n\njulia> ones(BitString, 10) # or also trues(BitString, 10)\n10-bits BitString with integer value 1023:\n  11111111 11\n\njulia> zeros(BitString, 10) # or also falses(BitString, 10)\n10-bits BitString with integer value 0:\n  00000000 00\n\njulia> BitString(16) do i\n           iseven(i)\n       end\n16-bits BitString with integer value 43690:\n  01010101 01010101\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.bitstring_to_index-Tuple{BitString}","page":"Bit Strings","title":"MimiqCircuitsBase.bitstring_to_index","text":"bitstring_to_index(bitstring)\n\nConvert a bitstring into the corresponding index.\n\nThis is useful for indexing, for example, a vector of states.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.bitstring_to_integer","page":"Bit Strings","title":"MimiqCircuitsBase.bitstring_to_integer","text":"bitstring_to_integer(bitstring[, T])\n\nConvert a bitstring into its corresponding integer.\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.nonzeros-Tuple{BitString}","page":"Bit Strings","title":"MimiqCircuitsBase.nonzeros","text":"nonzeros(bitstring)\n\nReturn the indices of the non-zero qubits in a bit state.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.to01-Tuple{BitString}","page":"Bit Strings","title":"MimiqCircuitsBase.to01","text":"to01(bitstring[, endianess=:big])\n\nConverts a BitString into a string of 0 and 1 characters. Optionally endianess can be specified, which can be either :big or :little.\n\nExamples\n\njulia> to01(bs\"10011\")\n\"10011\"\n\njulia> to01(bs\"10011\"; endianess=:big)\n\"10011\"\n\njulia> to01(bs\"10011\"; endianess=:little)\n\"11001\"\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.tobits-Tuple{BitString}","page":"Bit Strings","title":"MimiqCircuitsBase.tobits","text":"tobits(bitstring)\n\nGet the underlying BitVector of a bit state.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.@bs_str-Tuple{Any}","page":"Bit Strings","title":"MimiqCircuitsBase.@bs_str","text":"macro bs_str(s)\n\nConvert a string into a bit state.\n\nExamples\n\njulia> bs\"101011\"\n6-bits BitString with integer value 53:\n  101011\n\n\n\n\n\n","category":"macro"},{"location":"library/mimiqcircuitsbase/general/#General-functions","page":"General functions","title":"General functions","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/general/","page":"General functions","title":"General functions","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"abstract.jl\", \"docstrings.jl\", \"evaluate.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.isopalias","page":"General functions","title":"MimiqCircuitsBase.isopalias","text":"isopalias(typ)\n\nChecks if a given operation type is an alias or not.\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.isunitary","page":"General functions","title":"MimiqCircuitsBase.isunitary","text":"isunitary(instruction)\nisunitary(operation)\n\nChecks if a given operation is unititary or not.\n\nSee also\n\niswrapper\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.getoperation","page":"General functions","title":"MimiqCircuitsBase.getoperation","text":"getoperation(operation)\ngetoperation(instruction)\n\nReturns the quantum operation associated to the given instruction.\n\nSee also iswrapper.\n\nExamples\n\njulia> getoperation(Instruction(GateX(), 1))\nX\n\njulia> getoperation(GateSX())\nX\n\njulia> getoperation(GateCX())\nX\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.inverse","page":"General functions","title":"MimiqCircuitsBase.inverse","text":"inverse(circuit)\ninverse(instruction)\ninverse(operation)\n\nInverse of the given circuit, instruction or operation.\n\nWhen the inverse is not a known operation, it will return an Inverse object that wraps the original operation.\n\ndetails: Details\nIt throws an error if the object is not invertible. Such for example, in the case of non unitary operations, or circuits containing Measure or Reset.\n\nSee also matrix, isunitary, power.\n\nExamples\n\njulia> inverse(GateRX(λ))\nRX(-λ)\n\njulia> inverse(GateCSX())\nC(SX†)\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.numbits","page":"General functions","title":"MimiqCircuitsBase.numbits","text":"numbits(instruction)\nnumbits(circuit)\n\nNumber of classical bits on which the given operation or instruction is defined.\n\nSee also numqubits.\n\nExamples\n\njulia> numbits(GateCX())\n0\n\njulia> numbits(Measure())\n1\n\njulia> c = Circuit(); push!(c, Measure(), 1, 1); push!(c, Measure(),1,3)\n1-qubit circuit with 2 instructions:\n├── Measure @ q[1], c[1]\n└── Measure @ q[1], c[3]\n\njulia> numbits(c)\n3\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.numqubits","page":"General functions","title":"MimiqCircuitsBase.numqubits","text":"numqubits(operation)\nnumqubits(instruction)\nnumqubits(circuit)\n\nNumber of qubits on which the given operation or instruction is defined.\n\nSee also numbits.\n\nExamples\n\njulia> numqubits(GateCX())\n2\n\njulia> numqubits(Measure())\n1\n\njulia> c = Circuit(); push!(c, GateX(), 1); push!(c, GateCX(),3,6)\n6-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── CX @ q[3], q[6]\n\njulia> numqubits(c)\n6\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.opname","page":"General functions","title":"MimiqCircuitsBase.opname","text":"opname(instruction)\nopname(operation)\n\nName of the underlying quantum operation in a human readable format.\n\nSee also numqubits, numbits.\n\nExamples\n\njulia> opname(GateX())\n\"X\"\n\njulia> opname(GateRX(π/2))\n\"RX\"\n\njulia> opname(Instruction(GateCX(),1,2))\n\"Control\"\n\njulia> opname(QFT(4))\n\"QFT\"\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.power","page":"General functions","title":"MimiqCircuitsBase.power","text":"power(operation, exponent)\n\nElevate an operation to a given exponent.\n\nIt performs simplifications when possible otherwise wraps the operation in a Power object.\n\nSee also Power, inverse, Inverse.\n\nExamples\n\njulia> power(GateX(), 1//2)\nSX\n\njulia> power(GateX(), 0.5)\nX^0.5\n\njulia> GateX()^2\nID\n\njulia> GateCSX()^2\nCX\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.evaluate","page":"General functions","title":"MimiqCircuitsBase.evaluate","text":"evaluate(object, dictionary)\n\nEvaluate all the parametric expression in object using the values specified in the given in the variable, value dictionary, returning a new object constructed on the evaluated parameters.\n\nExamples\n\nEvaluate a single parametric gate\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> g  = GateRX(θ)\nRX(θ)\n\njulia> evaluate(g, Dict(θ => 3π))\nRX(3π)\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/operations/","page":"Operations","title":"Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"operation.jl\", \"list.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Operation","page":"Operations","title":"MimiqCircuitsBase.Operation","text":"Operation{N,M}\n\nAbstract supertype for all the quantum operations acting on N qubits and M classical bits.\n\nMethods\n\niswrapper, isunitary, numbits, numqubits, opname\n\nSee also\n\nAbstractGate\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.cregsizes-Tuple{T} where T","page":"Operations","title":"MimiqCircuitsBase.cregsizes","text":"cregsizes(operation)\ncregsizes(operationtype)\n\nLength of the classicalregisters the given operation acts on.\n\nSee also\n\nqregsizes, numqubits, numbits\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.getparam","page":"Operations","title":"MimiqCircuitsBase.getparam","text":"getparam(operation, name)\n\nValue of the corresponding parameter in the given parametric operation.\n\nExamples\n\ngetparam(GateRX(π/8), :θ)\n\nSee also\n\nparnames, numparams, getparams\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.getparams","page":"Operations","title":"MimiqCircuitsBase.getparams","text":"getparams(operation)\n\nValue of the parameters in the given parametric operation.\n\nExamples\n\ngetparam(GateU(π/8, 3.1, sqrt(2)))\n\nSee also\n\nparnames, numparams, getparam\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.hilbertspacedim","page":"Operations","title":"MimiqCircuitsBase.hilbertspacedim","text":"hilbertspacedim(operation)\nhilbertspacedim(operationtype)\nhilbertspacedim(N::Integer)\n\nHilbert space dimension for the given operation. For an operation actiing on N qubits, it is 2^N.\n\nExamples\n\nhilbertspacedim(Operation{2, 1})\nhilbertspacedim(GateH)\nhilbertspacedim(GateH())\nhilbertspacedim(GateRX)\nhilbertspacedim(GateCX)\nhilbertspacedim(4)\n\nSee also\n\nnumqubits, numbits, Operation, AbstractGate\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.iswrapper","page":"Operations","title":"MimiqCircuitsBase.iswrapper","text":"iswrapper(operation)\niswrapper(operationtype)\n\nChecks if a given operation is a wrapper or not.\n\nExamples\n\niswrapper(Control)\niswrapper(GateX)\niswrapper(GateSX) # SX is defined as Power(1//2, GateX())\niswrapper(GateCX) # CX is defined as Control(1, GateX())\n\nSee also\n\nisunitary, getoperation\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.numparams","page":"Operations","title":"MimiqCircuitsBase.numparams","text":"numparams(operation)\nnumparams(operationtype)\n\nNumber of parameters for the given parametric operation. Zero for non parametric operations.\n\nBy default it returns the number of fields of the operations.\n\nExamples\n\njulia> numparams(GateH)\n0\n\njulia> numparams(GateU)\n3\n\njulia> numparams(GateRX)\n1\n\njulia> numparams(Measure)\n0\n\n\nSee also\n\nparnames, getparam\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.parnames","page":"Operations","title":"MimiqCircuitsBase.parnames","text":"parnames(operation)\nparnames(operationtype)\n\nName of the parameters allowed for the given operation.\n\nBy default it returns the fieldnames of the operation type.\n\nExamples\n\nparnames(GateH)\nparnames(GateRX)\nparnames(GateCRX)\nparnames(Measure)\n\nSee also\n\nnumparams, getparam\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.qregsizes-Tuple{T} where T","page":"Operations","title":"MimiqCircuitsBase.qregsizes","text":"qregsizes(operation)\nqregsizes(operationtype)\n\nLength of the quantum registers the given operation acts on.\n\ndetails: Details\nSome operations, such as adders or multipliers, acts on different groups of qubits (quantum registers).\n\nExamples\n\njulia> qregsizes(GateRX(0.1))\n(1,)\n\njulia> qregsizes(GateCRX(0.1))\n(1, 1)\n\njulia> qregsizes(QFT(4))\n(4,)\n\nSee also\n\ncregsizes, numqubits, numbits\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.GATES","page":"Operations","title":"MimiqCircuitsBase.GATES","text":"GATES\n\nList of gates provided by the library.\n\nSingle qubit gates\n\nGateID, GateX, GateY, GateZ, GateH, GateS, GateSDG, GateT, GateTDG, GateSX, GateSXDG.\n\nSingle qubit parametric gates\n\nGateU, GateUPhase, GateP, GateRX, GateRY, GateRZ, GateR, GateU1, GateU2, GateU3.\n\nTwo qubit gates\n\nGateID2, GateCX, GateCY, GateCZ, GateCH, GateSWAP, GateISWAP, GateCS, GateCSDG, GateCSX, GateCSXDG, GateECR, GateDCX,\n\nTwo qubit parametric gates\n\nGateCP, GateCU, GateCRX, GateCRY, GateCRZ, GateRXX, GateRYY, GateRZZ, GateRZX, GateXXplusYY, GateXXminusYY.\n\nMulti qubit Gates\n\nGateCCX, GateC3X, GateCCP, GateCSWAP.\n\nGeneralized gates\n\nThese defines an unitary quantum operation on non fixed number of qubits.\n\nSee GENERALIZED for a list of them.\n\nOperations\n\nSee OPERATIONS for a complete list of operations.\n\n\n\n\n\n","category":"constant"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.GENERALIZED","page":"Operations","title":"MimiqCircuitsBase.GENERALIZED","text":"GENERALIZED\n\nDefinition of complex unitary quantum opteration on a not fixed number of qubits, or on multiple groups of qubits (registers).\n\nUsually they are initialized with the number of qubits they operate on, or with the size of each group of qubits they act on\n\nQFT, PhaseGradient\n\n\n\n\n\n","category":"constant"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.OPERATIONS","page":"Operations","title":"MimiqCircuitsBase.OPERATIONS","text":"OPERATIONS\n\nPhases and other unitaries\n\nSee GATES for a complete list unitary gates.\n\nGPhase, GateCustom\n\nFor gate definitions and calls, see GateDecl and GateCall\n\nOther circuits elements\n\nBarrier, IfStatement\n\nModifiers\n\nControl, Parallel, Power, Inverse\n\nNon-unitary operations\n\nMeasure, Reset\n\nAlgorithms or complex gate builders\n\nSee GENERALIZED for a complete list of generalized gates or algorithms.\n\n\n\n\n\n","category":"constant"},{"location":"library/mimiqcircuitsbase/operations/#Gates","page":"Operations","title":"Gates","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/operations/","page":"Operations","title":"Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"gate.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.AbstractGate","page":"Operations","title":"MimiqCircuitsBase.AbstractGate","text":"AbstractGate{N} <: Operation{N,0}\n\nSupertype for all the N-qubit unitary gates.\n\nSee also hilbertspacedim, inverse, isunitary, matrix, numqubits, opname\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.matrix","page":"Operations","title":"MimiqCircuitsBase.matrix","text":"matrix(gate)\n\nMatrix associated to the given gate.\n\nnote: Note\nif the gate is parametric, the matrix elements are is wrapped in a Symbolics.Num object. To manipulate expressions use the Symbolics package.\n\nExamples\n\nMatrix of a simple gate\n\njulia> matrix(GateH())\n2×2 Matrix{Float64}:\n 0.707107   0.707107\n 0.707107  -0.707107\n\njulia> matrix(GateRX(π/2))\n2×2 Matrix{ComplexF64}:\n    0.707107+5.55112e-17im       0.0-0.707107im\n 1.11022e-16-0.707107im     0.707107+5.55112e-17im\n\njulia> matrix(GateCX())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n 0.0  0.0  1.0  0.0\n\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#Wrappers","page":"Operations","title":"Wrappers","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/operations/","page":"Operations","title":"Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\n    \"operations/control.jl\",\n    \"operations/inverse.jl\",\n    \"operations/power.jl\",\n    \"operations/parallel.jl\",\n    \"operations/ifstatement.jl\",\n]","category":"page"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Control","page":"Operations","title":"MimiqCircuitsBase.Control","text":"Control(numcontrols, gate) <: AbstractGate\n\nControl modifier, similar to OpenQASM 3.0 ctrl @ gate. It wraps a given gate and adds a number of controls to it.\n\nnote: Note\nBy default the first numcontrols qubits are used as controls, and the remaining ones as targets for the wrapped gate.\n\nSee also Power, Inverse, getoperation, iswrapper, numcontrols, numtargets.\n\nExamples\n\njulia> Control(1, GateX())\nCX\n\njulia> Control(3, GateH())\nC₃H\n\njulia> Control(24, GateSWAP())\nC₂₄SWAP\n\nDecomposition\n\nThe default decomposition of a Control gate is build by applying recursively Lemma 7.3 of [1]. This requires to decompose multicontrolled-X gates, which is done recursively, according to Lemma 7.2 and 7.3 of [1].\n\nHere we give a simple example of a decomposition of a C_5T gate.\n\njulia> decompose(Control(3,GateT()))\n4-qubit circuit with 9 instructions:\n├── C(Z^(1//8)) @ q[3], q[4]\n├── C₂X @ q[1:2], q[3]\n├── C((Z^(1//8))†) @ q[3], q[4]\n├── C₂X @ q[1:2], q[3]\n├── C(Z^(1//16)) @ q[2], q[4]\n├── CX @ q[1], q[2]\n├── C((Z^(1//16))†) @ q[2], q[4]\n├── CX @ q[1], q[2]\n└── C(Z^(1//16)) @ q[1], q[4]\n\ndetail: Detail\nSome decompositions have been overrided with optimized versions, to reduce the number of gates used.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Control-Union{Tuple{Operation{N, 0}}, Tuple{N}} where N","page":"Operations","title":"MimiqCircuitsBase.Control","text":"Control(gate)\n\nBuild a controlled gate with 1 control.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.control","page":"Operations","title":"MimiqCircuitsBase.control","text":"control([numcontrols], gate)\n\nBuild a multicontrolled gate.\n\nThe number of controls can be omitted to be lazily evaluated later.\n\nExamples\n\nStandard examples, with all the arguments spefcified.\n\njulia> control(1, GateX())\nCX\n\njulia> control(2, GateX())\nC₂X\n\njulia> control(3, GateCH())\nC₄H\n\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.numcontrols","page":"Operations","title":"MimiqCircuitsBase.numcontrols","text":"numcontrols(control)\n\nNumber of controls of a given multicontrolled gate.\n\nSee also\n\nControl, numtargets, numqubits\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.numtargets","page":"Operations","title":"MimiqCircuitsBase.numtargets","text":"numtargets(control)\n\nGet the number of targets of a given multicontrolled gate.\n\nExamples\n\nnumcontro\n\nSee also\n\nControl, numtargets, numqubits\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Inverse","page":"Operations","title":"MimiqCircuitsBase.Inverse","text":"Inverse(operation)\n\nInverse of the wrapped quantum operation.\n\nThe inversion is not performed right away, but only when the circuit is cached or executed.\n\nSome simplifications are already carried out at construction, for example, Inverse(Inverse(op)) is simplified as Inverse(op).\n\nwarn: Warn\nUsers should not use directly Inverse but the inverse method, which performs already all the simplifications.\n\nSee also inverse, iswrapper, Control, Power.\n\nExamples\n\njulia> Inverse(GateX())\nX†\n\njulia> Inverse(GateH())\nH†\n\njulia> Inverse(GateSX())\nSX†\n\njulia> Inverse(GateCSX())\n(CSX)†\n\njulia> Inverse(QFT(4))\nQFT†\n\n\nDecomposition\n\nDecomposition of the inverse is carring out by inverting the decomposition of the wrapped operation.\n\njulia> decompose(Inverse(GateCSX()))\n2-qubit circuit with 3 instructions:\n├── H @ q[2]\n├── CU1(-1π/2) @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Power","page":"Operations","title":"MimiqCircuitsBase.Power","text":"Power(pow, operation)\n\nWraps an operation and raises it to the given power.\n\nSome simplifications are already carried out at construction, for example Power(pow2, Power(pow1, op)) is simplified as Power(pow1 * pow2, op).\n\nnote: Note\nFor allowing simplifications, always prefer rational powers, such as 1//2 over floating point ones, such as 0.5.\n\nwarn: Warn\nUsers should not use directly Power but the power method, which performs already all the simplifications. Gates should implement the _power method instead.\n\nSee also power, Inverse , inverse.\n\nExample\n\njulia> Power(GateZ(), 1//2)\nS\n\njulia> Power(GateZ(), 2)\nZ^2\n\njulia> Power(GateCH(), 1//2)\nCH^(1//2)\n\njulia> Power(GateCX(), 1//2)\nCX^(1//2)\n\nDecomposition\n\nIn the general case, if a decomposition is not known for a given operation and power, the Power operation is not decomposed.\n\nIf the exponent is an integer, then the gate is decomposed by repeating it.\n\njulia> decompose(Power(GateH(), 2))\n1-qubit circuit with 2 instructions:\n├── H @ q[1]\n└── H @ q[1]\n\njulia> decompose(Power(GateH(), 1//2))\n1-qubit circuit with 1 instructions:\n└── H^(1//2) @ q[1]\n\njulia> decompose(Power(GateX(), 1//2)) # same as decomposing GateSX\n1-qubit circuit with 4 instructions:\n├── S† @ q[1]\n├── H @ q[1]\n├── S† @ q[1]\n└── GPhase(π/4) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Parallel","page":"Operations","title":"MimiqCircuitsBase.Parallel","text":"Parallel(repeats, operation)\n\nWrapper that applies the same operation on multiple qubits.\n\nIf the operation is a N-qubit operation, then the resulting operation is applied over N * repeats qubits.\n\nExamples\n\njulia> Parallel(5, GateX())\nParallel(5, X)\n\njulia> Parallel(3, GateRX(λ))\nParallel(3, RX(λ))\n\njulia> Parallel(2, Parallel(3, GateX()))\nParallel(2, Parallel(3, X))\n\n\nDecomposition\n\nA parallel is decomposed into a sequence of operation, one for each group of qubits.\n\njulia> decompose(Parallel(2, GateX()))\n2-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── X @ q[2]\n\njulia> decompose(Parallel(3, GateSWAP()))\n6-qubit circuit with 3 instructions:\n├── SWAP @ q[1:2]\n├── SWAP @ q[3:4]\n└── SWAP @ q[5:6]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.numrepeats","page":"Operations","title":"MimiqCircuitsBase.numrepeats","text":"numrepeats(paralleloperation)\n\nGet the number of repetitions of a parallel operation.\n\nSee also Parallel.\n\nExamples\n\njulia> numrepeats(Parallel(5, GateX()))\n5\n\njulia> numrepeats(Parallel(3, GateSWAP()))\n3\n\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.parallel","page":"Operations","title":"MimiqCircuitsBase.parallel","text":"parallel(repeats, operation)\n\nBuild a parallel operation.\n\nThe resulting operation is applied over N * repeats qubits.\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.IfStatement","page":"Operations","title":"MimiqCircuitsBase.IfStatement","text":"IfStatement(numbits, op, num)\n\nApplies the wrapper operation, only if the classical register is equal to num.\n\nwarn: Warn\nCurrentely not supported by the state vector and MPS simulators.\n\nExamples\n\npush!(IfStatement(GateX(), 10), 1,1,2,3,4,5) is the equivalent of OpenQASM 2.0\n\ncreg c[5];\nif (c==10) x q[0];\n\njulia> IfStatement(10, GateX(), 999)\nIf(c == 999) X\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#Decompositions","page":"Operations","title":"Decompositions","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/operations/","page":"Operations","title":"Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"decompose.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.decompose","page":"Operations","title":"MimiqCircuitsBase.decompose","text":"decompose(operation)\ndecompose(circuit)\n\nDecompose the given operation or circuit into a circuit of more elementary gates. If applied recursively, it will decompose the given object into a circuit of GateCX and GateU gates.\n\nSee also decompose!.\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.decompose!","page":"Operations","title":"MimiqCircuitsBase.decompose!","text":"decompose!(circuit, operation[, qtargets, ctargets])\n\nIn place version of decompose.\n\nIt decomposes the given object, appending all the resulting operations to the given circuit. The optional qtargets and ctargets arguments can be used to map the qubits and classical bits of the decomposed operation to the ones of the target circuit.\n\n\n\n\n\n","category":"function"},{"location":"library/function_index/#main-index","page":"Function Index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function Index","title":"Function Index","text":"Pages = [\n    \"mimiqcircuits.md\",\n    \"mimiqlink.md\",\n    \"mimiqcircuitsbase/general.md\",\n    \"mimiqcircuitsbase/circuits.md\",\n    \"mimiqcircuitsbase/operations.md\",\n    \"mimiqcircuitsbase/standard.md\",\n    \"mimiqcircuitsbase/generalized.md\",\n    \"mimiqcircuitsbase/other.md\",\n    \"mimiqcircuitsbase/bitstrings.md\",\n    \"internals.md\",\n]","category":"page"},{"location":"manual/execution/#Circuit-Execution-on-MIMIQ","page":"Circuit execution","title":"Circuit Execution on MIMIQ","text":"","category":"section"},{"location":"manual/execution/#Understanding-sampling-and-executions","page":"Circuit execution","title":"Understanding sampling and executions","text":"","category":"section"},{"location":"manual/execution/","page":"Circuit execution","title":"Circuit execution","text":"Executions on MIMIQ are carried out in different ways depending on the type of the circuit submitted. There are three fundamental cases based on the presence of non-unitary operations such as Measure, IfStatement, or Reset.","category":"page"},{"location":"manual/execution/#No-non-unitary-operations","page":"Circuit execution","title":"No non-unitary operations","text":"","category":"section"},{"location":"manual/execution/","page":"Circuit execution","title":"Circuit execution","text":"In this case the circuit is executed only once and the final state is sampled as many times as specified by the  number of samples (nsamples) parameter of the execution. The sampled value of all the qubits is returned (in the obvious ordering).","category":"page"},{"location":"manual/execution/#No-mid-circuit-measurements-and-no-non-unitary-operations","page":"Circuit execution","title":"No mid-circuit measurements and no non-unitary operations","text":"","category":"section"},{"location":"manual/execution/","page":"Circuit execution","title":"Circuit execution","text":"In this case the circuit is executed only once again, and the final state is sampled as many times as specified by nsamples, but only the sampled value of all the classical bits used in the circuit is returned (usually the targets of the measurements at the end of the circuit).","category":"page"},{"location":"manual/execution/#Mid-circuit-measurements-or-non-unitary-operations","page":"Circuit execution","title":"Mid-circuit measurements or non-unitary operations","text":"","category":"section"},{"location":"manual/execution/","page":"Circuit execution","title":"Circuit execution","text":"In this case the circuit is executed nsamples times, and the final state is sampled only once per run. The sampled value of all the classical bits used in the circuit is returned.","category":"page"},{"location":"manual/execution/#Fidelity-and-Error-estimates","page":"Circuit execution","title":"Fidelity and Error estimates","text":"","category":"section"},{"location":"manual/execution/","page":"Circuit execution","title":"Circuit execution","text":"Since we allow for the execution of circuits on MIMIQ with non exact methods, we return always a fidelity estimate for each execution.","category":"page"},{"location":"manual/execution/","page":"Circuit execution","title":"Circuit execution","text":"Fidelity in this case is defined as the squared modulus of the overlap between the final state obtained by the execution and the ideal one. It is a number between 0 and 1, where 1 means that the final state is exactly the one we wanted to obtain.","category":"page"},{"location":"manual/execution/","page":"Circuit execution","title":"Circuit execution","text":"The fidelity will always be 1.0 for exact methods, but it can be less than that for non exact methods.","category":"page"},{"location":"manual/execution/","page":"Circuit execution","title":"Circuit execution","text":"In the case of MPS methods, the number returned is an estimate of the actual fidelity of the state. More specifically, it is a lower bound for the fidelity, meaning that the actual fidelity will always be larger or equal to the number reported.","category":"page"},{"location":"manual/execution/","page":"Circuit execution","title":"Circuit execution","text":"The average multiqubit error estimate is the higher bound of the error done in average when applying a two qubit gate.","category":"page"},{"location":"manual/execution/#Timings","page":"Circuit execution","title":"Timings","text":"","category":"section"},{"location":"manual/execution/","page":"Circuit execution","title":"Circuit execution","text":"Name Description\napply Time used to apply all the unitaries of the circuit to the initial state. It also includes the time to allocate the initial state.\ncompression Time used to compress the circuit or convert it into a format that is more efficient for the execution on MIMIQ.\nsample Time used to sample the final state of the circuit.\namplitudes Time used to retrieve the amplitudes of the final state of the circuit.\ntotal Time elapsed from the start of the execution to the end","category":"page"},{"location":"manual/execution/","page":"Circuit execution","title":"Circuit execution","text":"When reading these timings consider that sampling only account for the time needed to sample the final state. If a circuit needs to be executed multiple time to obtain such samples, the \"sample\" time will be zero. The contrary is true for the \"apply\" time, which is the sum of the apply time for all the executions of the circuit.","category":"page"},{"location":"library/mimiqcircuitsbase/results/#Quantum-Circuit-Simulation-Results","page":"Quantum Circuit Simulation Results","title":"Quantum Circuit Simulation Results","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/results/","page":"Quantum Circuit Simulation Results","title":"Quantum Circuit Simulation Results","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"qcsresults.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/results/#MimiqCircuitsBase.QCSResults","page":"Quantum Circuit Simulation Results","title":"MimiqCircuitsBase.QCSResults","text":"QCSRresults()\nQCSRresults(simulator, version, fidelities, avggateerrors, cstates, zstates, amplitudes, timings)\n\nStorage for the results of a quantum circuit simulation.\n\nFields\n\nsimulator: name of the simulator used,\nversion: version of the simulator used,\nfidelities: fidelity estimates,\navggateerrors: average multiqubit gate errors,\ncstates: classical states content,\nzstates: complex valued states content (not used),\namplitudes: amplitudes,\ntimings: precise timings of the execution.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/module/#MimiqCircuitsBase.jl-public-documentation","page":"MimiqCircuitsBase.jl public documentation","title":"MimiqCircuitsBase.jl public documentation","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/module/","page":"MimiqCircuitsBase.jl public documentation","title":"MimiqCircuitsBase.jl public documentation","text":"Documentation for MimiqCircuitsBase.jl's public interface.","category":"page"},{"location":"library/mimiqcircuitsbase/module/#MimiqCircuitsBase","page":"MimiqCircuitsBase.jl public documentation","title":"MimiqCircuitsBase","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/module/","page":"MimiqCircuitsBase.jl public documentation","title":"MimiqCircuitsBase.jl public documentation","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"MimiqCircuitsBase.jl\"]","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"MIMIQ Circuits is a quantum computing framework and high performance simulator developed by QPerfect that allows you to develop and run your quantum algorithms beyond the limits of today's noisy intermediate scale quantum (NISQ) computers.","category":"page"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"MimiqCircuits.jl is a Julia Language package containing all the utilities and programming interfaces (APIs) to build quantum systems, connect and execute simulation on QPerfect's MIMIQ-CIRC large scale quantum circuit simulator.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To install MimiqCircuits, please open Julia's interactive session (REPL), then press the ] to start using the package manager mode, then type the following commands.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If it is the first time opening julia update the list of packages","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"update","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then add QPerfect's registry of Julia packages:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"registry add https://github.com/qperfect-io/QPerfectRegistry.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To install MimiqCircuits, to its last stable release,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"add MimiqCircuits","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Check the installation page, for more details, and our first tutorial for sample usage.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this guide, we will walk you through the fundamental procedures for simulating a quantum circuit using MIMIQ-CIRC product developed by QPerfect. Throughout the tutorial, we will furnish links to detailed documentation and examples that can provide a deeper understanding of each topic.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to use MIMIQ-CIRC, we need to first load the MimiqCircuit Julia module within your workspace by following this step:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using MimiqCircuits","category":"page"},{"location":"tutorial/#Building-a-Quantum-circuit","page":"Tutorial","title":"Building a Quantum circuit","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first step in executing quantum algorithm on MIMIQ-CIRC always consists in defining one implementation of the algorithm as a quantum circuit, a sequence of quantum operations (quantum gates, measurements, resets, etc...) that act on a set of qubits. In MIMIQ-CIRC we always start by defining an empty circuit","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using MimiqCircuits # hide\ncircuit = Circuit()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In MimiqCircuits we do not need to specify the number of qubits of a circuit, or a list of quantum registers to use. Qubits will be allocated up to the maximum used index. Since in Julia indices start counting from one, also qubits indices are allowed values between 1 and 2^63-1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A circuit is made up of quantum operations. Gates, or unitary operations, are the simplest and most common ones. Lists are provided by the documentation of MimiqCircuitsBase.OPERATIONS, MimiqCircuitsBase.GATES and MimiqCircuitsBase.GENERALIZED, which can also be simply accessed by","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"?GATES","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To add gates to circuits in Julia we will be using the puhs! function, which takes multiple arguments, but usually: the circuit to add the operation to, the operation to be added, and as many target qubits as possible.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this first simple example [MimiqCircuitsBase.GateH], only needs one target","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"push!(circuit, GateH(), 1)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The text representation H @ q[1] informs us that there is an instruction which applies the Hadamard gate to the qubit of index 1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Multiple gates can be added at once through the same push! syntax. In the following example we add 9 CX or control-X gates between the qubit 1 and all the qubits from 2 to 10.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"push!(circuit, GateCX(), 1, 2:10)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This syntax is not dissimilar to the OpenQASM one, and can be seen as equivalent of","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"for i in 2:10\n    push!(circuit, GateCX(), 1, i)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The same is true for adding operations that act also on classical bits","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"push!(circuit, Measure(), 1:10, 1:10)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which is equivalent to","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"for i in 1:10\n    push!(circuit, Measure(), i, i)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The number of quantum bits and classical bits of a circuit is defined by the maximum index used, so in this case 10 for both.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"numqubits(circuit), numbits(circuit)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"With these informations, it is already possible to build any quantum circuit. However, for alternative advanced circuit building utilities see the documentation of MimiqCircuitsBase.emplace!, and MimiqCircuitsBase.Circuit.","category":"page"},{"location":"tutorial/#Remote-execution-on-MIMIQ-CIRC","page":"Tutorial","title":"Remote execution on MIMIQ-CIRC","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to execute the implemented circuit on MIMIQ-CIRC three more steps are required:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"opening a connection to the MIMIQ Remote Services,\nsend a circuit for execution,\nretrieve the results of the execution.","category":"page"},{"location":"tutorial/#Connecting-to-MIMIQ","page":"Tutorial","title":"Connecting to MIMIQ","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In most cases, connecting to MIMIQ can achieved by a single instruction","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"conn = connect()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"conn = connect(ENV[\"MIMIQUSER\"], ENV[\"MIMIQPASS\"]; url=QPERFECT_CLOUD2) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For more options please see the documentation of MimiqLink.connect. If executed without supplemental arguments, connect() will start a local webpage and will try to open it with your default browser. As an alternative, connect(\"john.smith@example.com\", \"jonspassword\") allows to insert directly the username and password of the user.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nIn order to complete this step you need an active subscription to MIMIQ-CIRC. To obtain one, please contact us or, if your organization already has a subscription, contact the organization account holder.","category":"page"},{"location":"tutorial/#Executing-a-circuit-on-MIMIQ","page":"Tutorial","title":"Executing a circuit on MIMIQ","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once a connection is established an execution can be sent to the remote services.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"job = execute(conn, circuit)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This will execute a simulation of the given circuit with default parameters. The default choice of algorithm is \"auto\".  Generally, there are three available options:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"\"auto\" for the automatically selecting the best algorithm according to circuit size and complexity,\n\"statevector\" for a highly optimized state vector engine, and\n\"mps\" for a large-scale Matrix Product States (MPS) method.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Check out the documentation of the MimiqCircuits.execute function, for details.","category":"page"},{"location":"tutorial/#OpenQASM","page":"Tutorial","title":"OpenQASM","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"OpenQASM files, defining quantum algorithms can be executed on MIMIQ in the same way native circuits can, simply use MimiqCircuits.executeqasm and provide the path of the file to upload. See the OpenQASM page for more details on how include files are handled.","category":"page"},{"location":"tutorial/#Retrieving-execution-results","page":"Tutorial","title":"Retrieving execution results","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once the execution has terminated on MIMIQ, the results can be retrieved via the MimiqCircuits.getresults function, which returns a MimiqCircuitsBase.QCSResults structure.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"res = getresults(conn, job)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Name and version of the simulator, samples, and timings can be retrieved from the aggregated results. For example, to make an histogram out of the retrieved samples, it suffices to execute","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"histsamples(res)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To plot the results (works both with Plots.jl and Makie.jl)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplot(res)","category":"page"},{"location":"tutorial/#Retrieving-submitted-remote-jobs","page":"Tutorial","title":"Retrieving submitted remote jobs","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"c, params = getinputs(conn, job)\n\n# showing back the executed circuit, retrieeved from MIMIQ\nc","category":"page"},{"location":"library/mimiqcircuitsbase/other/#Other-Operations","page":"Other Operations","title":"Other Operations","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/other/#Custom-gates","page":"Other Operations","title":"Custom gates","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/other/","page":"Other Operations","title":"Other Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"custom.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.GateCustom","page":"Other Operations","title":"MimiqCircuitsBase.GateCustom","text":"struct GateCustom{N,T} <: AbstractGate{N}\n\nN qubit gate specified by a 2^N times 2^N matrix with elements of type T.\n\nUse this to construct your own gates based on unitary matrices. Currently only N=1,2 (M=2,4) are recognised.\n\nMIMIQ uses textbook convention for specifying gates.\n\nOne qubit gate matrices are defined in the basis 0rangle, 1rangle e.g.,\n\noperatornameZ =\nbeginpmatrix\n    10\n    0-1\nendpmatrix\n\nTwo qubit gate matrices are defined in the basis 00rangle, 01rangle>, 10rangle, 11rangle where the left-most qubit is the first to appear in the target list e.g.,\n\noperatornameCNOT =\nbeginpmatrix\n    1000\n    0100\n    0001\n    0010\nendpmatrix\n\njulia> CNOT = [1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]\n4×4 Matrix{Int64}:\n 1  0  0  0\n 0  1  0  0\n 0  0  0  1\n 0  0  1  0\n\njulia> # CNOT gate with control on q1 and target on q2\n\njulia> Instruction(GateCustom(CNOT), 1, 2)\nGateCustom([1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]) @ q1, q2\n\n# Examples\n\n\njldoctest julia> g = GateCustom([1 0; 0 1]) Custom([1.0 0.0; 0.0 1.0])\n\njulia> push!(Circuit(), g, 1) 1-qubit circuit with 1 instructions: └── Custom([1.0 0.0; 0.0 1.0]) @ q1 ```\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#Gate-definitions","page":"Other Operations","title":"Gate definitions","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/other/","page":"Other Operations","title":"Other Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"gatedecl.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.GateCall","page":"Other Operations","title":"MimiqCircuitsBase.GateCall","text":"GateCall(decl, args...)\n\nGate corresponding to a call to a GateDecl definition.\n\nIt is created by calling a GateDecl with the proper number of arguments.\n\nExamples\n\njulia> decl = @gatedecl ansatz(θ) = begin\n           insts = Instruction[]\n           push!(insts, Instruction(GateX(), 1))\n           push!(insts, Instruction(GateRX(θ), 2))\n           return insts\n       end;\n\n\njulia> @variables λ;\n\n\njulia> decl(λ)\nansatz(λ)\n\n\nSee also\n\nGateDecl\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.GateDecl","page":"Other Operations","title":"MimiqCircuitsBase.GateDecl","text":"GateDecl(name, args, instructions)\n\nDefine a new gate of given name, arguments and instructions.\n\nExamples\n\nA simple gate declaration, via the @gatedecl macro:\n\njulia> decl = @gatedecl ansatz(θ) = begin\n           insts = Instruction[]\n           push!(insts, Instruction(GateX(), 1))\n           push!(insts, Instruction(GateRX(θ), 2))\n           return insts\n       end\ngate ansatz(θ) =\n├── X @ q[1]\n└── RX(θ) @ q[2]\n\njulia> @variables λ;\n\n\njulia> decompose(decl(λ))\n2-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── RX(λ) @ q[2]\n\n\nSee also\n\nGateCall\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#Non-unitary-operations","page":"Other Operations","title":"Non-unitary operations","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/other/","page":"Other Operations","title":"Other Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"reset.jl\", \"measure.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.Reset","page":"Other Operations","title":"MimiqCircuitsBase.Reset","text":"Reset()\n\nQuantum operation that resets the status of one qubit to the ket0 state.\n\nSee also Operation, Measure.\n\nExamples\n\njulia> Reset()\nReset\n\njulia> c = push!(Circuit(), Reset, 1)\n1-qubit circuit with 1 instructions:\n└── Reset @ q[1]\n\njulia> push!(c, Reset(), 3)\n3-qubit circuit with 2 instructions:\n├── Reset @ q[1]\n└── Reset @ q[3]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.Measure","page":"Other Operations","title":"MimiqCircuitsBase.Measure","text":"Measure()\n\nSingle qubit measurement operation in the computational basis\n\nThe operation projects the quantum states and stores the result of such measurement is stored in a classical register.\n\nwarn: Warn\nMeasure is non-reversible.\n\nSee also Operation, Reset.\n\nExamples\n\njulia> Measure()\nMeasure\n\njulia> c = push!(Circuit(), Measure, 1, 1)\n1-qubit circuit with 1 instructions:\n└── Measure @ q[1], c[1]\n\njulia> push!(c, Measure(), 3, 4)\n3-qubit circuit with 2 instructions:\n├── Measure @ q[1], c[1]\n└── Measure @ q[3], c[4]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#No-ops","page":"Other Operations","title":"No-ops","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/other/","page":"Other Operations","title":"Other Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"barrier.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.Barrier","page":"Other Operations","title":"MimiqCircuitsBase.Barrier","text":"Barrier(numqubits)\n\nNo-op operation that does not affect the quantum state or the execution of a circuit, but prevents compression or optimization across it.\n\nExamples\n\njulia> Barrier(1)\nBarrier\n\njulia> Barrier(2)\nBarrier\n\njulia> c = push!(Circuit(), Barrier(1), 1)\n1-qubit circuit with 1 instructions:\n└── Barrier @ q[1]\n\njulia> push!(c, Barrier(1), 1:3)\n3-qubit circuit with 4 instructions:\n├── Barrier @ q[1]\n├── Barrier @ q[1]\n├── Barrier @ q[2]\n└── Barrier @ q[3]\n\njulia> push!(c, Barrier(3), 1,2,3)\n3-qubit circuit with 5 instructions:\n├── Barrier @ q[1]\n├── Barrier @ q[1]\n├── Barrier @ q[2]\n├── Barrier @ q[3]\n└── Barrier @ q[1:3]\n\n\n\n\n\n","category":"type"}]
}
