var documenterSearchIndex = {"docs":
[{"location":"library/mimiqcircuitsbase/other/#Other-Operations","page":"Other Operations","title":"Other Operations","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/other/#Custom-gates","page":"Other Operations","title":"Custom gates","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/other/","page":"Other Operations","title":"Other Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"custom.jl\", \"operations/operator.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.GateCustom","page":"Other Operations","title":"MimiqCircuitsBase.GateCustom","text":"struct GateCustom{N,T} <: AbstractGate{N}\n\nN qubit gate specified by a 2^N times 2^N matrix with elements of type T.\n\nUse this to construct your own gates based on unitary matrices.\n\nnote: Note\nOnly one and two qubits gates are supported.\n\nMIMIQ uses textbook convention for specifying gates.\n\nOne qubit gate matrices are defined in the basis 0rangle, 1rangle e.g.,\n\noperatornameZ =\nbeginpmatrix\n    10\n    0-1\nendpmatrix\n\nTwo qubit gate matrices are defined in the basis 00rangle, 01rangle>, 10rangle, 11rangle where the left-most qubit is the first to appear in the target list e.g.,\n\noperatornameCNOT =\nbeginpmatrix\n    1000\n    0100\n    0001\n    0010\nendpmatrix\n\njulia> CNOT = [1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]\n4×4 Matrix{Int64}:\n 1  0  0  0\n 0  1  0  0\n 0  0  0  1\n 0  0  1  0\n\njulia> # CNOT gate with control on q1 and target on q2\n\njulia> Instruction(GateCustom(CNOT), 1, 2)\nGateCustom([1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]) @ q1, q2\n\n# Examples\n\n\njldoctest julia> g = GateCustom([1 0; 0 1]) Custom([1.0 0.0; 0.0 1.0])\n\njulia> push!(Circuit(), g, 1) 1-qubit circuit with 1 instructions: └── Custom([1.0 0.0; 0.0 1.0]) @ q1 ```\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.Operator","page":"Other Operations","title":"MimiqCircuitsBase.Operator","text":"Operator(matrix)\n\nN qubit operator specified by an 2^N times 2^N matrix.\n\nnote: Note\nOnly one and two qubits operators are supported.\n\nThis operator doesn't have to be unitary.\n\nSee also AbstractOperator, ExpectationValue, and Kraus.\n\nExamples\n\njulia> Operator([1 2; 3 4])\n1-qubit Operator:\n├── 1.0 2.0\n└── 3.0 4.0\n\njulia> Operator([1 0 0 1; 0 0 0 0; 0 0 0 0; 1 0 0 1])\n2-qubit Operator:\n├── 1.0 0.0 0.0 1.0\n├── 0.0 0.0 0.0 0.0\n├── 0.0 0.0 0.0 0.0\n└── 1.0 0.0 0.0 1.0\n\nOperators can be used for expectation values:\n\njulia> push!(Circuit(), ExpectationValue(Operator([0 1; 0 0])), 1, 1)\n1-qubit circuit with 1 instructions:\n└── ⟨Operator([0.0 1.0; 0.0 0.0])⟩ @ q[1], z[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.AbstractOperator","page":"Other Operations","title":"MimiqCircuitsBase.AbstractOperator","text":"AbstractOperator{N} <: Operation{N,0,0}\n\nSupertype for all the N-qubit operators.\n\nNote that objects of type AbstractOperator do not need to be unitary.\n\nOperators can be used to define Kraus channels (noise) AbstractKrausChannel, or to compute expectation values ExpectationValue. However, they will return an error if we attempt to directly apply them to states.\n\nSee also matrix, isunitary.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.matrix","page":"Other Operations","title":"MimiqCircuitsBase.matrix","text":"matrix(operator)\n\nMatrix associated to the given operator.\n\nnote: Note\nif the operator is parametric, the matrix elements are wrapped in a Symbolics.Num object. To manipulate expressions use the Symbolics package.\n\nExamples\n\njulia> matrix(GateH())\n2×2 Matrix{Float64}:\n 0.707107   0.707107\n 0.707107  -0.707107\n\njulia> matrix(GateRX(π/2))\n2×2 Matrix{ComplexF64}:\n 0.707107+0.0im            0.0-0.707107im\n      0.0-0.707107im  0.707107+0.0im\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.opsquared-Tuple{AbstractOperator}","page":"Other Operations","title":"MimiqCircuitsBase.opsquared","text":"opsquared(op)\n\nCompute A^dagger A for an operator A.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.rescale-Tuple{AbstractOperator, Any}","page":"Other Operations","title":"MimiqCircuitsBase.rescale","text":"oprescale(op, a)\n\nCompute a * A for an operator A and rescaling factor a.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.unwrappedmatrix-Tuple{T} where T<:AbstractOperator","page":"Other Operations","title":"MimiqCircuitsBase.unwrappedmatrix","text":"unwrappedmatrix(operator)\n\nReturns the matrix associated to the specified quantum operator without the Symbolics.Num wrapper.\n\nnote: Note\nIf any of the gate's parameters is symbolic, an error is thrown.\n\nSee also matrix.\n\nExamples\n\njulia> unwrappedmatrix(GateRX(π/2))\n2×2 Matrix{ComplexF64}:\n 0.707107+0.0im            0.0-0.707107im\n      0.0-0.707107im  0.707107+0.0im\n\njulia> unwrappedmatrix(GateH())\n2×2 Matrix{Float64}:\n 0.707107   0.707107\n 0.707107  -0.707107\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/other/#Gate-definitions","page":"Other Operations","title":"Gate definitions","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/other/","page":"Other Operations","title":"Other Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"gatedecl.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.GateCall","page":"Other Operations","title":"MimiqCircuitsBase.GateCall","text":"GateCall(decl, args...)\n\nGate corresponding to a call to a GateDecl definition.\n\nIt is created by calling a GateDecl with the proper number of arguments.\n\nExamples\n\njulia> @gatedecl ansatz(θ) = begin\n           c = Circuit()\n           push!(c, GateX(), 1)\n           push!(c, GateRX(θ), 2)\n           return c\n       end\ngate ansatz(θ) =\n├── X @ q[1]\n└── RX(θ) @ q[2]\n\n\njulia> @variables λ;\n\n\njulia> ansatz(λ)\nansatz(λ)\n\n\nSee also\n\nGateDecl\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.GateDecl","page":"Other Operations","title":"MimiqCircuitsBase.GateDecl","text":"GateDecl(name, args, circuit)\n\nDefine a new gate of given name, arguments and circuit.\n\nExamples\n\nA simple gate declaration, via the @gatedecl macro:\n\njulia> @gatedecl ansatz(θ)  = begin\n           c = Circuit()\n           push!(c, GateX(), 1)\n           push!(c, GateRX(θ), 2)\n           return c\n       end\ngate ansatz(θ) =\n├── X @ q[1]\n└── RX(θ) @ q[2]\n\njulia> @variables λ;\n\n\njulia> decompose(ansatz(λ))\n2-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── RX(λ) @ q[2]\n\n\nSee also\n\nGateCall\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#Non-unitary-operations","page":"Other Operations","title":"Non-unitary operations","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/other/","page":"Other Operations","title":"Other Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"reset.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.MeasureReset","page":"Other Operations","title":"MimiqCircuitsBase.MeasureReset","text":"MeasureReset()\n\nThis operation measures a qubit q, stores the value in a classical bit c, then applies a X operation to the qubit if the measured value is 1, effectively resetting the qubit to the :math:\\\\ket{0} state.\n\nSee also MeasureResetX, MeasureResetY, IfStatement, GateH.\n\nExamples\n\njulia> MeasureReset()\nMR\n\njulia> decompose(MeasureReset())\n1-qubit circuit with 2 instructions:\n├── M @ q[1], c[1]\n└── IF(c==1) X @ q[1], c[1]\n\njulia> c = push!(Circuit(), MeasureReset(), 1, 1)\n1-qubit circuit with 1 instructions:\n└── MR @ q[1], c[1]\n\njulia> push!(c, MeasureReset(), 3, 4)\n3-qubit circuit with 2 instructions:\n├── MR @ q[1], c[1]\n└── MR @ q[3], c[4]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.MeasureResetX","page":"Other Operations","title":"MimiqCircuitsBase.MeasureResetX","text":"MeasureResetX()\n\nThe MeasureResetX operation first applies a Hadamard gate (H) to the qubit, performs a measurement and reset operation similar to the MeasureReset operation, and then applies another Hadamard gate. This sequence effectively measures the qubit in the X-basis and resets it to the |+> state.\n\nSee also MeasureReset, MeasureResetY, IfStatement, GateH.\n\nExamples\n\njulia> MeasureResetX()\nMRX\n\njulia> decompose(MeasureResetX())\n1-qubit circuit with 3 instructions:\n├── H @ q[1]\n├── MR @ q[1], c[1]\n└── H @ q[1]\n\njulia> c = push!(Circuit(), MeasureResetX(), 1, 1)\n1-qubit circuit with 1 instructions:\n└── MRX @ q[1], c[1]\n\njulia> push!(c, MeasureResetX(), 3, 4)\n3-qubit circuit with 2 instructions:\n├── MRX @ q[1], c[1]\n└── MRX @ q[3], c[4]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.MeasureResetY","page":"Other Operations","title":"MimiqCircuitsBase.MeasureResetY","text":"MeasureResetY()\n\nThe MeasureResetY operation applies (HYZ) gate to the qubit, performs a MeasureReset operation, and then applies another HYZ gate.  This sequence effectively measures the qubit in the Y-basis.\n\nSee aclso MeasureResetX, MeasureReset, IfStatement, GateHYZ.\n\nExamples\n\njulia> MeasureResetY()\nMRY\n\njulia> decompose(MeasureResetY())\n1-qubit circuit with 3 instructions:\n├── HYZ @ q[1]\n├── MR @ q[1], c[1]\n└── HYZ @ q[1]\n\n\njulia> c = push!(Circuit(), MeasureResetY(), 1, 1)\n1-qubit circuit with 1 instructions:\n└── MRY @ q[1], c[1]\n\njulia> push!(c, MeasureResetY(), 3, 4)\n3-qubit circuit with 2 instructions:\n├── MRY @ q[1], c[1]\n└── MRY @ q[3], c[4]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.MeasureResetZ","page":"Other Operations","title":"MimiqCircuitsBase.MeasureResetZ","text":"MeasureResetZ()\n\nThis operation is an alias for MeasureReset Operation.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.Reset","page":"Other Operations","title":"MimiqCircuitsBase.Reset","text":"Reset()\n\nQuantum operation that resets the status of one qubit to the ket0 state.\n\nSee also Operation, Measure.\n\nExamples\n\njulia> Reset()\nReset\n\njulia> c = push!(Circuit(), Reset, 1)\n1-qubit circuit with 1 instructions:\n└── Reset @ q[1]\n\njulia> push!(c, Reset(), 3)\n3-qubit circuit with 2 instructions:\n├── Reset @ q[1]\n└── Reset @ q[3]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.ResetX","page":"Other Operations","title":"MimiqCircuitsBase.ResetX","text":"ResetX\n\nQuantum operation that resets the status of one qubit to ket+ = (ket0+ket1)sqrt2, the +1 eigenstate of the X gate.\n\nThis operation is equivalent to the sequence Reset, GateH.\n\nSee also Reset, Operation, Measure.\n\nExamples\n\njulia> ResetX()\nResetX\n\njulia> decompose(ResetX())\n1-qubit circuit with 3 instructions:\n├── H @ q[1]\n├── Reset @ q[1]\n└── H @ q[1]\n\njulia> c = push!(Circuit(), ResetX, 1)\n1-qubit circuit with 1 instructions:\n└── ResetX @ q[1]\n\njulia> push!(c, ResetX(), 3)\n3-qubit circuit with 2 instructions:\n├── ResetX @ q[1]\n└── ResetX @ q[3]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.ResetY","page":"Other Operations","title":"MimiqCircuitsBase.ResetY","text":"ResetY\n\nQuantum operation that resets the status of one qubit to kety+ = (ket0+iket1)sqrt2, the +1 eigenstate of the Y gate.\n\nThis operation is equivalent to the sequence Reset, GateH, GateS.\n\nSee also Reset, Operation, Measure.\n\nExamples\n\njulia> ResetY()\nResetY\n\njulia> decompose(ResetY())\n1-qubit circuit with 3 instructions:\n├── HYZ @ q[1]\n├── Reset @ q[1]\n└── HYZ @ q[1]\n\njulia> c = push!(Circuit(), ResetY, 1)\n1-qubit circuit with 1 instructions:\n└── ResetY @ q[1]\n\njulia> push!(c, ResetY(), 3)\n3-qubit circuit with 2 instructions:\n├── ResetY @ q[1]\n└── ResetY @ q[3]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.ResetZ","page":"Other Operations","title":"MimiqCircuitsBase.ResetZ","text":"ResetZ()\n\nSee Reset.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#No-ops","page":"Other Operations","title":"No-ops","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/other/","page":"Other Operations","title":"Other Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"barrier.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.Barrier","page":"Other Operations","title":"MimiqCircuitsBase.Barrier","text":"Barrier(numqubits)\n\nNo-op operation that does not affect the quantum state or the execution of a circuit, but prevents compression or optimization across it.\n\nExamples\n\njulia> Barrier(1)\nBarrier\n\njulia> Barrier(2)\nBarrier\n\njulia> c = push!(Circuit(), Barrier(1), 1)\n1-qubit circuit with 1 instructions:\n└── Barrier @ q[1]\n\njulia> push!(c, Barrier(1), 1:3)\n3-qubit circuit with 4 instructions:\n├── Barrier @ q[1]\n├── Barrier @ q[1]\n├── Barrier @ q[2]\n└── Barrier @ q[3]\n\njulia> push!(c, Barrier(3), 1,2,3)\n3-qubit circuit with 5 instructions:\n├── Barrier @ q[1]\n├── Barrier @ q[1]\n├── Barrier @ q[2]\n├── Barrier @ q[3]\n└── Barrier @ q[1:3]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#Others","page":"Other Operations","title":"Others","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/other/","page":"Other Operations","title":"Other Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages = [\"annotations.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.AbstractAnnotation","page":"Other Operations","title":"MimiqCircuitsBase.AbstractAnnotation","text":"AbstractAnnotation{N, M, L} <: Operation{N, M, L}\n\nAn abstract type representing a general annotation operation for use in quantum circuits.  This type supports annotations that are not strictly quantum operations but may carry metadata or extra circuit information.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.Detector","page":"Other Operations","title":"MimiqCircuitsBase.Detector","text":"Detector{N}(N::Integer, notes::AbstractVector)\n\nAn annotation class representing a detector in a quantum circuit.  The Detector checks the parity of measurement results over N classical bits, where the parity should be deterministic under noiseless execution.\n\nDetector monitors the results of a specific set of measurements and verifies that their combined parity (even or odd) remains consistent. This consistency is expected under ideal, noiseless conditions.  If noise or errors disrupt the circuit, the Detector can identify this because the parity will change unexpectedly,  signaling a potential error in the measurement outcomes. This helps in error detection by revealing inconsistencies that arise due to unintended disturbances.\n\nSee Also QubitCoordinates, ShiftCoordinates, or Tick\n\nArguments\n\nN::Integer: The number of classical bits.\nnotes::AbstractVector: A vector of floating-point values that contain measurement notes.\n\nThrows\n\nArgumentError: If N is zero or negative.\n\nExamples\n\njulia> detector = Detector(2, [1.0, 0.5])\nDetector(1.0, 0.5)\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c,detector,1,2)\n0-qubit circuit with 1 instructions:\n└── Detector(1.0,0.5) @ c[1:2]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.ObservableInclude","page":"Other Operations","title":"MimiqCircuitsBase.ObservableInclude","text":"ObservableInclude{N}(N::Integer, notes::AbstractVector)\n\nAn annotation class for adding measurement records to a specified logical observable within a quantum circuit.  Observables are sets of measurements expected to produce a deterministic result, used to track specific logical qubit states across operations.\n\nThe ObservableInclude class tags a group of measurement records as a logical observable, representing a consistent, predictable result under noiseless conditions.  This grouping allows for tracking the state of logical qubits across circuit operations, which is crucial for error correction.  Logical observables monitor encoded qubit states by combining multiple measurements, providing robustness against noise and helping to identify any deviations that indicate potential errors.\n\nSee Also QubitCoordinates, Detector, or Tick\n\nArguments\n\nN::Integer: The number of classical bits observed in this logical observable.\nnotes::AbstractVector: A vector of integers identifying measurement records.\n\nThrows\n\nArgumentError: If N is zero or negative.\n\nExamples\n\njulia> obs_include = ObservableInclude(2, [1, 2])\nObservableInclude(1, 2)\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, obs_include,1,2)\n0-qubit circuit with 1 instructions:\n└── ObservableInclude(1,2) @ c[1:2]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.QubitCoordinates","page":"Other Operations","title":"MimiqCircuitsBase.QubitCoordinates","text":"QubitCoordinates(coordinates...)\n\nAn annotation class used to specify the spatial location of a qubit in a quantum circuit.  Coordinates do not affect simulation results but are useful for visualizing and organizing qubit layouts within the circuit.\n\nSee Also Detector, ShiftCoordinates, or Tick\n\nArguments\n\ncoordinates: A variable number of floating-point values representing the coordinates of the qubit.\n\nExamples\n\njulia> coords = QubitCoordinates(0.0, 1.0)\nQubitCoordinates(0.0, 1.0)\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c,coords,1)\n1-qubit circuit with 1 instructions:\n└── QubitCoordinates(0.0,1.0) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.ShiftCoordinates","page":"Other Operations","title":"MimiqCircuitsBase.ShiftCoordinates","text":"ShiftCoordinates(coordinates...)\n\nAn annotation class used to apply a shift to the spatial coordinates of subsequent qubit or detector annotations in a quantum circuit.  ShiftCoordinates accumulates offsets that adjust the position of related circuit components, aiding in visualization without affecting the simulation.\n\nSee Also QubitCoordinates, ShiftCoordinates, or Tick\n\nArguments\n\ncoordinates: A variable number of floating-point values representing the shift offsets for each coordinate.\n\nExamples\n\njulia> shift = ShiftCoordinates(1.0, 2.0)\nShiftCoordinates(1.0, 2.0)\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, shift)\n0-qubit circuit with 1 instructions:\n└── ShiftCoordinates(1.0,2.0)\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/other/#MimiqCircuitsBase.Tick","page":"Other Operations","title":"MimiqCircuitsBase.Tick","text":"Tick()\n\nAn annotation class representing a timing marker or layer boundary in a quantum circuit.  Tick does not affect simulation but provides structure by separating operations into distinct time steps, which is useful for visualization and analysis.\n\nSee Also QubitCoordinates, ShiftCoordinates, or Detector\n\nExamples\n\njulia> tick = Tick()\nTick()\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, tick)\n0-qubit circuit with 1 instructions:\n└── Tick()\n\n\n\n\n\n","category":"type"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A. Barenco, C. H. Bennett, R. Cleve, D. P. DiVincenzo, N. Margolus, P. Shor, T. Sleator, J. A. Smolin and H. Weinfurter. Elementary gates for quantum computation. Phys. Rev. A 52, 3457–3467 (1995).\n\n\n\n","category":"page"},{"location":"library/mimiqcircuitsbase/standard/#Standard-Gates","page":"Standard Gates","title":"Standard Gates","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/standard/","page":"Standard Gates","title":"Standard Gates","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\n    \"operations/gates/standard/u.jl\",\n    \"operations/gates/standard/phase.jl\",\n    \"operations/gates/standard/deprecated.jl\",\n    \"operations/gates/standard/pauli.jl\",\n    \"operations/gates/standard/hadamard.jl\",\n    \"operations/gates/standard/id.jl\",\n    \"operations/gates/standard/s.jl\",\n    \"operations/gates/standard/t.jl\",\n    \"operations/gates/standard/sx.jl\",\n    \"operations/gates/standard/rotations.jl\",\n    \"operations/gates/standard/swap.jl\",\n    \"operations/gates/standard/iswap.jl\",\n    \"operations/gates/standard/cpauli.jl\",\n    \"operations/gates/standard/chadamard.jl\",\n    \"operations/gates/standard/cs.jl\",\n    \"operations/gates/standard/csx.jl\",\n    \"operations/gates/standard/cu.jl\",\n    \"operations/gates/standard/cphase.jl\",\n    \"operations/gates/standard/crotations.jl\",\n    \"operations/gates/standard/ecr.jl\",\n    \"operations/gates/standard/dcx.jl\",\n    \"operations/gates/standard/interactions.jl\",\n    \"operations/gates/standard/cswap.jl\",\n    \"operations/gates/standard/cnx.jl\",\n    \"operations/gates/standard/cnp.jl\",\n]","category":"page"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateU","page":"Standard Gates","title":"MimiqCircuitsBase.GateU","text":"GateU(θ, ϕ, λ[, γ = 0])\n\nSingle qubit generic unitary gate U(theta phi lambda gamma = 0), where theta, phi, and lambda are the Euler angles specified in radians, and gamma is a global phase.\n\nSee also GateU3, GateP, GateU2, GateU1\n\nMatrix representation\n\noperatornameU(theta phi lambda gamma = 0) =\nmathrme^igamma\nbeginpmatrix\n    cosleft(fractheta2right)  -mathrme^ilambdasinleft(fractheta2right) \n    mathrme^iphisinleft(fractheta2right)  mathrme^i(phi+lambda)cosleft(fractheta2right)\nendpmatrix\n\nExamples\n\njulia> @variables θ ϕ λ\n3-element Vector{Symbolics.Num}:\n θ\n ϕ\n λ\n\njulia> GateU(θ, ϕ, λ)\nU(θ, ϕ, λ)\n\njulia> matrix(GateU(2.023, 0.5, 0.1))\n2×2 Matrix{ComplexF64}:\n  0.53059+0.0im       -0.843394-0.0846217im\n 0.743864+0.406375im   0.437915+0.299594im\n\njulia> c = push!(Circuit(), GateU(θ, ϕ, λ), 1)\n1-qubit circuit with 1 instructions:\n└── U(θ,ϕ,λ) @ q[1]\n\njulia> push!(c, GateU(π/8, π/2, π/4), 2)\n2-qubit circuit with 2 instructions:\n├── U(θ,ϕ,λ) @ q[1]\n└── U(π/8,π/2,π/4) @ q[2]\n\njulia> power(GateU(θ, ϕ, λ), 2), inverse(GateU(θ, ϕ, λ))\n(GateU(θ, ϕ, λ, 0π)^2, GateU(-θ, -λ, -ϕ, 0π))\n\n\nDecomposition\n\nSince U gate, is the most general single qubit unitary matrix, all other matrices are defined from it.\n\njulia> decompose(GateU(θ, λ, ϕ))\n1-qubit circuit with 1 instructions:\n└── U(θ,λ,ϕ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateP","page":"Standard Gates","title":"MimiqCircuitsBase.GateP","text":"GateP(λ)\n\nSingle qubit Phase gate.\n\nλ is the phase angle in radians.\n\nMatrix representation\n\noperatornameP(lambda) =\noperatornameU(0 0 lambda) =\nbeginpmatrix\n    1  0 \n    0  mathrme^ilambda\nendpmatrix\n\nExamples\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> GateP(λ)\nP(λ)\n\njulia> matrix(GateP(1.989))\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  -0.40612+0.91382im\n\njulia> c = push!(Circuit(), GateP(λ), 1)\n1-qubit circuit with 1 instructions:\n└── P(λ) @ q[1]\n\njulia> push!(c, GateP(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── P(λ) @ q[1]\n└── P(π/2) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateP(λ))\n1-qubit circuit with 1 instructions:\n└── U(0,0,λ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateU1","page":"Standard Gates","title":"MimiqCircuitsBase.GateU1","text":"GateU1(λ)\n\nSingle qubit rotation \\operatorname{U1}(\\lambda) about the Z axis.\n\nEquivalent to GateP.\n\nMatrix representation\n\noperatornameU1(lambda) =\nbeginpmatrix\n    1  0 \n    0  e^ilambda\nendpmatrix\n\nExamples\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> GateU1(λ)\nU1(λ)\n\njulia> matrix(GateU1(0.519))\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.868316+0.496012im\n\njulia> c = push!(Circuit(), GateU1(λ), 1)\n1-qubit circuit with 1 instructions:\n└── U1(λ) @ q[1]\n\njulia> push!(c, GateU1(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── U1(λ) @ q[1]\n└── U1(π/2) @ q[2]\n\njulia> power(GateU1(λ), 2), inverse(GateU1(λ))\n(GateU1(λ)^2, GateU1(-λ))\n\n\nDecomposition\n\njulia> decompose(GateU1(λ))\n1-qubit circuit with 1 instructions:\n└── U(0,0,λ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateU2","page":"Standard Gates","title":"MimiqCircuitsBase.GateU2","text":"GateU2(ϕ, λ)\n\nSingle qubit rotation \\operatorname{U2}(\\phi, \\lambda) about the X+Z axis.\n\nMatrix representation\n\noperatornameU2(philambda) = frac1sqrt2e^-(phi+lambda)2beginpmatrix\n1  -e^ilambda \ne^iphi  e^i(phi+lambda)\nendpmatrix\n\nExamples\n\njulia> @variables ϕ λ\n2-element Vector{Symbolics.Num}:\n ϕ\n λ\n\njulia> GateU2(ϕ, λ)\nU2(ϕ, λ)\n\njulia> matrix(GateU2(2.023, 0.5))\n2×2 Matrix{ComplexF64}:\n  0.707107+0.0im       -0.620545-0.339005im\n -0.308969+0.636033im  -0.576077+0.410044im\n\njulia> c = push!(Circuit(), GateU2(ϕ, λ), 1)\n1-qubit circuit with 1 instructions:\n└── U2(ϕ,λ) @ q[1]\n\njulia> push!(c, GateU2(π/2, π/4), 2)\n2-qubit circuit with 2 instructions:\n├── U2(ϕ,λ) @ q[1]\n└── U2(π/2,π/4) @ q[2]\n\njulia> power(GateU2(ϕ, λ), 2), inverse(GateU2(ϕ, λ))\n(GateU2(ϕ, λ)^2, GateU2(-3.141592653589793 - λ, π - ϕ))\n\n\nDecomposition\n\njulia> decompose(GateU2(ϕ, λ))\n1-qubit circuit with 1 instructions:\n└── U3(π/2,ϕ,λ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateU3","page":"Standard Gates","title":"MimiqCircuitsBase.GateU3","text":"GateU3(θ, ϕ, λ)\n\nSingle qubit generic unitary gate U3(\\theta, \\phi, \\lambda).\n\nThis gate is equivalent to the generic unitary gate GateU, differing from it only by a global phase of fracphi + lambda + theta2.\n\nMatrix representation\n\noperatornameU3(thetaphilambda) =\nbeginpmatrix\n    cosleft(fractheta2right)  -e^ilambdasinleft(fractheta2right) \n    mathrme^iphisinleft(fractheta2right)  mathrme^i(phi+lambda)cosleft(fractheta2right)\nendpmatrix\n\nExamples\n\njulia> @variables θ ϕ λ\n3-element Vector{Symbolics.Num}:\n θ\n ϕ\n λ\n\njulia> GateU3(θ, ϕ, λ)\nU3(θ, ϕ, λ)\n\njulia> matrix(GateU3(2.023, 0.5, 0.1))\n2×2 Matrix{ComplexF64}:\n  0.53059+0.0im       -0.843394-0.0846217im\n 0.743864+0.406375im   0.437915+0.299594im\n\njulia> c = push!(Circuit(), GateU3(θ, ϕ, λ), 1)\n1-qubit circuit with 1 instructions:\n└── U3(θ,ϕ,λ) @ q[1]\n\njulia> push!(c, GateU3(π/8, π/2, π/4), 2)\n2-qubit circuit with 2 instructions:\n├── U3(θ,ϕ,λ) @ q[1]\n└── U3(π/8,π/2,π/4) @ q[2]\n\njulia> power(GateU3(θ, ϕ, λ), 2), inverse(GateU3(θ, ϕ, λ))\n(GateU3(θ, ϕ, λ)^2, GateU3(-θ, -λ, -ϕ))\n\n\nDecomposition\n\njulia> decompose(GateU3(θ, ϕ, λ))\n1-qubit circuit with 1 instructions:\n└── U(θ,ϕ,λ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateX","page":"Standard Gates","title":"MimiqCircuitsBase.GateX","text":"GateX()\n\nSingle qubit Pauli-X gate.\n\nMatrix representation\n\noperatornameX =\nbeginpmatrix\n    0  1 \n    1  0\nendpmatrix\n\nExamples\n\njulia> GateX()\nX\n\njulia> matrix(GateX())\n2×2 Matrix{Int64}:\n 0  1\n 1  0\n\njulia> c = push!(Circuit(), GateX(), 1)\n1-qubit circuit with 1 instructions:\n└── X @ q[1]\n\njulia> push!(c, GateX, 2)\n2-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── X @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateX())\n1-qubit circuit with 1 instructions:\n└── U(π,0,π) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateY","page":"Standard Gates","title":"MimiqCircuitsBase.GateY","text":"GateY()\n\nSingle qubit Pauli-Y gate.\n\nMatrix representation\n\noperatornameY =\nbeginpmatrix\n    0  -i \n    i  0\nendpmatrix\n\nExamples\n\njulia> GateY()\nY\n\njulia> matrix(GateY())\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0-1.0im\n 0.0+1.0im  0.0+0.0im\n\njulia> c = push!(Circuit(), GateY(), 1)\n1-qubit circuit with 1 instructions:\n└── Y @ q[1]\n\njulia> push!(c, GateY, 2)\n2-qubit circuit with 2 instructions:\n├── Y @ q[1]\n└── Y @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateY())\n1-qubit circuit with 1 instructions:\n└── U(π,π/2,π/2) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateZ","page":"Standard Gates","title":"MimiqCircuitsBase.GateZ","text":"GateZ()\n\nSingle qubit Pauli-Z gate.\n\nMatrix representation\n\noperatornameZ =\nbeginpmatrix\n    1  0 \n    0  -1\nendpmatrix\n\nExamples\n\njulia> GateZ()\nZ\n\njulia> matrix(GateZ())\n2×2 Matrix{Float64}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> c = push!(Circuit(), GateZ(), 1)\n1-qubit circuit with 1 instructions:\n└── Z @ q[1]\n\njulia> push!(c, GateZ, 2)\n2-qubit circuit with 2 instructions:\n├── Z @ q[1]\n└── Z @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateZ())\n1-qubit circuit with 1 instructions:\n└── P(π) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateH","page":"Standard Gates","title":"MimiqCircuitsBase.GateH","text":"GateH()\n\nSingle qubit Hadamard gate.\n\nMatrix representation\n\noperatornameH =\nfrac1sqrt2\nbeginpmatrix\n    1  1 \n    1  -1\nendpmatrix\n\nExamples\n\njulia> GateH()\nH\n\njulia> matrix(GateH())\n2×2 Matrix{Float64}:\n 0.707107   0.707107\n 0.707107  -0.707107\n\njulia> c = push!(Circuit(), GateH(), 1)\n1-qubit circuit with 1 instructions:\n└── H @ q[1]\n\njulia> push!(c, GateH, 1)\n1-qubit circuit with 2 instructions:\n├── H @ q[1]\n└── H @ q[1]\n\njulia> power(GateH(), 2), inverse(GateH())\n(GateH()^2, GateH())\n\n\nDecomposition\n\njulia> decompose(GateH())\n1-qubit circuit with 1 instructions:\n└── U(π/2,0,π) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateHXY","page":"Standard Gates","title":"MimiqCircuitsBase.GateHXY","text":"GateHXY()\n\nSingle qubit HXY gate.\n\nMatrix representation\n\noperatornameHXY = frac1sqrt2 beginpmatrix\n            0  1 - i \n            1 + i  0\n        endpmatrix\n\nExamples\n\njulia> GateHXY()\nHXY\n\njulia> matrix(GateHXY())\n2×2 Matrix{ComplexF64}:\n      0.0+0.0im       0.707107-0.707107im\n 0.707107+0.707107im       0.0+0.0im\n\njulia> c = push!(Circuit(), GateHXY(), 1)\n1-qubit circuit with 1 instructions:\n└── HXY @ q[1]\n\njulia> power(GateHXY(), 2), inverse(GateHXY())\n(GateHXY()^2, GateHXY())\n\n\nDecomposition\n\njulia> decompose(GateHXY())\n1-qubit circuit with 5 instructions:\n├── H @ q[1]\n├── Z @ q[1]\n├── H @ q[1]\n├── S @ q[1]\n└── U(0,0,0,-1π/4) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateHXZ","page":"Standard Gates","title":"MimiqCircuitsBase.GateHXZ","text":"GateHXZ()\n\nThe HXZ gate is an alias for the Hadamard gate.  It applies a transformation that puts the qubit in an equal superposition of |0⟩ and |1⟩.\n\nMatrix representation\n\noperatornameHXZ = frac1sqrt2 beginpmatrix\n            1  1 \n            1  -1\n        endpmatrix\n\nExamples\n\njulia> GateHXZ()\nH\n\njulia> matrix(GateHXZ())\n2×2 Matrix{Float64}:\n 0.707107   0.707107\n 0.707107  -0.707107\n\njulia> c = push!(Circuit(), GateHXZ(), 1)\n1-qubit circuit with 1 instructions:\n└── H @ q[1]\n\njulia> power(GateHXZ(), 2), inverse(GateHXZ())\n(GateH()^2, GateH())\n\n\nDecomposition\n\njulia> decompose(GateHXZ())\n1-qubit circuit with 1 instructions:\n└── U(π/2,0,π) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateHYZ","page":"Standard Gates","title":"MimiqCircuitsBase.GateHYZ","text":"GateHYZ()\n\nSingle qubit HYZ gate.\n\nMatrix representation\n\noperatornameHYZ = frac1sqrt2 beginpmatrix\n            1  -i \n            i  -1\n        endpmatrix\n\nExamples\n\njulia> GateHYZ()\nHYZ\n\njulia> matrix(GateHYZ())\n2×2 Matrix{ComplexF64}:\n 0.707107+0.0im             0.0-0.707107im\n      0.0+0.707107im  -0.707107+0.0im\n\njulia> c = push!(Circuit(), GateHYZ(), 1)\n1-qubit circuit with 1 instructions:\n└── HYZ @ q[1]\n\njulia> power(GateHYZ(), 2), inverse(GateHYZ())\n(GateHYZ()^2, GateHYZ())\n\n\nDecomposition\n\njulia> decompose(GateHYZ())\n1-qubit circuit with 5 instructions:\n├── H @ q[1]\n├── S @ q[1]\n├── H @ q[1]\n├── Z @ q[1]\n└── U(0,0,0,-1π/4) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateID","page":"Standard Gates","title":"MimiqCircuitsBase.GateID","text":"GateID()\n\nSingle qubit identity gate\n\nMatrix representation\n\noperatornameI =\nbeginpmatrix\n    1  0 \n    0  1\nendpmatrix\n\nExamples\n\njulia> GateID()\nID\n\njulia> matrix(GateID())\n2×2 Matrix{Float64}:\n 1.0  -0.0\n 0.0   1.0\n\njulia> c = push!(Circuit(), GateID(), 1)\n1-qubit circuit with 1 instructions:\n└── ID @ q[1]\n\njulia> power(GateID(), 2), inverse(GateID())\n(GateID(), GateID())\n\n\nDecomposition\n\njulia> decompose(GateID())\n1-qubit circuit with 1 instructions:\n└── U(0,0,0) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateS","page":"Standard Gates","title":"MimiqCircuitsBase.GateS","text":"GateS()\n\nSingle qubit S gate (or phase gate). It is defined as the square root of the Z gate.\n\nSee also GateSDG, GateZ, Power\n\nMatrix representation\n\noperatornameS =\nsqrtoperatornameZ =\nbeginpmatrix\n    1  0 \n    0  i\nendpmatrix\n\nExamples\n\njulia> GateS()\nS\n\njulia> matrix(GateS())\n2×2 Matrix{Complex{Int64}}:\n 1+0im  0+0im\n 0+0im  0+1im\n\njulia> c = push!(Circuit(), GateS(), 1)\n1-qubit circuit with 1 instructions:\n└── S @ q[1]\n\njulia> push!(c, GateS, 2)\n2-qubit circuit with 2 instructions:\n├── S @ q[1]\n└── S @ q[2]\n\njulia> power(GateS(), 2), inverse(GateS())\n(GateZ(), Inverse(GateS()))\n\n\nDecomposition\n\njulia> decompose(GateS())\n1-qubit circuit with 1 instructions:\n└── U(0,0,π/2) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateSDG","page":"Standard Gates","title":"MimiqCircuitsBase.GateSDG","text":"GateSDG()\n\nSingle qubit S-dagger gate (conjugate transpose of the S gate).\n\nSee also GateS, GateZ, Power, Inverse\n\nMatrix representation\n\noperatornameS^dagger =\nbeginpmatrix\n    1  0 \n    0  -i\nendpmatrix\n\nExamples\n\njulia> GateSDG()\nS†\n\njulia> matrix(GateSDG())\n2×2 Matrix{Complex{Int64}}:\n 1+0im  0+0im\n 0+0im  0-1im\n\njulia> c = push!(Circuit(), GateSDG(), 1)\n1-qubit circuit with 1 instructions:\n└── S† @ q[1]\n\njulia> push!(c, GateSDG, 2)\n2-qubit circuit with 2 instructions:\n├── S† @ q[1]\n└── S† @ q[2]\n\njulia> power(GateSDG(), 2), inverse(GateSDG())\n((Inverse(GateS()))^2, GateS())\n\n\nDecomposition\n\njulia> decompose(GateSDG())\n1-qubit circuit with 1 instructions:\n└── U(0,0,-1π/2) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateT","page":"Standard Gates","title":"MimiqCircuitsBase.GateT","text":"GateT()\n\nSingle qubit T gate. It is defined as the square root of the S gate, Z^frac14.\n\nSee also GateTDG, GateS, GateZ, Power\n\nMatrix representation\n\noperatornameZ =\noperatornameZ^frac14 =\nbeginpmatrix\n    1  0 \n    0  exp(fracipi4)\nendpmatrix\n\nExamples\n\njulia> GateT()\nT\n\njulia> matrix(GateT())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.707107+0.707107im\n\njulia> c = push!(Circuit(), GateT(), 1)\n1-qubit circuit with 1 instructions:\n└── T @ q[1]\n\njulia> push!(c, GateT, 2)\n2-qubit circuit with 2 instructions:\n├── T @ q[1]\n└── T @ q[2]\n\njulia> power(GateT(), 2), power(GateT(), 4), inverse(GateT())\n(GateS(), GateZ(), Inverse(GateT()))\n\n\nDecomposition\n\njulia> decompose(GateT())\n1-qubit circuit with 1 instructions:\n└── U(0,0,π/4) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateTDG","page":"Standard Gates","title":"MimiqCircuitsBase.GateTDG","text":"GateTDG()\n\nSingle qubit T-dagger gate (conjugate transpose of the T gate).\n\nSee also GateT\n\nMatrix Representation\n\noperatornameT^dagger =\nbeginpmatrix\n    1  0 \n    0  exp(frac-ipi4)\nendpmatrix\n\nExamples\n\njulia> GateTDG()\nT†\n\njulia> matrix(GateTDG())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.707107-0.707107im\n\njulia> c = push!(Circuit(), GateTDG(), 1)\n1-qubit circuit with 1 instructions:\n└── T† @ q[1]\n\njulia> push!(c, GateTDG, 2)\n2-qubit circuit with 2 instructions:\n├── T† @ q[1]\n└── T† @ q[2]\n\njulia> power(GateTDG(), 2), power(GateTDG(), 4), inverse(GateTDG())\n((Inverse(GateT()))^2, (Inverse(GateT()))^4, GateT())\n\n\nDecomposition\n\njulia> decompose(GateTDG())\n1-qubit circuit with 1 instructions:\n└── U(0,0,-1π/4) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateSX","page":"Standard Gates","title":"MimiqCircuitsBase.GateSX","text":"GateSX()\n\nSingle qubit sqrtX gate.\n\nSee also GateSXDG, GateX, Power\n\nMatrix representation\n\noperatornameSX =\nsqrtoperatornameX =\nfrac12\nbeginpmatrix\n    1+i  1-i \n    1-i  1+i\nendpmatrix\n\nExamples\n\njulia> GateSX()\nSX\n\njulia> matrix(GateSX())\n2×2 Matrix{ComplexF64}:\n 0.5+0.5im  0.5-0.5im\n 0.5-0.5im  0.5+0.5im\n\njulia> c = push!(Circuit(), GateSX(), 1)\n1-qubit circuit with 1 instructions:\n└── SX @ q[1]\n\njulia> push!(c, GateSX, 2)\n2-qubit circuit with 2 instructions:\n├── SX @ q[1]\n└── SX @ q[2]\n\njulia> power(GateSX(), 2), inverse(GateSX())\n(GateX(), Inverse(GateSX()))\n\n\nDecomposition\n\njulia> decompose(GateSX())\n1-qubit circuit with 4 instructions:\n├── S† @ q[1]\n├── H @ q[1]\n├── S† @ q[1]\n└── U(0,0,0,π/4) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateSXDG","page":"Standard Gates","title":"MimiqCircuitsBase.GateSXDG","text":"GateSXDG()\n\nSingle qubit sqrtX^dagger gate (conjugate transpose of the sqrtX gate)\n\nSee also GateSX, GateX, Power, Inverse\n\nMatrix representation\n\noperatornameSXDG =\nsqrtoperatornameX^dagger =\nfrac12\nbeginpmatrix\n    1-i  1+i \n    1+i  1-i\nendpmatrix\n\nExamples\n\njulia> GateSXDG()\nSX†\n\njulia> matrix(GateSXDG())\n2×2 Matrix{ComplexF64}:\n 0.5-0.5im  0.5+0.5im\n 0.5+0.5im  0.5-0.5im\n\njulia> c = push!(Circuit(), GateSXDG(), 1)\n1-qubit circuit with 1 instructions:\n└── SX† @ q[1]\n\njulia> push!(c, GateSXDG, 2)\n2-qubit circuit with 2 instructions:\n├── SX† @ q[1]\n└── SX† @ q[2]\n\njulia> power(GateSXDG(), 2), inverse(GateSXDG())\n((Inverse(GateSX()))^2, GateSX())\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateR","page":"Standard Gates","title":"MimiqCircuitsBase.GateR","text":"GateR(θ, ϕ)\n\nSingle qubit parametric rotation operatornameR(theta lambda) gate.\n\nIt performs a rotation of theta radians for the target qubit around an XY-plane axis of the Bloch sphere determined by cos(phi)mathbfx + sin(phi)mathbfy.\n\nMatrix representation\n\noperatornameR(thetaphi) =\nbeginpmatrix\n    cosfractheta2  -ie^-iphisinfractheta2 \n    -ie^iphisinfractheta2  cosfractheta2\nendpmatrix\n\nExamples\n\njulia> @variables θ ϕ\n2-element Vector{Symbolics.Num}:\n θ\n ϕ\n\njulia> GateR(θ, ϕ)\nR(θ, ϕ)\n\njulia> matrix(GateR(2.023, 1.989))\n2×2 Matrix{ComplexF64}:\n 0.53059+0.0im       -0.77458+0.344239im\n 0.77458+0.344239im   0.53059+0.0im\n\njulia> c = push!(Circuit(), GateR(θ, ϕ), 1)\n1-qubit circuit with 1 instructions:\n└── R(θ,ϕ) @ q[1]\n\njulia> push!(c, GateR(π/2, π/4), 2)\n2-qubit circuit with 2 instructions:\n├── R(θ,ϕ) @ q[1]\n└── R(π/2,π/4) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateR(θ, ϕ))\n1-qubit circuit with 1 instructions:\n└── U3(θ,-1.5707963267948966 + ϕ,1.5707963267948966 - ϕ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRX","page":"Standard Gates","title":"MimiqCircuitsBase.GateRX","text":"GateRX(θ)\n\nSingle qubit parametric rotation operatornameR_X(theta) gate.\n\nIt performs a rotation of theta radians around the X-axis of the Bloch sphere of the target qubit.\n\nMatrix representation\n\noperatornameR_X(theta) =\nbeginpmatrix\n    cosfractheta2  -isinfractheta2 \n    -isinfractheta2  cosfractheta2\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRX(θ)\nRX(θ)\n\njulia> matrix(GateRX(1.989))\n2×2 Matrix{ComplexF64}:\n 0.544922+0.0im            0.0-0.838487im\n      0.0-0.838487im  0.544922+0.0im\n\njulia> c = push!(Circuit(), GateRX(θ), 1)\n1-qubit circuit with 1 instructions:\n└── RX(θ) @ q[1]\n\njulia> push!(c, GateRX(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── RX(θ) @ q[1]\n└── RX(π/2) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateRX(θ))\n1-qubit circuit with 1 instructions:\n└── U(θ,-1π/2,π/2) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRY","page":"Standard Gates","title":"MimiqCircuitsBase.GateRY","text":"GateRY(θ)\n\nSingle qubit parametric rotation operatornameR_Y(theta) gate.\n\nIt performss a rotation of theta radians around the Y-axis of the Bloch sphere of the target qubit.\n\nMatrix representation\n\noperatornameR_Y(theta) =\nbeginpmatrix\n    cosfractheta2  -sinfractheta2 \n    sinfractheta2  cosfractheta2\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRY(θ)\nRY(θ)\n\njulia> matrix(GateRY(1.989))\n2×2 Matrix{Float64}:\n 0.544922  -0.838487\n 0.838487   0.544922\n\njulia> c = push!(Circuit(), GateRY(θ), 1)\n1-qubit circuit with 1 instructions:\n└── RY(θ) @ q[1]\n\njulia> push!(c, GateRY(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── RY(θ) @ q[1]\n└── RY(π/2) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateRY(θ))\n1-qubit circuit with 1 instructions:\n└── U(θ,0,0) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRZ","page":"Standard Gates","title":"MimiqCircuitsBase.GateRZ","text":"GateRZ(λ)\n\nSingle qubit parametric rotation operatornameR_Z(lambda) gate.\n\nIt performs a rotation of lambda radians around the Z-axis of the Bloch sphere for the target qubit.\n\nMatrix representation\n\noperatornameRZ(lambda) =\nbeginpmatrix\n    e^-ifraclambda2  0 \n    0  e^ifraclambda2\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRZ(θ)\nRZ(θ)\n\njulia> matrix(GateRZ(1.989))\n2×2 Matrix{ComplexF64}:\n 0.544922-0.838487im       0.0+0.0im\n      0.0+0.0im       0.544922+0.838487im\n\njulia> c = push!(Circuit(), GateRZ(θ), 1)\n1-qubit circuit with 1 instructions:\n└── RZ(θ) @ q[1]\n\njulia> push!(c, GateRZ(π/2), 2)\n2-qubit circuit with 2 instructions:\n├── RZ(θ) @ q[1]\n└── RZ(π/2) @ q[2]\n\n\nDecomposition\n\njulia> decompose(GateRZ(θ))\n1-qubit circuit with 1 instructions:\n└── U(0,0,θ,(-1//2)*θ) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateSWAP","page":"Standard Gates","title":"MimiqCircuitsBase.GateSWAP","text":"GateSWAP()\n\nTwo qubit SWAP gate.\n\nSee also GateISWAP, GateCSWAP\n\nMatrix representation\n\noperatornameSWAP = frac1sqrt2\nbeginpmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  1  0  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> GateSWAP()\nSWAP\n\njulia> matrix(GateSWAP())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> c = push!(Circuit(), GateSWAP(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── SWAP @ q[1:2]\n\njulia> push!(c, GateSWAP, 3, 4)\n4-qubit circuit with 2 instructions:\n├── SWAP @ q[1:2]\n└── SWAP @ q[3:4]\n\njulia> power(GateSWAP(), 2), inverse(GateSWAP())\n(Parallel(2, GateID()), GateSWAP())\n\n\nDecomposition\n\njulia> decompose(GateSWAP())\n2-qubit circuit with 3 instructions:\n├── CX @ q[1], q[2]\n├── CX @ q[2], q[1]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateISWAP","page":"Standard Gates","title":"MimiqCircuitsBase.GateISWAP","text":"GateISWAP()\n\nTwo qubit ISWAP gate.\n\nSee also GateSWAP.\n\nMatrix representation\n\noperatornameISWAP = frac1sqrt2\nbeginpmatrix\n    1  0  0  0 \n    0  0  i  0 \n    0  i  0  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> GateISWAP()\nISWAP\n\njulia> matrix(GateISWAP())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im\n 0.0+0.0im  0.0+1.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im\n\njulia> c = push!(Circuit(), GateISWAP(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── ISWAP @ q[1:2]\n\njulia> push!(c, GateISWAP, 3, 4)\n4-qubit circuit with 2 instructions:\n├── ISWAP @ q[1:2]\n└── ISWAP @ q[3:4]\n\njulia> power(GateISWAP(), 2), inverse(GateISWAP())\n(GateISWAP()^2, Inverse(GateISWAP()))\n\n\nDecomposition\n\njulia> decompose(GateISWAP())\n2-qubit circuit with 6 instructions:\n├── S @ q[1]\n├── S @ q[2]\n├── H @ q[1]\n├── CX @ q[1], q[2]\n├── CX @ q[2], q[1]\n└── H @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCX","page":"Standard Gates","title":"MimiqCircuitsBase.GateCX","text":"GateCX()\n\nTwo qubit Controlled-X gate (or CNOT).\n\ndetails: Details\nImplemented as an alias to Control(1, GateX()).\n\nnote: Note\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nMatrix representation\n\noperatornameCX =\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\nendpmatrix\n\nExamples\n\njulia> GateCX(), numcontrols(GateCX()), numtargets(GateCX())\n(GateCX(), 1, 1)\n\njulia> matrix(GateCX())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n 0.0  0.0  1.0  0.0\n\njulia> c = push!(Circuit(), GateCX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CX @ q[1], q[2]\n\njulia> power(GateCX(), 2), inverse(GateCX())\n(Control(GateID()), GateCX())\n\n\nDecomposition\n\njulia> decompose(GateCX())\n2-qubit circuit with 1 instructions:\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCY","page":"Standard Gates","title":"MimiqCircuitsBase.GateCY","text":"GateCY()\n\nTwo qubit Controlled-Y gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateY()).\n\nnote: Note\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nMatrix representation\n\noperatornameCY = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  -i \n    0  0  i  0\nendpmatrix\n\nExamples\n\njulia> GateCY(), numcontrols(GateCY()), numtargets(GateCY())\n(GateCY(), 1, 1)\n\njulia> matrix(GateCY())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im\n\njulia> c = push!(Circuit(), GateCY(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CY @ q[1], q[2]\n\njulia> power(GateCY(), 2), inverse(GateCY())\n(Control(GateID()), GateCY())\n\n\nDecomposition\n\njulia> decompose(GateCY())\n2-qubit circuit with 3 instructions:\n├── S† @ q[2]\n├── CX @ q[1], q[2]\n└── S @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCZ","page":"Standard Gates","title":"MimiqCircuitsBase.GateCZ","text":"GateCZ()\n\nTwo qubit Controlled-Z gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateZ()).\n\nnote: Note\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nMatrix representation\n\noperatornameCZ = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\nendpmatrix\n\nExamples\n\njulia> GateCZ(), numcontrols(GateCZ()), numtargets(GateCZ())\n(GateCZ(), 1, 1)\n\njulia> matrix(GateCZ())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0   0.0\n 0.0  1.0  0.0   0.0\n 0.0  0.0  1.0   0.0\n 0.0  0.0  0.0  -1.0\n\njulia> c = push!(Circuit(), GateCZ(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CZ @ q[1], q[2]\n\njulia> power(GateCZ(), 2), inverse(GateCZ())\n(Control(GateID()), GateCZ())\n\n\nDecomposition\n\njulia> decompose(GateCZ())\n2-qubit circuit with 3 instructions:\n├── H @ q[2]\n├── CX @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCH","page":"Standard Gates","title":"MimiqCircuitsBase.GateCH","text":"GateCH()\n\nTwo qubit controlled-Hadamard gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateH()).\n\nnote: Note\nBy convention, the first qubit is the control and the second is the target.\n\nMatrix representation\n\noperatornameCH = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  frac1sqrt2  frac1sqrt2 \n    0  0  frac1sqrt2  -frac1sqrt2\nendpmatrix\n\nExamples\n\njulia> GateCH(), numcontrols(GateCH), numtargets(GateCH)\n(GateCH(), 1, 1)\n\njulia> matrix(GateCH())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0        0.0\n 0.0  1.0  0.0        0.0\n 0.0  0.0  0.707107   0.707107\n 0.0  0.0  0.707107  -0.707107\n\njulia> c = push!(Circuit(), GateCH(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CH @ q[1], q[2]\n\njulia> power(GateCH(), 2), inverse(GateCH())\n(Control(GateH()^2), GateCH())\n\n\nDecomposition\n\njulia> decompose(GateCH())\n2-qubit circuit with 7 instructions:\n├── S @ q[2]\n├── H @ q[2]\n├── T @ q[2]\n├── CX @ q[1], q[2]\n├── T† @ q[2]\n├── H @ q[2]\n└── S† @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCS","page":"Standard Gates","title":"MimiqCircuitsBase.GateCS","text":"GateCS()\n\nTwo qubit Controlled-S gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateS()).\n\nSee also GateS, Control.\n\nMatrix representation\n\noperatornameCS =beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  i\nendpmatrix\n\nExamples\n\njulia> GateCS(), numcontrols(GateCS()), numtargets(GateCS())\n(GateCS(), 1, 1)\n\njulia> matrix(GateCS())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im\n\njulia> c = push!(Circuit(), GateCS(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CS @ q[1], q[2]\n\njulia> power(GateCS(), 2), inverse(GateCS())\n(GateCZ(), Control(Inverse(GateS())))\n\n\nDecomposition\n\njulia> decompose(GateCS())\n2-qubit circuit with 1 instructions:\n└── CP(π/2) @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCSDG","page":"Standard Gates","title":"MimiqCircuitsBase.GateCSDG","text":"GateCSDG()\n\nAdjoint of two qubit Controlled-S gate.\n\ndetails: Details\nImplemented as an alias to inverse(Control(1, GateS())).\n\nSee also GateS, Control.\n\nMatrix representation\n\noperatornameCS^dagger = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -i\nendpmatrix\n\nExamples\n\njulia> GateCSDG(), numcontrols(GateCSDG()), numtargets(GateCSDG())\n(Control(Inverse(GateS())), 1, 1)\n\njulia> matrix(GateCSDG())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im\n\njulia> c = push!(Circuit(), GateCSDG(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── C(S†) @ q[1], q[2]\n\njulia> power(GateCSDG(), 2), inverse(GateCSDG())\n(Control((Inverse(GateS()))^2), GateCS())\n\n\nDecomposition\n\njulia> decompose(GateCSDG())\n2-qubit circuit with 1 instructions:\n└── CP(-1π/2) @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCSX","page":"Standard Gates","title":"MimiqCircuitsBase.GateCSX","text":"GateCSX()\n\nTwo qubit Controled-SX gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateSX()).\n\nSee also GateSX, GateCSXDG, Control.\n\nMatrix representation\n\noperatornameCSX =beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  frac1+i2  frac1-i2 \n    0  0  frac1-i2  frac1+i2\nendpmatrix\n\nExamples\n\njulia> GateCSX(), numcontrols(GateCSX()), numtargets(GateCSX())\n(GateCSX(), 1, 1)\n\njulia> matrix(GateCSX())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.5+0.5im  0.5-0.5im\n 0.0+0.0im  0.0+0.0im  0.5-0.5im  0.5+0.5im\n\njulia> c = push!(Circuit(), GateCSX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CSX @ q[1], q[2]\n\njulia> power(GateCSX(), 2), inverse(GateCSX())\n(GateCX(), Control(Inverse(GateSX())))\n\n\nDecomposition\n\njulia> decompose(GateCSX())\n2-qubit circuit with 3 instructions:\n├── H @ q[2]\n├── CU1(π/2) @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCSXDG","page":"Standard Gates","title":"MimiqCircuitsBase.GateCSXDG","text":"GateCSXDG()\n\nTwo qubit CSX-dagger gate. (Control on second qubit)\n\ndetails: Details\nImplemented as an alias to Control(1, GateSXDG()).\n\nSee also GateSX, GateCSXDG, Control.\n\nMatrix representation\n\noperatornameCSX^dagger = beginpmatrix\n    1  0  0  0 \n    0  1  0  0\n    0  0  frac1-i2  frac1+i2 \n    0  0  frac1+i2  frac1-i2\nendpmatrix\n\nExamples\n\njulia> GateCSXDG(), numcontrols(GateCSXDG()), numtargets(GateCSXDG())\n(Control(Inverse(GateSX())), 1, 1)\n\njulia> matrix(GateCSXDG())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.5-0.5im  0.5+0.5im\n 0.0+0.0im  0.0+0.0im  0.5+0.5im  0.5-0.5im\n\njulia> c = push!(Circuit(), GateCSXDG(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── C(SX†) @ q[1], q[2]\n\njulia> power(GateCSXDG(), 2), inverse(GateCSXDG())\n(Control((Inverse(GateSX()))^2), GateCSX())\n\n\nDecomposition\n\njulia> decompose(GateCSXDG())\n2-qubit circuit with 3 instructions:\n├── H @ q[2]\n├── CU1(-1π/2) @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCU","page":"Standard Gates","title":"MimiqCircuitsBase.GateCU","text":"GateCU(θ, ϕ, λ)\n\nControlled-operatornameU(theta phi lambda) gate.\n\ndetails: Details\nImplemented as an alias to Control(1, GateU(θ, ϕ, λ, γ)).\n\nSee also Control, GateU.\n\noperatornameCU(theta phi lambda gamma) =\nfrac12 beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  e^igamma cosleft(fractheta2right)  -e^igamma e^ilambdasinleft(fractheta2right) \n    0  0  e^igamma mathrme^iphisinleft(fractheta2right)  e^igamma mathrme^i(phi+lambda)cosleft(fractheta2right)\nendpmatrix\n\nExamples\n\njulia> @variables θ ϕ λ γ\n4-element Vector{Symbolics.Num}:\n θ\n ϕ\n λ\n γ\n\njulia> GateCU(θ, ϕ, λ, γ), numcontrols(GateCU(θ, ϕ, λ, γ)), numtargets(GateCU(θ, ϕ, λ, γ))\n(GateCU(θ, ϕ, λ, γ), 1, 1)\n\njulia> matrix(GateCU(2.023, 0.5, 0.1, 0.2))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im       0.0+0.0im             0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im             0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.520013+0.105412im  -0.809771-0.250491im\n 0.0+0.0im  0.0+0.0im  0.648302+0.546057im   0.369666+0.380622im\n\njulia> c = push!(Circuit(), GateCU(θ, ϕ, λ, γ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CU(θ,ϕ,λ,γ) @ q[1], q[2]\n\njulia> push!(c, GateCU(π/8, π/2, π/4, π/7), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CU(θ,ϕ,λ,γ) @ q[1], q[2]\n└── CU(π/8,π/2,π/4,π/7) @ q[1], q[2]\n\njulia> power(GateCU(θ, ϕ, λ, γ), 2), inverse(GateCU(θ, ϕ, λ, γ))\n(Control(GateU(θ, ϕ, λ, γ)^2), GateCU(-θ, -λ, -ϕ, -γ))\n\n\nDecomposition\n\njulia> decompose(GateCU(θ, λ, ϕ, γ))\n2-qubit circuit with 7 instructions:\n├── P(γ) @ q[1]\n├── P((1//2)*(λ + ϕ)) @ q[1]\n├── P((1//2)*(-λ + ϕ)) @ q[2]\n├── CX @ q[1], q[2]\n├── U((-1//2)*θ,0,(1//2)*(-λ - ϕ)) @ q[2]\n├── CX @ q[1], q[2]\n└── U((1//2)*θ,λ,0) @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCP","page":"Standard Gates","title":"MimiqCircuitsBase.GateCP","text":"GateCP(θ)\n\nControlled-operatornameP(lambda) gate.\n\ndetails: Details\nImplemented as an alias to Control(GateP(θ)).\n\nSee also Control, GateRZ.\n\nExamples\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> GateCP(λ), numcontrols(GateCP(λ)), numtargets(GateCP(λ))\n(GateCP(λ), 1, 1)\n\njulia> matrix(GateCP(1.989))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  -0.40612+0.91382im\n\njulia> c = push!(Circuit(), GateCP(λ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CP(λ) @ q[1], q[2]\n\njulia> push!(c, GateCP(π/8), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CP(λ) @ q[1], q[2]\n└── CP(π/8) @ q[1], q[2]\n\njulia> power(GateCP(λ), 2), inverse(GateCP(λ))\n(GateCP(2λ), GateCP(-λ))\n\n\nDecomposition\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> decompose(GateCP(θ))\n2-qubit circuit with 5 instructions:\n├── P((1//2)*θ) @ q[1]\n├── CX @ q[1], q[2]\n├── P((-1//2)*θ) @ q[2]\n├── CX @ q[1], q[2]\n└── P((1//2)*θ) @ q[2]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCRX","page":"Standard Gates","title":"MimiqCircuitsBase.GateCRX","text":"GateCRX(θ)\n\nControlled-operatornameR_X(theta) gate.\n\ndetails: Details\nImplemented as an alias to Control(GateRX(θ)).\n\nSee also Control, GateRX.\n\nMatrix representation\n\noperatornameCRX(theta) = beginpmatrix\n            1  0  0  0 \n            0  1  0  0 \n            0  0  cosfractheta2  -isinfractheta2 \n            0  0  -isinfractheta2  cosfractheta2\n        endpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateCRX(θ), numcontrols(GateCRX(θ)), numtargets(GateCRX(θ))\n(GateCRX(θ), 1, 1)\n\njulia> matrix(GateCRX(1.989))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.544922+0.0im            0.0-0.838487im\n 0.0+0.0im  0.0+0.0im       0.0-0.838487im  0.544922+0.0im\n\njulia> c = push!(Circuit(), GateCRX(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CRX(θ) @ q[1], q[2]\n\njulia> push!(c, GateCRX(π/8), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CRX(θ) @ q[1], q[2]\n└── CRX(π/8) @ q[1], q[2]\n\njulia> power(GateCRX(θ), 2), inverse(GateCRX(θ))\n(GateCRX(2θ), GateCRX(-θ))\n\n\nDecomposition\n\njulia> decompose(GateCRX(θ))\n2-qubit circuit with 5 instructions:\n├── P(π/2) @ q[2]\n├── CX @ q[1], q[2]\n├── U((-1//2)*θ,0,0) @ q[2]\n├── CX @ q[1], q[2]\n└── U((1//2)*θ,-1π/2,0) @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCRY","page":"Standard Gates","title":"MimiqCircuitsBase.GateCRY","text":"GateCRY(θ)\n\nControlled-operatornameR_Y(theta) gate.\n\ndetails: Details\nImplemented as an alias to Control(GateRY(θ)).\n\nSee also Control, GateRY.\n\nMatrix representation\n\noperatornameCRY(theta) = beginpmatrix\n            1  0  0  0 \n            0  1  0  0 \n            0  0  cosfractheta2  -sinfractheta2 \n            0  0   sinfractheta2  cosfractheta2\n        endpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateCRY(θ), numcontrols(GateCRY(θ)), numtargets(GateCRY(θ))\n(Control(GateRY(θ)), 1, 1)\n\njulia> matrix(GateCRY(1.989))\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0        0.0\n 0.0  1.0  0.0        0.0\n 0.0  0.0  0.544922  -0.838487\n 0.0  0.0  0.838487   0.544922\n\njulia> c = push!(Circuit(), GateCRY(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CRY(θ) @ q[1], q[2]\n\njulia> push!(c, GateCRY(π/8), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CRY(θ) @ q[1], q[2]\n└── CRY(π/8) @ q[1], q[2]\n\njulia> power(GateCRY(θ), 2), inverse(GateCRY(θ))\n(Control(GateRY(2θ)), Control(GateRY(-θ)))\n\n\nDecomposition\n\njulia> decompose(GateCRY(θ))\n2-qubit circuit with 4 instructions:\n├── RY((1//2)*θ) @ q[2]\n├── CX @ q[1], q[2]\n├── RY((-1//2)*θ) @ q[2]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCRZ","page":"Standard Gates","title":"MimiqCircuitsBase.GateCRZ","text":"GateCRZ(θ)\n\nControlled-operatornameR_Z(theta) gate.\n\ndetails: Details\nImplemented as an alias to Control(GateRZ(θ)).\n\nSee also Control, GateRZ.\n\nMatrix representation\n\n    operatornameCRZ(theta) = beginpmatrix\n            1  0  0  0 \n            0  1  0  0 \n            0  0  e^-ifraclambda2  0 \n            0  0  0  e^ifraclambda2\n        endpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateCRZ(θ), numcontrols(GateCRZ(θ)), numtargets(GateCRZ(θ))\n(Control(GateRZ(θ)), 1, 1)\n\njulia> matrix(GateCRZ(1.989))\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  1.0+0.0im       0.0+0.0im            0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.544922-0.838487im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im       0.0+0.0im       0.544922+0.838487im\n\njulia> c = push!(Circuit(), GateCRZ(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── CRZ(θ) @ q[1], q[2]\n\njulia> push!(c, GateCRZ(π/8), 1, 2)\n2-qubit circuit with 2 instructions:\n├── CRZ(θ) @ q[1], q[2]\n└── CRZ(π/8) @ q[1], q[2]\n\njulia> power(GateCRZ(θ), 2), inverse(GateCRZ(θ))\n(Control(GateRZ(2θ)), Control(GateRZ(-θ)))\n\n\nDecomposition\n\njulia> decompose(GateCRZ(θ))\n2-qubit circuit with 4 instructions:\n├── RZ((1//2)*θ) @ q[2]\n├── CX @ q[1], q[2]\n├── RZ((-1//2)*θ) @ q[2]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateECR","page":"Standard Gates","title":"MimiqCircuitsBase.GateECR","text":"GateECR()\n\nTwo qubit ECR echo gate.\n\nMatrix representation\n\noperatornameECR = frac1sqrt2\nbeginpmatrix\n    0  1  0  i \n    1  0  -i  0 \n    0  i  0  1 \n    -i  0  1  0\nendpmatrix\n\nExamples\n\njulia> GateECR()\nECR\n\njulia> matrix(GateECR())\n4×4 Matrix{ComplexF64}:\n      0.0+0.0im            0.0+0.0im       …       0.0+0.707107im\n      0.0+0.0im            0.0+0.0im          0.707107+0.0im\n 0.707107+0.0im            0.0-0.707107im          0.0+0.0im\n      0.0-0.707107im  0.707107+0.0im               0.0+0.0im\n\njulia> c = push!(Circuit(), GateECR(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── ECR @ q[1:2]\n\njulia> power(GateECR(), 2), inverse(GateECR())\n(Parallel(2, GateID()), GateECR())\n\n\nDecomposition\n\njulia> decompose(GateECR())\n2-qubit circuit with 3 instructions:\n├── RZX(π/4) @ q[1:2]\n├── X @ q[1]\n└── RZX(-1π/4) @ q[1:2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateDCX","page":"Standard Gates","title":"MimiqCircuitsBase.GateDCX","text":"GateDCX()\n\nTwo qubit double-CNOT (control on first qubit and then second) OR DCX gate.\n\nMatrix representation\n\noperatornameDCX= beginpmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  0  0  1 \n    0  1  0  0\nendpmatrix\n\nExamples\n\njulia> GateDCX()\nDCX\n\njulia> matrix(GateDCX())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n 0.0  1.0  0.0  0.0\n\njulia> c = push!(Circuit(), GateDCX(), 1, 2)\n2-qubit circuit with 1 instructions:\n└── DCX @ q[1:2]\n\njulia> power(GateDCX(), 2), inverse(GateDCX())\n(Inverse(GateDCX()), Inverse(GateDCX()))\n\n\nDecomposition\n\njulia> decompose(GateDCX())\n2-qubit circuit with 2 instructions:\n├── CX @ q[1], q[2]\n└── CX @ q[2], q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRXX","page":"Standard Gates","title":"MimiqCircuitsBase.GateRXX","text":"GateRXX(θ)\n\nParametric two qubit X otimes X interaction \\operatorname{R}_{XX}(\\theta) gate.\n\nIt corresponds to a rotation of theta radians along the XX axis of the two-qubit Bloch sphere.\n\nSee also GateRYY, GateRZZ, GateRZX, GateXXplusYY, GateXXminusYY.\n\nMatrix representation\n\noperatornameR_XX(theta) =\nbeginpmatrix\n    cosleft(fractheta2right)  0  0  -isinleft(fractheta2right) \n    0  cosleft(fractheta2right)  -isinleft(fractheta2right)  0 \n    0  -isinleft(fractheta2right)  cosleft(fractheta2right)  0 \n    -isinleft(fractheta2right)  0  0  cosleft(fractheta2right)\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRXX(θ)\nRXX(θ)\n\njulia> matrix(GateRXX(θ))\n4×4 Matrix{Complex{Symbolics.Num}}:\n     cos((1//2)*θ)                  0                  0  -im*sin((1//2)*θ)\n                 0      cos((1//2)*θ)  -im*sin((1//2)*θ)                  0\n                 0  -im*sin((1//2)*θ)      cos((1//2)*θ)                  0\n -im*sin((1//2)*θ)                  0                  0      cos((1//2)*θ)\n\njulia> c = push!(Circuit(), GateRXX(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RXX(θ) @ q[1:2]\n\njulia> push!(c, GateRXX(π/2), 1, 2)\n2-qubit circuit with 2 instructions:\n├── RXX(θ) @ q[1:2]\n└── RXX(π/2) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateRXX(θ))\n2-qubit circuit with 7 instructions:\n├── H @ q[1]\n├── H @ q[2]\n├── CX @ q[1], q[2]\n├── RZ(θ) @ q[2]\n├── CX @ q[1], q[2]\n├── H @ q[2]\n└── H @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRYY","page":"Standard Gates","title":"MimiqCircuitsBase.GateRYY","text":"GateRYY(θ)\n\nParametric two qubit Y otimes Y interaction \\operatorname{R}_{YY}(\\theta) gate.\n\nIt corresponds to a rotation of theta radians along the YY axis of the two-qubit Bloch sphere.\n\nSee also GateRXX, GateRZZ, GateRZX, GateXXplusYY, GateXXminusYY.\n\nMatrix representation\n\noperatornameR_YY(theta) =\nbeginpmatrix\n    cosleft(fractheta2right)  0  0  isinleft(fractheta2right) \n    0  cosleft(fractheta2right)  -isinleft(fractheta2right)  0 \n    0  -isinleft(fractheta2right)  cosleft(fractheta2right)  0 \n    isinleft(fractheta2right)  0  0  cosleft(fractheta2right)\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRYY(θ)\nRYY(θ)\n\njulia> matrix(GateRYY(θ))\n4×4 Matrix{Complex{Symbolics.Num}}:\n    cos((1//2)*θ)                  0                  0  im*sin((1//2)*θ)\n                0      cos((1//2)*θ)  -im*sin((1//2)*θ)                 0\n                0  -im*sin((1//2)*θ)      cos((1//2)*θ)                 0\n im*sin((1//2)*θ)                  0                  0     cos((1//2)*θ)\n\njulia> c = push!(Circuit(), GateRYY(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RYY(θ) @ q[1:2]\n\njulia> push!(c, GateRYY(π/2), 1, 2)\n2-qubit circuit with 2 instructions:\n├── RYY(θ) @ q[1:2]\n└── RYY(π/2) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateRYY(θ))\n2-qubit circuit with 7 instructions:\n├── RX(π/2) @ q[1]\n├── RX(π/2) @ q[2]\n├── CX @ q[1], q[2]\n├── RZ(θ) @ q[2]\n├── CX @ q[1], q[2]\n├── RX(-1π/2) @ q[1]\n└── RX(-1π/2) @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRZX","page":"Standard Gates","title":"MimiqCircuitsBase.GateRZX","text":"GateRZX(θ)\n\nParametric two qubit Z otimes X interaction \\operatorname{R}_{ZX}(\\theta) gate.\n\nIt corresponds to a rotation of theta radians about ZX.\n\nSee also GateRXX, GateRYY, GateRZZ, GateXXplusYY, GateXXminusYY.\n\nMatrix representation\n\noperatornameRZX(theta) =beginpmatrix\n            cos(fractheta2)  -isin(fractheta2)  0  0 \n            -isin(fractheta2)  cos(fractheta2)  0  0 \n            0  0  cos(fractheta2)  isin(fractheta2) \n            0  0  isin(fractheta2)  cos(fractheta2)\n        endpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRZX(θ)\nRZX(θ)\n\njulia> matrix(GateRZX(θ))\n4×4 Matrix{Complex{Symbolics.Num}}:\n     cos((1//2)*θ)  -im*sin((1//2)*θ)                 0                 0\n -im*sin((1//2)*θ)      cos((1//2)*θ)                 0                 0\n                 0                  0     cos((1//2)*θ)  im*sin((1//2)*θ)\n                 0                  0  im*sin((1//2)*θ)     cos((1//2)*θ)\n\njulia> c = push!(Circuit(), GateRZX(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RZX(θ) @ q[1:2]\n\njulia> push!(c, GateRZX(π/2), 1, 2)\n2-qubit circuit with 2 instructions:\n├── RZX(θ) @ q[1:2]\n└── RZX(π/2) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateRZX(θ))\n2-qubit circuit with 5 instructions:\n├── H @ q[2]\n├── CX @ q[1], q[2]\n├── RZ(θ) @ q[2]\n├── CX @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateRZZ","page":"Standard Gates","title":"MimiqCircuitsBase.GateRZZ","text":"GateRZZ(θ)\n\nParametric two qubit Z otimes Z interaction \\operatorname{R}_{ZZ}(\\theta) gate.\n\nIt corresponds to a rotation of theta radians along the ZZ axis of the two-qubit Bloch sphere.\n\nSee also GateRXX, GateRYY, GateRZX, GateXXplusYY, GateXXminusYY.\n\nMatrix representation\n\noperatornameR_ZZ(theta) =\nbeginpmatrix\n    e^-ifractheta2  0  0  0 \n    0  e^ifractheta2  0  0 \n    0  0  e^ifractheta2  0 \n    0  0  0  e^-ifractheta2\nendpmatrix\n\nExamples\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> GateRZZ(θ)\nRZZ(θ)\n\njulia> matrix(GateRZZ(θ))\n4×4 Matrix{Complex{Symbolics.Num}}:\n cos((-1//2)*θ) + im*sin((-1//2)*θ)  …                           0\n                          0                                      0\n                          0                                      0\n                          0             cos((-1//2)*θ) + im*sin((-1//2)*θ)\n\njulia> c = push!(Circuit(), GateRZZ(θ), 1, 2)\n2-qubit circuit with 1 instructions:\n└── RZZ(θ) @ q[1:2]\n\njulia> push!(c, GateRZZ(π/2), 1, 2)\n2-qubit circuit with 2 instructions:\n├── RZZ(θ) @ q[1:2]\n└── RZZ(π/2) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateRZZ(θ))\n2-qubit circuit with 3 instructions:\n├── CX @ q[1], q[2]\n├── RZ(θ) @ q[2]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateXXminusYY","page":"Standard Gates","title":"MimiqCircuitsBase.GateXXminusYY","text":"GateXXminusYY(θ, β)\n\nParametric two qubit X otimes X - Y otimes Y interaction operatorname(XX-YY)(theta beta) gate, where theta and beta are the rotation and phase angles.\n\nSee also GateRXX, GateRYY, GateRZZ, GateRZX, GateXXplusYY.\n\nMatrix Representation\n\noperatorname(XX-YY)(theta beta) =\nbeginpmatrix\n    cos(fractheta2)  0  0  -isin(fractheta2)e^-ibeta \n    0  1  0  0 \n    0  0  1  0 \n    -isin(fractheta2)e^ibeta  0  0  cos(fractheta2)\nendpmatrix\n\nExamples\n\njulia> @variables θ β\n2-element Vector{Symbolics.Num}:\n θ\n β\n\njulia> GateXXminusYY(θ, β)\nXXminusYY(θ, β)\n\njulia> matrix(GateXXminusYY(θ, β))\n4×4 Matrix{Complex{Symbolics.Num}}:\n          cos((1//2)*θ)                          …  sin(-β)*sin((1//2)*θ) - im*cos(-β)*sin((1//2)*θ)\n                      0                                                            0\n                      0                                                            0\n sin(β)*sin((1//2)*θ) - im*cos(β)*sin((1//2)*θ)                        cos((1//2)*θ)\n\njulia> c = push!(Circuit(), GateXXminusYY(θ, β), 1, 2)\n2-qubit circuit with 1 instructions:\n└── XXminusYY(θ,β) @ q[1:2]\n\njulia> push!(c, GateXXminusYY(π/2, 0.0), 1, 2)\n2-qubit circuit with 2 instructions:\n├── XXminusYY(θ,β) @ q[1:2]\n└── XXminusYY(π/2,0π) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateXXminusYY(θ, β))\n2-qubit circuit with 14 instructions:\n├── RZ(-β) @ q[2]\n├── RZ(-1π/2) @ q[1]\n├── SX @ q[1]\n├── RZ(π/2) @ q[1]\n├── S @ q[2]\n├── CX @ q[1], q[2]\n├── RY((1//2)*θ) @ q[1]\n├── RY((-1//2)*θ) @ q[2]\n├── CX @ q[1], q[2]\n├── S† @ q[2]\n├── RZ(-1π/2) @ q[1]\n├── SX† @ q[1]\n├── RZ(π/2) @ q[1]\n└── RZ(β) @ q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateXXplusYY","page":"Standard Gates","title":"MimiqCircuitsBase.GateXXplusYY","text":"GateXXplusYY(θ, β)\n\nParametric two qubit X otimes X + Y otimes Y interaction operatorname(XX+YY)(theta beta) gate, where theta and beta are the rotation and phase angles.\n\nSee also GateRXX, GateRYY, GateRZZ, GateRZX, GateXXminusYY.\n\nMatrix representation\n\noperatorname(XX+YY)(theta beta) =\nbeginpmatrix\n    1  0  0  0 \n    0  cos(fractheta2)  -isin(fractheta2)e^ibeta  0 \n    0  -isin(fractheta2)e^-ibeta  cos(fractheta2)  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> @variables θ β\n2-element Vector{Symbolics.Num}:\n θ\n β\n\njulia> GateXXplusYY(θ, β)\nXXplusYY(θ, β)\n\njulia> matrix(GateXXplusYY(θ, β))\n4×4 Matrix{Complex{Symbolics.Num}}:\n 1                                 0                  …  0\n 0                     cos((1//2)*θ)                     0\n 0  sin(-β)*sin((1//2)*θ) - im*cos(-β)*sin((1//2)*θ)     0\n 0                                 0                     1\n\njulia> c = push!(Circuit(), GateXXplusYY(θ, β), 1, 2)\n2-qubit circuit with 1 instructions:\n└── XXplusYY(θ,β) @ q[1:2]\n\njulia> push!(c, GateXXplusYY(π/2, 0), 1, 2)\n2-qubit circuit with 2 instructions:\n├── XXplusYY(θ,β) @ q[1:2]\n└── XXplusYY(π/2,0) @ q[1:2]\n\n\nDecomposition\n\njulia> decompose(GateXXplusYY(θ, β))\n2-qubit circuit with 14 instructions:\n├── RZ(β) @ q[1]\n├── RZ(-1π/2) @ q[2]\n├── SX @ q[2]\n├── RZ(π/2) @ q[2]\n├── S @ q[1]\n├── CX @ q[2], q[1]\n├── RY((-1//2)*θ) @ q[2]\n├── RY((-1//2)*θ) @ q[1]\n├── CX @ q[2], q[1]\n├── S† @ q[1]\n├── RZ(-1π/2) @ q[2]\n├── SX† @ q[2]\n├── RZ(π/2) @ q[2]\n└── RZ(-β) @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCSWAP","page":"Standard Gates","title":"MimiqCircuitsBase.GateCSWAP","text":"GateCSWAP()\n\nThree-qubit, controlled-operatornameSWAP gate.\n\ndetails: Details\nImplemented as an alias to Control{1,2,3,GateSWAP}.\n\nSee also Control, GateU.\n\nnote: Note\nBy convention, the first qubit is the control and the last two are targets.\n\nExamples\n\njulia> GateCSWAP(), numcontrols(GateCSWAP()), numtargets(GateCSWAP())\n(GateCSWAP(), 1, 2)\n\njulia> matrix(GateCSWAP())\n8×8 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0\n\njulia> c = push!(Circuit(), GateCSWAP(), 1, 2, 3)\n3-qubit circuit with 1 instructions:\n└── CSWAP @ q[1], q[2:3]\n\njulia> power(GateCSWAP(), 2), inverse(GateCSWAP())\n(Control(Parallel(2, GateID())), GateCSWAP())\n\n\nDecomposition\n\njulia> decompose(GateCSWAP())\n3-qubit circuit with 3 instructions:\n├── CX @ q[3], q[2]\n├── C₂X @ q[1:2], q[3]\n└── CX @ q[3], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateC3X","page":"Standard Gates","title":"MimiqCircuitsBase.GateC3X","text":"GateC3X()\n\nFour qubit, triply-controlled X gate.\n\ndetails: Details\nImplemented as an alias to Control(3 GateX()).\n\nnote: Note\nBy convention, the first three qubits are the controls and the fourth is the target.\n\nExamples\n\njulia> GateC3X(), numcontrols(GateC3X()), numtargets(GateC3X())\n(Control(3, GateX()), 3, 1)\n\njulia> matrix(GateC3X())\n16×16 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  1.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n\njulia> c = push!(Circuit(), GateC3X(), 1, 2, 3, 4)\n4-qubit circuit with 1 instructions:\n└── C₃X @ q[1:3], q[4]\n\njulia> power(GateC3X(), 2), inverse(GateC3X())\n(Control(3, GateID()), Control(3, GateX()))\n\n\nDecomposition\n\njulia> decompose(GateC3X())\n4-qubit circuit with 31 instructions:\n├── H @ q[4]\n├── P(π/8) @ q[1]\n├── P(π/8) @ q[2]\n├── P(π/8) @ q[3]\n├── P(π/8) @ q[4]\n├── CX @ q[1], q[2]\n├── P(-1π/8) @ q[2]\n├── CX @ q[1], q[2]\n├── CX @ q[2], q[3]\n⋮   ⋮\n├── CX @ q[1], q[4]\n├── P(π/8) @ q[4]\n├── CX @ q[3], q[4]\n├── P(-1π/8) @ q[4]\n├── CX @ q[2], q[4]\n├── P(π/8) @ q[4]\n├── CX @ q[3], q[4]\n├── P(-1π/8) @ q[4]\n├── CX @ q[1], q[4]\n└── H @ q[4]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCCX","page":"Standard Gates","title":"MimiqCircuitsBase.GateCCX","text":"GateCCX()\n\nThree-qubit, doubly-controlled X gate.\n\ndetails: Details\nImplemented as an alias to Control(2 GateX()).\n\nnote: Note\nBy convention, the first two qubits are the controls and the third is the target.\n\nExamples\n\njulia> GateCCX(), numcontrols(GateCCX()), numtargets(GateCCX())\n(Control(2, GateX()), 2, 1)\n\njulia> matrix(GateCCX())\n8×8 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n\njulia> c = push!(Circuit(), GateCCX(), 1, 2, 3)\n3-qubit circuit with 1 instructions:\n└── C₂X @ q[1:2], q[3]\n\njulia> power(GateCCX(), 2), inverse(GateCCX())\n(Control(2, GateID()), Control(2, GateX()))\n\n\nDecomposition\n\njulia> decompose(GateCCX())\n3-qubit circuit with 15 instructions:\n├── H @ q[3]\n├── CX @ q[2], q[3]\n├── T† @ q[3]\n├── CX @ q[1], q[3]\n├── T @ q[3]\n├── CX @ q[2], q[3]\n├── T† @ q[3]\n├── CX @ q[1], q[3]\n├── T @ q[2]\n├── T @ q[3]\n├── H @ q[3]\n├── CX @ q[1], q[2]\n├── T @ q[1]\n├── T† @ q[2]\n└── CX @ q[1], q[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/standard/#MimiqCircuitsBase.GateCCP","page":"Standard Gates","title":"MimiqCircuitsBase.GateCCP","text":"GateCCP(λ)\n\nThree-qubit, doubly-controlled phase gate.\n\ndetails: Details\nImplemented as an alias to Control(2 GateP(λ)).\n\nnote: Note\nBy convention, the first two qubits are the controls and the third is the target.\n\nExamples\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> GateCCP(λ), numcontrols(GateCCP(λ)), numtargets(GateCCP(λ))\n(GateCCP(λ), 2, 1)\n\njulia> matrix(GateCCP(1.989))\n8×8 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  …  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im     0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im     0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  …  0.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im     1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im  -0.40612+0.91382im\n\njulia> c = push!(Circuit(), GateCCP(λ), 1, 2, 3)\n3-qubit circuit with 1 instructions:\n└── CCP(λ) @ q[1:2], q[3]\n\njulia> push!(c, GateCCP(π/8), 1, 2, 3)\n3-qubit circuit with 2 instructions:\n├── CCP(λ) @ q[1:2], q[3]\n└── CCP(π/8) @ q[1:2], q[3]\n\njulia> power(GateCCP(λ), 2), inverse(GateCCP(λ))\n(GateCCP(2λ), GateCCP(-λ))\n\n\nDecomposition\n\njulia> @variables λ\n1-element Vector{Symbolics.Num}:\n λ\n\njulia> decompose(GateCCP(λ))\n3-qubit circuit with 5 instructions:\n├── CP((1//2)*λ) @ q[2], q[3]\n├── CX @ q[1], q[2]\n├── CP((-1//2)*λ) @ q[2], q[3]\n├── CX @ q[1], q[2]\n└── CP((1//2)*λ) @ q[1], q[3]\n\n\n\n\n\n","category":"type"},{"location":"manual/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"In this section, we’ll walk you through the steps needed to get MIMIQ up and running on your system. We’ll cover everything from installing Julia, adding the necessary registries, and installing the MIMIQ packages, to setting up Jupyter with a Julia kernel for an enhanced coding experience. By the end of this guide, you’ll be ready to dive into quantum computing with MIMIQ.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Installation\nInstalling Julia\nInstall juliaup\nWindows\nmacOS and Linux\nInstall Julia\nAdding the QPerfect Registry\nInstalling MIMIQ\nUsing MIMIQ and Julia with Jupyter\nInstall Jupyter\nStart Jupyter\nUsing MIMIQ in Jupyter","category":"page"},{"location":"manual/installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"To get started with MIMIQ, you will need to have Julia installed on your system. Julia is a high-level, high-performance programming language for technical computing. We recommend using juliaup for an easy and streamlined installation process.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"juliaup is a Julia version manager that simplifies the installation and management of Julia versions on your system. It allows you to easily switch between different versions of Julia, ensuring you always have the right version for your project.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"To install Julia using juliaup, follow these steps:","category":"page"},{"location":"manual/installation/#Install-juliaup","page":"Installation","title":"Install juliaup","text":"","category":"section"},{"location":"manual/installation/#Windows","page":"Installation","title":"Windows","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"On windows, you can install juliaup from the Microsoft Store.","category":"page"},{"location":"manual/installation/#macOS-and-Linux","page":"Installation","title":"macOS and Linux","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"On macOS and Linux, you can install juliaup using the following command in your terminal:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"curl -fsSl https://install.julialang.org | sh","category":"page"},{"location":"manual/installation/#Install-julia","page":"Installation","title":"Install julia","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Once juliaup is installed, you can install the latest stable version of Julia by running:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"juliaup add release","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"For more detailed instructions on installing juliaup, refer to juliaup's installation guide, and for more information and alternative methods for installing Julia, refer to the official Julia website.","category":"page"},{"location":"manual/installation/#Adding-the-QPerfect-Registry","page":"Installation","title":"Adding the QPerfect Registry","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Before you can install MIMIQ, you need to add the QPerfect registry. This step is crucial as it allows you to access the MIMIQ packages, released by QPerfect.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"To add the QPerfect registry, open your Julia REPL and enter the package mode by pressing the ] key. Then run the following command:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"(@v1.11)> registry add General\n(@v1.11)> registry add https://github.com/qperfect-io/QPerfectRegistry.git","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Alternatively, from the Julia REPL, without switching to package mode, you can run the following command:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.Registry.add(\"General\")\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/qperfect-io/QPerfectRegistry.git\"))","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"note: Note\nIf this is your first time running Julia, adding the QPerfect registry will prevent Julia from adding the default General registry automatically.","category":"page"},{"location":"manual/installation/#Installing-MIMIQ","page":"Installation","title":"Installing MIMIQ","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Once the QPerfect registry is added, you can install the MimiqCircuits package. This package is essential for using the MIMIQ framework for simulating quantum circuits. Run the following command in your Julia REPL, in package mode:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"(@v1.11)> add MimiqCircuits","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Alternatively, you can run the following command without switching to package mode:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"MimiqCircuits\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"this will install the latest version of the MIMIQ package in your main Julia environment ((@v0.15) in this case). You can follow the same steps to install the package in other environments if needed.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"To test if the installation was successful, you can run the following command in your Julia REPL:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using MimiqCircuits","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"You are now ready to start using MIMIQ for simulating quantum circuits in Julia!","category":"page"},{"location":"manual/installation/#Using-MIMIQ-and-Julia-with-Jupyter","page":"Installation","title":"Using MIMIQ and Julia with Jupyter","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Jupyter is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. It is an excellent tool for interactive computing often used in data analysis or other technical workflows.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"To use MIMIQ and Julia within Jupyter, you will need to install Jupyter and set up the proper kernel. Here's how you can do it:","category":"page"},{"location":"manual/installation/#Install-Jupyter","page":"Installation","title":"Install Jupyter","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Follow the official Jupyter installation guide to install Jupyter on your system. The easiest way is to use pip from a working Python installation (pip install notebook)..","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Install the Julia Jupyter kernel (IJulia). After installing Jupyter, you need to add the Julia kernel. Run the following commands in your Julia REPL in package mode:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"(@v1.11)> add IJulia","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"or alternatively, without switching to package mode:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"IJulia\")","category":"page"},{"location":"manual/installation/#Start-Jupyter","page":"Installation","title":"Start Jupyter","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"You can start Jupyter by running the following command in your terminal:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"jupyter notebook","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"This will open Jupyter in your default web browser. As an alternative, you can run Jupyter directly from the Julia REPL by running:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using IJulia\nnotebook()","category":"page"},{"location":"manual/installation/#Using-MIMIQ-in-Jupyter","page":"Installation","title":"Using MIMIQ in Jupyter","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Now that you have Jupyter set up and  running with the Julia kernel, you can start using MIMIQ. Create a new notebook and select the Julia kernel. Then you can import and use MimiqCircuits as follows:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using MimiqCircuits","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"You are now ready to explore and experiment with MIMIQ in a Jupyter notebook.","category":"page"},{"location":"manual/noise/#Noisy-simulations-on-MIMIQ","page":"Noise","title":"Noisy simulations on MIMIQ","text":"","category":"section"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Here we explain how to run noisy simulations that mimic the behavior of real quantum computers on MIMIQ. In this section you'll find:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Noisy simulations on MIMIQ","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"- [Summary of noise functionality](#summary-of-noise-functionality)\n- [Mathematical background](#mathematical-background)\n\t- [Kraus operators](#kraus-operators)\n\t- [Evolution with noise](#evolution-with-noise)\n- [Building noise channels](#building-noise-channels)\n- [How to add noise](#how-to-add-noise)\n\t- [Adding noise one by one](#adding-noise-one-by-one)\n\t- [Adding noise to all gates of same type](#adding-noise-to-all-gates-of-same-type)\n- [Running a noisy circuit](#running-a-noisy-circuit)","category":"page"},{"location":"manual/noise/#Summary-of-noise-functionality","page":"Noise","title":"Summary of noise functionality","text":"","category":"section"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Custom noise channels:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Kraus\nMixedUnitary","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Specialized noise channels:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Depolarizing\nDepolarizing1\nDepolarizing2\nPauliNoise\nPauliX\nPauliY\nPauliZ\nAmplitudeDamping\nGeneralizedAmplitudeDamping\nPhaseAmplitudeDamping\nThermalNoise\nProjectiveNoise","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Note that the Reset type operations can also be thought of as noisy operations. Coherent noise can be added by using any of the supported gates (MimiqCircuitsBase.GATES).","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Noise channels come with the following methods:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"krausmatrices and krausoperators\nunitarymatrices and unitarygates (only for mixed-unitary)\nprobabilities (only for mixed-unitary)\nismixedunitary","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"To add noise channels to a circuit you can use:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"push! (like gates)\nadd_noise or add_noise! (add noise to every instance of a gate)","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"To generate one sample of a circuit with mixed unitaries use:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"sample_mixedunitaries","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"See below for further information. You can also run ? followed by the given function in the command line (e.g. ?Kraus), or using @doc in Jupyter (e.g. @doc Kraus).","category":"page"},{"location":"manual/noise/#Mathematical-background","page":"Noise","title":"Mathematical background","text":"","category":"section"},{"location":"manual/noise/#Kraus-operators","page":"Noise","title":"Kraus operators","text":"","category":"section"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Noise in a quantum circuit refers to any kind of unwanted interaction of the qubits with the environment (or with itself). Mathematically, this puts us in the framework of open systems and the state of the qubits now needs to be described in terms of a density matrix rho, which fulfills rho=rho^dagger, mathrmTr rho = 1. A quantum operation such as noise can then be described using the Kraus operator representation as","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"\tmathcalE(rho) = sum_k E_k rho E_k^dagger","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"We consider only completely positive and trace preserving (CPTP) operations. In this case, the Kraus operators E_k can be any matrix as long as the fulfill the completeness relation sum_k E_k^dagger E_k = I. Note that unitary gates U just correspond to a single Kraus operator, E_1=U.","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"When all Kraus operators are proportional to a unitary matrix, E_k = alpha_k U_k, this is called a mixed-unitary quantum operation and can be written as (p_k = alpha_k^2)","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"\tmathcalE(rho) = sum_k p_k U_k rho U_k^dagger","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Such operations are easier to implement as we'll see below.","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Remarks:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Unitary gates U just correspond to a single Kraus operator, E_1=U.\nThe number of Kraus operators depends on the noise considered.\nFor a given quantum operation mathcalE the Kraus operator representation is not unique. One can change the basis of Kraus operators using a unitary matrix U as tildeE_i = sum_j U_ij E_j.","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"We define a noise channel (or Kraus channel) as a quantum operation mathcalE described by a set of Kraus operators as given above. A common way of modeling noisy quantum computers is by considering each operation O that happens in the circuit as a noisy quantum operation mathcalE_O. The full noisy operation can in principle be described using Kraus operators, but usually it is decomposed as tildeO = mathcalE_2 circ O circ mathcalE_1, where mathcalE_1 and mathcalE_2 are noise channels. In the case of gates we usually only consider a noise channel after the gate. Note that one common assumption in this type of noise modeling is that the noise channels of different gates are independent from each other.","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"For more details on noise see for example Nielsen and Chuang, Quantum Computation and Quantum Information, Chapter 8.","category":"page"},{"location":"manual/noise/#Evolution-with-noise","page":"Noise","title":"Evolution with noise","text":"","category":"section"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"There are two common ways to evolve the state of the system when acting with Kraus channels as defined above:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Density matrix: If we use a density matrix to describe the qubits, then a Kraus channel can simply be applied by directly performing the matrix multiplications as mathcalE(rho) = sum_k E_k rho E_k^dagger. The advantage of this approach is that the density matrix contains the full information of the system and we only need to run the circuit once. The disadvantage is that rho requires more memory to be stored (2^2N as opposed to 2^N for a state vector) so we can simulate fewer qubits.\nQuantum trajectories: This method consists in simulating the evolution of the state vector psi_alpha rangle for a set of iterations alpha = 1 ldots n. In each iteration a noise channel is applied by randomly selecting one of the Kraus operators according to some probabilities (see below) and applying that Kraus operator to the state vector. The advantage of this approach is that we need less memory since we work with a state vector. The disadvantage is that we need to run the circuit many times to collect samples (one sample per run).","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Currently, MIMIQ only implements the quantum trajectories method.","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"The basis for quantum trajectories is that a Kraus channel can be rewritten as","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"\tmathcalE(rho) = sum_k p_k tildeE_k rho tildeE_k^dagger","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"where p_k = mathrmTr(E_k rho E_k^dagger) and tildeE_k = E_k  sqrtp_k. The parameters p_k can be interpreted as probabilities since they fulfill 0 leq p_k leq 1 and sum_k p_k = 1. In this way, the Kraus channel can be viewed as a linear combination of operations with different Kraus operators weighted by the probabilities p_k. Note that the probabilities p_k generally depend on the state, so they need to be computed at runtime. The exception is mixed-unitary channels, for which the probabilities are fixed (state-independent), see above.","category":"page"},{"location":"manual/noise/#Building-noise-channels","page":"Noise","title":"Building noise channels","text":"","category":"section"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"You can create noise channels using one of the many functions available, see summary. Most of the noise channels take one or more parameters, and the custom channels require passing the Kraus matrices and/or probabilities. Here are some examples of how to build noise channels:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"using MimiqCircuits\np = 0.1    # probability\nPauliX(p)","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"p, gamma = 0.1, 0.2    # parameters\nGeneralizedAmplitudeDamping(p,gamma)","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"ps = [0.8,0.1,0.1]    # probabilities\npaulis = [\"II\",\"XX\",\"YY\"]    # Pauli strings\nPauliNoise(ps,paulis)","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"ps = [0.9, 0.1]    # probabilities\nunitaries = [[1 0; 0 1], [1 0; 0 -1]]    # unitary matrices\nMixedUnitary(ps, unitaries)","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"kmatrices = [[1 0; 0 sqrt(0.9)], [0 sqrt(0.1); 0 0]]    # Kraus matrices\nKraus(kmatrices)","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Check the documentation of each noise channel to understand the conditions that each of the parameters needs to fulfill for the noise channel to be valid.","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"In MIMIQ the most important distinction of noise channels is between mixed unitary and general Kraus channels (see mathematical section for definitions). You can use ismixedunitary to check if a channel is mixed unitary or not like this:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"ismixedunitary(PauliX(0.1))","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"ismixedunitary(AmplitudeDamping(0.1))","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"In both cases you can get the Kraus matrices/operators used to define the given channel by using krausmatrices or krausoperators. For example:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"krausmatrices(ProjectiveNoise(\"Z\"))","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"In the case of mixed unitary channels, you can separately obtain the list of probabilities and the list of unitary gates/matrices using probabilities and unitarymatrices  or unitarygates, respectively.","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"unitarymatrices(PauliZ(0.1))","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"unitarygates(Depolarizing1(0.1))","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"probabilities(PauliNoise([0.1,0.9],[\"II\",\"ZZ\"]))\n[0.1 0.9] # hide","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"In MIMIQ, noise channels can be added at any point in the circuit in order to make any operation noisy. For noisy gates, one would normally add a noise channel after an ideal gate. To model measurement, preparation and reset errors one can simply add noise channels before and/or after the corresponding operation. More information in the next section.","category":"page"},{"location":"manual/noise/#How-to-add-noise","page":"Noise","title":"How to add noise","text":"","category":"section"},{"location":"manual/noise/#Adding-noise-one-by-one","page":"Noise","title":"Adding noise one by one","text":"","category":"section"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"The simplest and most flexible way to add noise to a circuit is by using push!(@ref), the same way that we add gates. Here's an example of how to create a noisy 5-qubit GHZ circuit:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"c = Circuit()\npush!(c, PauliX(0.1), 1:5)    # preparation/reset error since all qubits start in 0\n\npush!(c, GateH(), 1)\npush!(c, AmplitudeDamping(0.1), 1)    # 1-qubit noise for GateH\n\npush!(c, GateCX(), 1, 2:5)\npush!(c, Depolarizing2(0.1), 1, 2:5)    # 2-qubit noise for GateCX\n\npush!(c, PauliX(0.1), 1:5)    # measurement error. Note it's added before the measurement\npush!(c, Measure(), 1:5, 1:5)","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Note how we added bit-flip error (PauliX) at beginning for state preparation/reset errors and right before measuring for measurement errors.","category":"page"},{"location":"manual/noise/#Adding-noise-to-all-gates-of-same-type","page":"Noise","title":"Adding noise to all gates of same type","text":"","category":"section"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Usually, when we add noise to a circuit we want to add the same type of noise to each instance of a given gate. For this purpose, instead of adding noise channels one by one you can use add_noise or add_noise! (same but in-place). It takes several parameters:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"add_noise(c, g, kraus; before=false, parallel=false)","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"This function will add the noise channel specified by kraus to every instance of gate g in the circuit c. The optional parameter before (default=false) determines whether to add the noise before or after the operation, and the parameter parallel (default=false) determines whether to add the noise in parallel after/before a block of transversal gates.","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Here is how to construct the same example of a noisy GHZ circuit as before but with add_noise:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"c = Circuit()\npush!(c, Reset(), 1:5)\npush!(c, GateH(), 1)\npush!(c, GateCX(), 1, 2:5)\npush!(c, Measure(), 1:5, 1:5)\n\ncnoise = add_noise(c, Reset(), PauliX(0.1); parallel=true)\ncnoise = add_noise(cnoise, GateH(), AmplitudeDamping(0.1))\ncnoise = add_noise(cnoise, GateCX(), Depolarizing2(0.1); parallel=true)\ncnoise = add_noise(cnoise, Measure(), PauliX(0.1); before=true, parallel=true)","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Note that we added a trivial Reset operation at the very beginning just to be able to add the state preparation error with the add_noise functionality. The qubits already start at 0 anyway.","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"The add_noise function becomes particularly useful in big circuits with lots of repetitions of gates. For further details check the API documentation of add_noise and add_noise!.","category":"page"},{"location":"manual/noise/#Running-a-noisy-circuit","page":"Noise","title":"Running a noisy circuit","text":"","category":"section"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"Circuits with noise can be run with the same execute function as used for circuits without noise, see simulation and cloud execution pages. Recall that currently noisy simulations will be run using quantum trajectories. In this case, when running a circuit with noise for n samples the circuit will internally be run once for every sample. In every run, a different set of random Kraus operators will be selected based on the corresponding probabilities.","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"When the noise channel is a mixed unitary channel the unitary operators to be applied can be selected before starting to apply operations on the state. We provide the function sample_mixedunitaries to generate samples of a circuit with mixed unitary noise as follows:","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"using Random\nrng = MersenneTwister(42)\n\nc = Circuit()\npush!(c, Depolarizing1(0.5), 1:5)\n\n# Produce a circuit with either I, X, Y, or Z in place of each depolarizing channel\ncsampled = sample_mixedunitaries(c; rng=rng, ids=true)","category":"page"},{"location":"manual/noise/","page":"Noise","title":"Noise","text":"This function is internally called when executing a circuit, but can also be used outside of execution.","category":"page"},{"location":"manual/unitary_gates/#Unitary-Gates","page":"Unitary Gates","title":"Unitary Gates","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Unitary gates are fundamental components of quantum circuits. Here we explain how to work with unitary gates in MIMIQ.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Unitary Gates\nMathematical background\nState vector and probability\nUnitary transformation\nUnitary gates in MIMIQ.\nSingle-qubit gates\nSingle-qubit parametric gates\nTwo qubit gates\nTwo-qubit parametric gates\nMulti-qubit gates\nGeneralized gates\nCustom Gates\nComposition: Control, Power, Inverse, Parallel\nControl\nPower\nInverse\nParallel\nExtract information of unitary gates\nMatrix\nNumber of targets","category":"page"},{"location":"manual/unitary_gates/#Mathematical-background","page":"Unitary Gates","title":"Mathematical background","text":"","category":"section"},{"location":"manual/unitary_gates/#State-vector-and-probability","page":"Unitary Gates","title":"State vector and probability","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"In quantum mechanics, every transformation applied to a quantum state must be unitary (in a closed system). To understand why, we can expand the quantum state as  ","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"beginaligned\nketpsi = sum_i=1^k c_i ketpsi_i\nendaligned","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"where ketpsi_i are orthonormal basis states. For this state, the following condition must hold true:  ","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"beginaligned\nsum_i=1^k c_i² = 1 \nendaligned","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Since c_i^2 corresponds to the probability of measuring state ketpsi_i, this condition simply says that the probabilities must add up to one. Unitary gates preserve this normalization condition, see below.","category":"page"},{"location":"manual/unitary_gates/#Unitary-transformation","page":"Unitary Gates","title":"Unitary transformation","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"An alternative way to compute the probability is through the inner product. Given two states in Hilbert space, ketalpha and ketpsi, the squared inner product braketalphapsi^2 reflects the probability of measuring the system in state ketalpha.  Thus, the normalization condition can be written asbraketpsipsi^2 = 1. In other words, the length of the state vector in complex space must be one.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"When evolving the state ketpsi using an operator U, the normalization condition becomes (omitting the square):  ","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"beginaligned\nbrapsi U^dagger U ketpsi = 1\nendaligned","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"To fulfill this, the operator U must satisfy the condition:  ","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"beginaligned\nU^dagger U = I\nendaligned","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"An operator that fulfills this requirement is called a unitary operator and its matrix representation is unitary too.","category":"page"},{"location":"manual/unitary_gates/#Unitary-gates-in-MIMIQ.","page":"Unitary Gates","title":"Unitary gates in MIMIQ.","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"MIMIQ offers a large number of gates to build quantum circuits. For an overview, type the following line in your Julia session:","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"?GATES","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Similarly, to get more information about a specific gate, you can type the following command in your Julia session using the gate of your choice:","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"?GateID","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"There are different categories of gates depending on the number of targets, parameters etc. We discuss how to implement them in the following.","category":"page"},{"location":"manual/unitary_gates/#Single-qubit-gates","page":"Unitary Gates","title":"Single-qubit gates","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"List of single-qubit gates: GateID, GateX, GateY, GateZ, GateH, GateS, GateSDG, GateT, GateTDG, GateSX, GateSXDG. GateSY, GateSYDG.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"For single-qubit gates you don't need to give any argument to the gate constructor (ex: GateX()). You only need to give the index of the target qubit when adding it to your circuit with the push! function.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"using MimiqCircuits # hide\ncircuit = Circuit() # hide\npush!(circuit, GateX(), 1)","category":"page"},{"location":"manual/unitary_gates/#Single-qubit-parametric-gates","page":"Unitary Gates","title":"Single-qubit parametric gates","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"List of single-qubit parametric gates:  GateU, GateP, GateRX, GateRY, GateRZ, GateR, GateU1, GateU2, GateU3, Delay.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"For single-qubit parametric gates you need to give the expected number of parameters to the gate constructor (ex: GateU(0.5, 0.5, 0.5) or GateU1(0.5)), if you are unsure of the expected number of parameters type ? before the name of the gate in your Julia session (ex: ?GateU). As for any single qubit gates you can add it to your circuit by using the push! function and give the index of the target qubit.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"circuit = Circuit() #  hide\npush!(circuit, GateRX(pi/2), 1)","category":"page"},{"location":"manual/unitary_gates/#Two-qubit-gates","page":"Unitary Gates","title":"Two qubit gates","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"List of two qubits gates: GateCX, GateCY, GateCZ, GateCH, GateSWAP, GateISWAP, GateCS, GateCSDG, GateCSX, GateCSXDG, GateECR, GateDCX.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Two-qubit gates can be instantiated without any arguments just like single-qubit gates (ex: GateCX()). You will need to give the index of both qubits to the push! function to add it to the circuit. To understand the ordering of the targets check the documentation of each particular gate. For controlled gates we use the convention that the first register corresponds to the control and the second to the target.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"circuit = Circuit() # hide\npush!(circuit, GateCH(), 1, 2)","category":"page"},{"location":"manual/unitary_gates/#Two-qubit-parametric-gates","page":"Unitary Gates","title":"Two-qubit parametric gates","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"List of two qubits parametric gates : GateCP, GateCU, GateCRX, GateCRY, GateCRZ, GateRXX, GateRYY, GateRZZ, GateRZX, GateXXplusYY, GateXXminusYY.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Two-qubit parametric gates are instantiated exactly like single-qubit parametric gates. You will need to give the expected number of parameters of the gate to its constructor (ex: GateCU(pi, pi, pi)). You can then add it to the circuit just like a two-qubit gate by giving the index of the target qubits to the push! function. Again, check each gate's documentation to understand the qubit ordering; for controlled gates the first qubit corresponds to the control qubit, the second to the target.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"circuit = Circuit() # hide\npush!(circuit, GateRXX(pi/2), 1, 2)","category":"page"},{"location":"manual/unitary_gates/#Multi-qubit-gates","page":"Unitary Gates","title":"Multi-qubit gates","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"List of multi-qubit gates: GateCCX, GateC3X, GateCCP, GateCSWAP.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"For the multi-qubit controlled gates you will need to give the index of each qubit to the push! function. As usual, first the control qubits, then the targets; check the specific documentation of each gate.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"circuit = Circuit() # hide\npush!(circuit, GateC3X(), 1, 2, 3, 4)","category":"page"},{"location":"manual/unitary_gates/#Generalized-gates","page":"Unitary Gates","title":"Generalized gates","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Some common gate combinations are available as generalized gates: PauliString, QFT, PhaseGradient, Diffusion, PolynomialOracle.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Generalized gates can be applied to a variable number of qubits. It is highly recommended to check their docstrings to understand their usage ?QFT.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Here is an example of use:","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"circuit = Circuit() # hide\npush!(circuit, PhaseGradient(10), 1:10...)","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"These gates target a variable number of gates, so you have to specify in the constructor how many target qubits will be used, and give to the push! function one index per target qubit.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"More about generalized gates on special operations.","category":"page"},{"location":"manual/unitary_gates/#Custom-Gates","page":"Unitary Gates","title":"Custom Gates","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"If you need to use a specific unitary gate that is not provided by MIMIQ, you can use GateCustom to create your own unitary gate.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"note: Note\nOnly one qubit or two qubits gates can be created using MIMIQ's GateCustom.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"note: Note\nAvoid using GateCustom if you can define the same gate using a pre-defined gate from MIMIQ's library, as it could impact negatively peformance.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"To create a custom unitary gate you first have to define the matrix of your gate in Julia:","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"# define the matrix for a 2 qubits gate\ncustom_matrix = [exp(im*pi/3) 0 0 0; 0 exp(im*pi/5) 0 0; 0 0 exp(im*pi/7) 0; 0 0 0 exp(im*pi/11)]","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Then you can create your unitary gate and use it like any other gate using push!","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"circuit = Circuit() # hide\n# creates the custom gate\ncustom_gate = GateCustom(custom_matrix)\n# Add the gate to the circuit \npush!(circuit, custom_gate, 1, 2)","category":"page"},{"location":"manual/unitary_gates/#Composition:-Control,-Power,-Inverse,-Parallel","page":"Unitary Gates","title":"Composition: Control, Power, Inverse, Parallel","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Gates in MIMIQ can be combined to create more complex gates using Control, Power, Inverse, Parallel.","category":"page"},{"location":"manual/unitary_gates/#Control","page":"Unitary Gates","title":"Control","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"A controlled version of every gate can be built using the control function.   For example, CX can be built with the following instruction:","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"CX = control(1, GateX())","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"The first argument indicates the number of control qubits and is completely up to the user. For example a CCCCCX can be built with the following instruction:","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"CCCCCX = control(5, GateX())","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"details: Details\nA wrapper for GateCX is already provided by MIMIQ. Whenever possible, it is recommended to use the gates already provided by the framework instead of creating your own composite gate to prevent performances loss.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Be careful when adding the new control gate to your circuit. When using the push! function, the first expected indices should be the control qubits specified in Control and the last indices the target qubits of the gate, for instance:","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"circuit = Circuit() # hide\n# here the first 5 indices are the control qubit and the last index is the target qubit of X.\npush!(circuit, CCCCCX, 1, 2, 3, 4, 5, 6)","category":"page"},{"location":"manual/unitary_gates/#Power","page":"Unitary Gates","title":"Power","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"To raise the power of a gate you can use the power function. For example, sqrtmathrmGateS = mathrmGateT, therefore, the following instruction can be used to generate the GateS:","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"power(GateS(), 1//2)","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"details: Details\nThe power method will attempt to realize simplifications whenever it can, for example asking for the square of GateX will directly give you GateID.","category":"page"},{"location":"manual/unitary_gates/#Inverse","page":"Unitary Gates","title":"Inverse","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"To get the inverse of an operator you can use the inverse method. Remember that the inverse of a unitary matrix is the same as the adjoint (conjugate transpose), so this is a simple way to get the adjoint of a gate. For example here is how to get the inverse of a GateH","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"inv_H = inverse(GateH())","category":"page"},{"location":"manual/unitary_gates/#Parallel","page":"Unitary Gates","title":"Parallel","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"To create a composite gate applying a specific gate to multiple qubits at once you can use the parallel method.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"circuit = Circuit() # hide\nX_gate_4 = parallel(4, GateX())\n\npush!(circuit, X_gate_4, 1, 2, 3, 4)\n\ndraw(circuit)","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"To check the number of repetition of your custom parallel gate you can use the numrepeats method:","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"numrepeats(X_gate_4)","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Be careful when using a multi-qubit gate with parallel as the index of the targeted qubits in push! can become confusing. for example see below the parallel applicatoin of a CX gate:","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"circuit = Circuit() # hide\ndouble_CX = Parallel(2, GateCX())\npush!(circuit, double_CX, 1, 2, 3, 4)\ndraw(circuit)","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Here the index 1 and 2 correspond to the control and target of the first CX gate and 3 and 4 correspond to the second CX gate.","category":"page"},{"location":"manual/unitary_gates/#Extract-information-of-unitary-gates","page":"Unitary Gates","title":"Extract information of unitary gates","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"MIMIQ priovides a few methods to extract information about the unitary gates.","category":"page"},{"location":"manual/unitary_gates/#Matrix","page":"Unitary Gates","title":"Matrix","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"To get the matrix of a unitary gate you can use the matrix:","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"matrix(GateCX())","category":"page"},{"location":"manual/unitary_gates/#Number-of-targets","page":"Unitary Gates","title":"Number of targets","text":"","category":"section"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"Another way to know how many qubits, bits or z-variables are targeted by one unitary gate you can use numqubits, numbits and numzvars, respectively.","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"numqubits(GateCX()), numbits(GateCX()), numzvars(GateCX())","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"numqubits(Measure()), numbits(Measure()), numzvars(Measure())","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"numqubits(Amplitude(bs\"01\")), numbits(Amplitude(bs\"01\")), numzvars(Amplitude(bs\"01\"))","category":"page"},{"location":"manual/unitary_gates/","page":"Unitary Gates","title":"Unitary Gates","text":"See non-unitary operations and statistical operations pages for more information on Measure and Amplitude.","category":"page"},{"location":"library/mimiqlink/#Connections-to-MIMIQ","page":"MimiqLink","title":"Connections to MIMIQ","text":"","category":"section"},{"location":"library/mimiqlink/","page":"MimiqLink","title":"MimiqLink","text":"Modules = [MimiqLink]\nPrivate = false","category":"page"},{"location":"library/mimiqlink/#MimiqLink.MimiqLink","page":"MimiqLink","title":"MimiqLink.MimiqLink","text":"module MimiqLink end\n\nThis module contains convenience tools to establish and keep up a connection to the QPerfect MIMIQ services, both remote or on premises.\n\nIt allows for three different connection modes: via login page, via token, via credentials.\n\nLogin Page\n\nThis method will open a browser pointing to a login page. The user will be asked to insert username/email and password.\n\njulia> using MimiqLink\n\njulia> connection = MimiqLink.connect()\n\noptionally an address for the MIMIQ services can be specified\n\njulia> connection = MimiqLink.connect(url = \"http://127.0.0.1/api\")\n\nToken\n\nThis method will allow the user to save a token file (by login via a login page), and then load it also from another julia session.\n\njulia> using MimiqLink\n\njulia> MimiqLink.savetoken(url = \"http://127.0.0.1/api\")\n\nthis will save a token in the qperfect.json file in the current directory. In another julia session is then possible to do:\n\njulia> using MimiqLink\n\njulia> connection = MimiqLink.loadtoken(\"path/to/my/qperfect.json\")\n\nCredentials\n\nThis method will allow users to access by directly use their own credentials.\n\nwarning: Warning\nIt is strongly discuraged to use this method. If files with credentials will be shared the access to the qperfect account might be compromised.\n\njulia> using MimiqLink\n\njulia> connection = MimiqLink.connect(\"me@mymail.com\", \"myweakpassword\")\n\njulia> MimiqLink.connect(\"me@mymail.com\", \"myweakpassword\"; url = \"http://127.0.0.1/api\")\n\n\n\n\n\n","category":"module"},{"location":"library/mimiqlink/#MimiqLink.QPERFECT_CLOUD","page":"MimiqLink","title":"MimiqLink.QPERFECT_CLOUD","text":"const QPERFECT_CLOUD\n\nAddress for the QPerfect Cloud services\n\n\n\n\n\n","category":"constant"},{"location":"library/mimiqlink/#MimiqLink.QPERFECT_CLOUD2","page":"MimiqLink","title":"MimiqLink.QPERFECT_CLOUD2","text":"const QPERFECT_CLOUD2\n\nAddressfor secondary QPerfect Cloud services\n\n\n\n\n\n","category":"constant"},{"location":"library/mimiqlink/#MimiqLink.connect","page":"MimiqLink","title":"MimiqLink.connect","text":"connect([; url=QPREFECT_CLOUD])\nconnect(token[; url=QPREFECT_CLOUD])\nconnect(username, password[; url=QPREFECT_CLOUD])\n\nEstablish a connection to the MIMIQ Services.\n\nA refresh process will be spawned in the background to refresh the access credentials. An active connection can be closed by using the close(connection) method. As an example:\n\nconnection = connect(\"john.doe@example.com\", \"johnspassword\")\nclose(connection)\n\nwarning: Warning\nThe first method will open a login page in the default browser and ask for your email and password. This method is encouraged, as it will avoid saving your password as plain text in your scripts or notebooks.\n\nThere are two main servers for the MIMIQ Services: the main one and a secondary one. Users are supposed to use the main one.\n\njulia> QPERFECT_CLOUD\nURI(\"https://mimiq.qperfect.io/api\")\n\njulia> QPERFECT_CLOUD2\nURI(\"https://mimiqfast.qperfect.io/api\")\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqlink/#MimiqLink.isjobcanceled-Tuple{Connection, Execution}","page":"MimiqLink","title":"MimiqLink.isjobcanceled","text":"isjobcanceled(conn, execution)\n\nCheck if a job has been canceled.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqlink/#MimiqLink.isjobdone-Tuple{Connection, Execution}","page":"MimiqLink","title":"MimiqLink.isjobdone","text":"isjobdone(conn, execution)\n\nCheck if a job is done.\n\nWill return true if the job finished successfully or with an error and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqlink/#MimiqLink.isjobfailed-Tuple{Connection, Execution}","page":"MimiqLink","title":"MimiqLink.isjobfailed","text":"isjobfailed(conn, execution)\n\nCheck if a job failed.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqlink/#MimiqLink.isjobstarted-Tuple{Connection, Execution}","page":"MimiqLink","title":"MimiqLink.isjobstarted","text":"isjobstarted(conn, execution)\n\nCheck if a job has started executing.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqlink/#MimiqLink.loadtoken","page":"MimiqLink","title":"MimiqLink.loadtoken","text":"loadtoken([filename])\n\nEstablish a connection to the MIMIQ Services by loading the credentials from a JSON file.\n\nArguments\n\nfilename: file where to load the credentials (default: qperfect.json)\n\nnote: Note\n\n\nThe credentials are usually valid only for a small amount of time, so you may need to regenerate them from time to time.\n\nExamples\n\njulia> savetoken(\"myqperfectcredentials.json\")\n\njulia> connection = loadtoken(\"myqperfectcredentials.json\")\n\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqlink/#MimiqLink.requestinfo-Tuple{Connection, Execution}","page":"MimiqLink","title":"MimiqLink.requestinfo","text":"requestinfo(conn, req)\n\nRetrieve information about an execution request.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqlink/#MimiqLink.savetoken","page":"MimiqLink","title":"MimiqLink.savetoken","text":"savetoken([filename][; url=QPERFECT_CLOUD)\n\nEstablish a connection to the MIMIQ Services and save the credentials in a JSON file.\n\nArguments\n\nfilename: file where to save the credentials (default: qperfect.json)\n\nKeyword arguments\n\nurl: the uri of the MIMIQ Services (default: QPERFECT_CLOUD value)\n\nExamples\n\njulia> savetoken(\"myqperfectcredentials.json\")\n\njulia> connection = loadtoken(\"myqperfectcredentials.json\")\n\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/generalized/#Generalized-gates","page":"Generalized gates","title":"Generalized gates","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/generalized/","page":"Generalized gates","title":"Generalized gates","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\n    \"operations/gphase.jl\",\n    \"operations/generalized/qft.jl\",\n    \"operations/generalized/phasegradient.jl\",\n    \"operations/generalized/polynomialoracle.jl\",\n    \"operations/generalized/diffusion.jl\",\n]","category":"page"},{"location":"library/mimiqcircuitsbase/generalized/#MimiqCircuitsBase.QFT","page":"Generalized gates","title":"MimiqCircuitsBase.QFT","text":"QFT(n)\n\nQuantum Fourier transform.\n\nPerforms the quantum Fourier transform on a register of n qubits.\n\nThe inverse quantum Fourier transform is simply given inverse(qft).\n\nIt implements the unitary transformation.\n\nfrac12^n2 sum_x=0^2^n-1 sum_y=0^2^n-1 e^2pi i fracxy2^n ketybrax\n\nExamples\n\njulia> c = push!(Circuit(), QFT(10), 1:10...)\n10-qubit circuit with 1 instructions:\n└── QFT @ q[1:10]\n\njulia> push!(c, inverse(QFT(10)), 1:10...)\n10-qubit circuit with 2 instructions:\n├── QFT @ q[1:10]\n└── QFT† @ q[1:10]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/generalized/#MimiqCircuitsBase.PhaseGradient","page":"Generalized gates","title":"MimiqCircuitsBase.PhaseGradient","text":"PhaseGradient(n)\n\nA phase gradient gate applies a phase shift to a quantum register of n qubits, where each computational basis state ketk experiences a phase proportional to its integer value k:\n\noperatornamePhaseGradient =\nsumk=0^n-1 mathrme^i frac2 piN k ketkbrak\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/generalized/#MimiqCircuitsBase.PolynomialOracle","page":"Generalized gates","title":"MimiqCircuitsBase.PolynomialOracle","text":"PolynomialOracle(xregsize, yregsize, a, b, c, d)\nPolynomialOracle(a, b, c, d) # lazy\n\nQuantum oracle for a polynomial function of two registers.\n\nApplies a pi phase shift to any basis state which satifies a xy + bx + cy + d == 0, where ketx and kety are the states of the two registers.\n\nExamples\n\njulia> c = push!(Circuit(), PolynomialOracle(5,5,1,2,3,4), 1:10...)\n10-qubit circuit with 1 instructions:\n└── PolynomialOracle(1,2,3,4) @ q[1:5], q[6:10]\n\njulia> push!(c, inverse(PolynomialOracle(5,5,1,2,3,4)), 1:10...)\n10-qubit circuit with 2 instructions:\n├── PolynomialOracle(1,2,3,4) @ q[1:5], q[6:10]\n└── PolynomialOracle(1,2,3,4) @ q[1:5], q[6:10]\n\nwarn: Warn\nThis operation is not yet implemented for decomposition. Might not work with some backends, where is not specifically implemented.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/generalized/#MimiqCircuitsBase.Diffusion","page":"Generalized gates","title":"MimiqCircuitsBase.Diffusion","text":"Diffusion(n)\nDiffusion() # lazy\n\nGrover's diffusion operator.\n\nIt implements the unitary transformation.\n\nH^otimes n (1-2ket0^nbra0^n) H^otimes n\n\nExamples\n\njulia> c = push!(Circuit(), Diffusion(10), 1:10...)\n10-qubit circuit with 1 instructions:\n└── Diffusion @ q[1:10]\n\njulia> push!(c, inverse(Diffusion(10)), 1:10...)\n10-qubit circuit with 2 instructions:\n├── Diffusion @ q[1:10]\n└── Diffusion† @ q[1:10]\n\njulia> decompose(Diffusion(4))\n4-qubit circuit with 9 instructions:\n├── RY(π/2) @ q[1]\n├── RY(π/2) @ q[2]\n├── RY(π/2) @ q[3]\n├── RY(π/2) @ q[4]\n├── C₃Z @ q[1:3], q[4]\n├── RY(π/2) @ q[1]\n├── RY(π/2) @ q[2]\n├── RY(π/2) @ q[3]\n└── RY(π/2) @ q[4]\n\n\n\n\n\n\n","category":"type"},{"location":"manual/statistical_ops/#Statistical-Operations","page":"Statistical Operations","title":"Statistical Operations","text":"","category":"section"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"Statistical operations are simulator specific mathematical operations allowing you to compute properties of the simulated quantum state without making it collapse. All statistical operations will result in a real or complex number that will be stored in the Z-Register, and can be accessed from the results of the simulation through the zstates option, see circuits and cloud execution page.","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"On this page you will find all statistical operations available on MIMIQ with explanations and examples.","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"Statistical Operations\nExpectation value\nMathematical definition\nUsage on MIMIQ\nEntanglement\nVon Neumann Entropy\nMathematical definition\nUsage on MIMIQ\nBond Dimension\nMathematical definition\nUsage on MIMIQ\nSchmidt Rank\nMathematical definition\nUsage on MIMIQ\nAmplitude","category":"page"},{"location":"manual/statistical_ops/#Expectation-value","page":"Statistical Operations","title":"Expectation value","text":"","category":"section"},{"location":"manual/statistical_ops/#Mathematical-definition","page":"Statistical Operations","title":"Mathematical definition","text":"","category":"section"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"An expectation value for a pure state  psi rangle is defined as","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"langle O rangle = langle psi  O  psi rangle","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"where O is an operator. With respect to a density matrix rho it's given by","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"langle O rangle = mathrmTr(rho O)","category":"page"},{"location":"manual/statistical_ops/#Usage-on-MIMIQ","page":"Statistical Operations","title":"Usage on MIMIQ","text":"","category":"section"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"First we need to define the operator O of which we will compute the expectation value","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"using MimiqCircuits # hide\nop = SigmaPlus()","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"SigmaPlus is only one of the many operators available. Of course, every gate can be used as an operator, for example op = GateZ(). However, MIMIQ also supports many non-unitary operators such as SigmaPlus, more about this on the operators page.","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"To ask MIMIQ to compute the expectation value for a circuit you can create an ExpectationValue object and push! it to the circuit like this:","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"circuit = Circuit() # hide\npush!(circuit, GateH(), 1)\n\n# Ask to compute the expectation value\nev = ExpectationValue(op)\npush!(circuit, ev, 1, 1)","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"As for all statistical operations, the arguments to give to the push! function always follow the order of quantum register index first, classical register second (none in this case), and Z-register index last. In the example above, the first 1 is the index for the first qubit of the quantum register and the second 1 is the index of the Z-Register.","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"Notice that the expectation value will be computed with respect to the quantum state of the system at the point in the circuit where the ExpectationValue is added.","category":"page"},{"location":"manual/statistical_ops/#Entanglement","page":"Statistical Operations","title":"Entanglement","text":"","category":"section"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"MIMIQ supports statistical operations on entanglement for ordered bipartitions. For instance, for qubits 1N MIMIQ can compute the entanglement between the bipartitions 1k-1 and kN. ","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"For this reason when you push! an entanglement operation to a circuit, you need to give it the qubit index k that separates the two bipartitions, as well as the Z-register to store the result.","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"warning: Warning\nThe following functions can only be used with the MPS backend.","category":"page"},{"location":"manual/statistical_ops/#Von-Neumann-Entropy","page":"Statistical Operations","title":"Von Neumann Entropy","text":"","category":"section"},{"location":"manual/statistical_ops/#Mathematical-definition-2","page":"Statistical Operations","title":"Mathematical definition","text":"","category":"section"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"The entanglement entropy for a bipartition into subsystems A and B is defined for a pure state rho =  psi ranglelangle psi | as","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"  mathcalS(rho_A) = - mathrmTr(rho_A log_2 rho_A) \n= - mathrmTr(rho_B log_2 rho_B)\n= mathcalS(rho_B)","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"where rho_A = mathrmTr_B(rho) is the reduced density matrix. A product state has mathcalS(rho_A)=0 and a maximally entangled state between A and B gives mathcalS(rho_A)=1.","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"We only consider bipartitions where A=1ldotsk-1 and B=kldotsN, for some k and where N is the total number of qubits.","category":"page"},{"location":"manual/statistical_ops/#Usage-on-MIMIQ-2","page":"Statistical Operations","title":"Usage on MIMIQ","text":"","category":"section"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"The entanglement entropy for a bipartition into subsystems A and B can be obtained using the VonNeumannEntropy function. You do not need to provide any argument to VonNeumannEntropy. To indicate where to create the separation into two subsystems MIMIQ will use the first qubit index given to the push! function, here is an example:","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"circuit = Circuit() # hide\n# Asking to compute the Von Neumann entropy between the two subsystems separated between qubit 2 and 3\npush!(circuit, VonNeumannEntropy(), 3, 1)","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"Here we compute the Von neumann entropy between the two subsystems 12 and 3N and write the results into the index 1 of the Z-register.","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"note: Note\nFor k=1, A is empty and the Von Neumann entropy will always return 1.","category":"page"},{"location":"manual/statistical_ops/#Bond-Dimension","page":"Statistical Operations","title":"Bond Dimension","text":"","category":"section"},{"location":"manual/statistical_ops/#Mathematical-definition-3","page":"Statistical Operations","title":"Mathematical definition","text":"","category":"section"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"The bond dimension is only defined for a matrix-product state (MPS), which can be written as (with i_1=i_N+1=1)","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"  psi rangle = sum_s_1s_2ldots=1^2\nsum_i_2^chi_2 sum_i_3^chi_3 ldots sum_i_N^chi_N\nA^(s_1)_i_1i_2 A^(s_2)_i_2 i_3 A^(s_3)_i_3 i_4 ldots\nA^(s_N)_i_Ni_N+1  s_1 s_2 s_3 ldots s_N rangle ","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"Here, chi_k is the bond dimension, i.e. the dimension of the index i_k. The first and last bond dimensions are dummies, chi_1=chi_N+1=1. A bond dimension of 1 means there is no entanglement between the two halves of the system.","category":"page"},{"location":"manual/statistical_ops/#Usage-on-MIMIQ-3","page":"Statistical Operations","title":"Usage on MIMIQ","text":"","category":"section"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"To compute the bond dimension between two halves of a system you can use the BondDim operator and push! to the circuit like any entanglement measure:","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"circuit = Circuit() # hide\n# Asking to compute the BondDim between the second and third qubits\npush!(circuit, BondDim(), 3, 1)","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"Here we compute the bond dimension between the two subsystems 12 and 3N and write the results into index 1 of the Z-Register.","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"note: Note\nFor k=1 the bond dimension returned will always be 1.","category":"page"},{"location":"manual/statistical_ops/#Schmidt-Rank","page":"Statistical Operations","title":"Schmidt Rank","text":"","category":"section"},{"location":"manual/statistical_ops/#Mathematical-definition-4","page":"Statistical Operations","title":"Mathematical definition","text":"","category":"section"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"A Schmidt decomposition for a bipartition into subsystems A and B is defined for a pure state as","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"psirangle = sum_i=1^r s_i alpha_irangle otimes beta_irangle","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"where alpha_irangle (beta_irangle) are orthonormal states acting on A (B). The Schmidt rank is the number of terms r in the sum. A product state gives r=1 and r1 signals entanglement.","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"We only consider bipartitions where A=1ldotsk-1 and B=kldotsN, for some k and where N is the total number of qubits.","category":"page"},{"location":"manual/statistical_ops/#Usage-on-MIMIQ-4","page":"Statistical Operations","title":"Usage on MIMIQ","text":"","category":"section"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"To compute the Schmidt rank of a bipartition you can use the SchmidtRank operator and push! like all entanglement measures:","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"circuit = Circuit() # hide\n# Asking to compute the Schmidt rank between the two subsystems separated between qubits 2 and 3\npush!(circuit, SchmidtRank(), 3, 1)","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"Here we compute the Schmidt rank between the two subsystems 12 and 3N and write the results into index 1 of the Z-Register.","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"note: Note\nFor k=1, A is empty and the Schmidt rank will always return 1.","category":"page"},{"location":"manual/statistical_ops/#Amplitude","page":"Statistical Operations","title":"Amplitude","text":"","category":"section"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"With MIMIQ you can extract quantum state amplitudes in the computational basis at any point in the circuit using Amplitude. You will need to give the Amplitude function the BitString matching the state for which you want the amplitude. For more information on BitStrings check the special topics documentation page.","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"You can add the Amplitude object to the circuit exactly like any other gate:","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"mystery_circuit = Circuit() # hide\npush!(mystery_circuit, GateH(), 1:3) # hide\n\n# Define the Amplitude operator\namp = Amplitude(BitString(\"101\"))\n\n# Add the amplitude operator to the circuit and write the result in the first complex number of the Z-Register\npush!(mystery_circuit, amp, 1)","category":"page"},{"location":"manual/statistical_ops/","page":"Statistical Operations","title":"Statistical Operations","text":"This will extract the amplitude of the basis state ket101. When adding the amplitude operation you do not need to give it any specific qubit target, the only index needed is for the Z-register to use for storing the result.","category":"page"},{"location":"library/mimiqcircuits/#Execution-utilities","page":"MimiqCircuits","title":"Execution utilities","text":"","category":"section"},{"location":"library/mimiqcircuits/","page":"MimiqCircuits","title":"MimiqCircuits","text":"Modules = [MimiqCircuits]\nPrivate = false","category":"page"},{"location":"library/mimiqcircuits/#MimiqCircuits.execute","page":"MimiqCircuits","title":"MimiqCircuits.execute","text":"execute(connection, circuit[; kwargs...])\nexecute(connection, circuits[; kwargs...])\n\nExecute a quantum circuit on the MIMIQ remote services.\n\nThe circuit is applied to the zero state and the resulting state is measured via sampling. Optionally amplitudes corresponding to few selected bit states (or bitstrings) can be returned from the computation.\n\nKeyword Arguments\n\nlabel::String: mnemonic name to give to the simulation, will be visible on the web interface\nalgorithm: algorithm to use by the compuation. By default \"auto\" will select the fastest algorithm between \"statevector\" or \"mps\".\nnsamples::Integer: number of times to sample the circuit (default: 1000, maximum: 2^16)\nbitstrings::Vector{BitString}: list of bit states to compute the amplitudes for (default: BitString[])\ntimelimit: number of minutes before the computation is stopped (default: maximum allowed or 30 minutes)\nbonddim::Int: bond dimension for the MPS algorithm (default: 256, maximum: 4096)\nentdim::Int: parameter to control pre compression of the circuit. Higher value makes simulations slower. (default: 16, minimum:4, maximum: 64)\nseed::Int: a seed for running the simulation (default: random seed)\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuits/#MimiqCircuits.getinput-Tuple{Connection, Execution}","page":"MimiqCircuits","title":"MimiqCircuits.getinput","text":"getinput(connection, execution)\n\nReturns the first circuit and parameters for the given execution.\n\nSee also getinputs, getresults, getresult.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuits/#MimiqCircuits.getinputs-Tuple{Connection, Execution}","page":"MimiqCircuits","title":"MimiqCircuits.getinputs","text":"getinputs(connection, execution)\n\nReturns the circuits and parameters for the given execution.\n\nSee also getinput, getresults, getresult.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuits/#MimiqCircuits.getresult-Tuple{Connection, Execution}","page":"MimiqCircuits","title":"MimiqCircuits.getresult","text":"getresult(connection, execution)\n\nReturns the first circuit and parameters for the given execution.\n\nSee also getinputs, getinput, getresults.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuits/#MimiqCircuits.getresults-Tuple{Connection, Execution}","page":"MimiqCircuits","title":"MimiqCircuits.getresults","text":"getresults(connection, execution[; interval=1])\n\nBlock until the given execution is finished and return the results.\n\nKeyword Arguments\n\ninterval: time interval in seconds to check for job completion (default: 1)\n\nSee also getinputs, getinput, getresult.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuits/#MimiqCircuits.loadresults-Tuple{AbstractString}","page":"MimiqCircuits","title":"MimiqCircuits.loadresults","text":"loadresults(file)\n\nLoad results from a given file.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuits/#MimiqCircuits.saveresults-Tuple{AbstractString, QCSResults}","page":"MimiqCircuits","title":"MimiqCircuits.saveresults","text":"saveresults(file, results)\n\nSave results to a given file.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/circuits/#Quantum-Circuits-and-Instructions","page":"Quantum Circuits and Instructions","title":"Quantum Circuits and Instructions","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/circuits/","page":"Quantum Circuits and Instructions","title":"Quantum Circuits and Instructions","text":"Modules = [MimiqCircuitsBase, Base]\nPrivate = false\nPages   = [\n    \"instruction.jl\",\n    \"circuit.jl\",\n    \"circuit_extras.jl\",\n    \"circuit_macro.jl\",\n    \"circuit/push.jl\",\n    \"circuit/insert.jl\",\n    \"circuit/emplace.jl\",\n    \"circuit/draw.jl\",\n]","category":"page"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.AbstractInstruction","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.AbstractInstruction","text":"AbstractInstruction\n\nAbstract super type for all the instrcutions.\n\nAn instruction applies one or more operations to a set of qubits and classical bits.\n\nMethods\n\ngetqubit, getqubits, getbits, getbit inverse, opname, numqubits, numbits\n\nSee also\n\nInstruction, Operation\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.Instruction","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.Instruction","text":"Instruction(op, qtargets, ctargets) <: AbstractInstruction\n\nRepresentation of an operation applied to specific qubit and bit targets.\n\nExample\n\njulia> Instruction(GateX(), (1,), (), ())\nX @ q[1]\n\njulia> Instruction(GateCX(), (1,2), (), ())\nCX @ q[1], q[2]\n\njulia> Instruction(Measure(), (3,), (3,), ())\nM @ q[3], c[3]\n\n\nSee also\n\nAbstractInstruction, Operation\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.Instruction-Union{Tuple{K}, Tuple{L}, Tuple{M}, Tuple{N}, Tuple{Operation{N, M, L}, Vararg{Int64, K}}} where {N, M, L, K}","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.Instruction","text":"Instruction(op, targets...)\n\nConstructors an instruction from an operation and a list of targets.\n\nBy convention, if op is an N-qubit and M-bit operations, then the first N targets are used as qubits and the last M as bits.\n\nExamples\n\njulia> Instruction(GateX(), 1)\nX @ q[1]\n\njulia> Instruction(GateCX(), 1,2)\nCX @ q[1], q[2]\n\njulia> Instruction(Measure(), 3, 3)\nM @ q[3], c[3]\n\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.getbit","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.getbit","text":"getbit(instruction, i)\n\ni-th target classical bit of an instruction.\n\nExamples\n\njulia> inst = Instruction(Measure(), 1, 3)\nM @ q[1], c[3]\n\njulia> getbit(inst, 1)\n3\n\n\nSee also\n\ngetbits, getqubit, getqubits,\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.getbits","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.getbits","text":"getbits(instruction)\n\nTuple of the classical bits which the instruction is applied to.\n\nExamples\n\njulia> inst = Instruction(Measure(), 1, 3)\nM @ q[1], c[3]\n\njulia> getbits(inst)\n(3,)\n\n\nSee also\n\ngetbit, getqubits, getqubit\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.getqubit","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.getqubit","text":"getqubit(instruction, i)\n\ni-th target qubit of an instruction.\n\nExamples\n\njulia> inst = Instruction(GateCX(), 1, 3)\nCX @ q[1], q[3]\n\njulia> getqubit(inst, 2)\n3\n\n\nSee also\n\ngetqubits, getbit, getbits\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.getqubits","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.getqubits","text":"getqubits(instruction)\n\nTuple of quantum bits which the instruction is applied to.\n\njulia> inst = Instruction(GateCX(), 1, 3)\nCX @ q[1], q[3]\n\njulia> getqubits(inst)\n(1, 3)\n\n\nSee also\n\ngetqubit, getbits, getbit\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.getztarget","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.getztarget","text":"getztarget(instruction)\n\nTuple of the classical bits which the instruction is applied to.\n\nExamples\n\njulia> inst = Instruction(ExpectationValue(pauli\"ZZ\"), 1, 2, 1)\n⟨ZZ⟩ @ q[1:2], z[1]\n\njulia> getztarget(inst,1)\n1\n\n\nSee also\n\ngetbit, getqubit, getbit\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.Circuit","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.Circuit","text":"Circuit([instructions])\n\nRepresentation of a quantum circuit as a vector of instructions applied to the qubits.\n\nThe circuit can be initialized with an optional vector of instructions.\n\nSee OPERATIONS, GATES, or GENERALIZED for the list of operations to add to circuits.\n\nExamples\n\nOperation can be added one by one to a circuit with the push!(circuit, operation, targets...) function\n\njulia> c = Circuit()\nempty circuit\n\n\njulia> push!(c, GateH(), 1)\n1-qubit circuit with 1 instructions:\n└── H @ q[1]\n\njulia> push!(c, GateCX(), 1, 2)\n2-qubit circuit with 2 instructions:\n├── H @ q[1]\n└── CX @ q[1], q[2]\n\njulia> push!(c, GateRX(π / 4), 1)\n2-qubit circuit with 3 instructions:\n├── H @ q[1]\n├── CX @ q[1], q[2]\n└── RX(π/4) @ q[1]\n\njulia> push!(c, Barrier(2), 1, 3)\n3-qubit circuit with 4 instructions:\n├── H @ q[1]\n├── CX @ q[1], q[2]\n├── RX(π/4) @ q[1]\n└── Barrier @ q[1,3]\n\njulia> push!(c, Measure(), 1, 1)\n3-qubit circuit with 5 instructions:\n├── H @ q[1]\n├── CX @ q[1], q[2]\n├── RX(π/4) @ q[1]\n├── Barrier @ q[1,3]\n└── M @ q[1], c[1]\n\n\nTargets are not restricted to be single values, but also vectors. In this case a single push! will add multiple operations.\n\njulia> push!(Circuit(), GateCCX(), 1, 2:4, 4:10)\n6-qubit circuit with 3 instructions:\n├── C₂X @ q[1:2], q[4]\n├── C₂X @ q[1,3], q[5]\n└── C₂X @ q[1,4], q[6]\n\nis equivalent to\n\nfor (i, j) in zip(2:4, 4:10)\n    push!(c, GateCX(), 1, i)\nend\n\nNotice how the range 4:10 is not fully used, since 2:4 is shorter.\n\nDisplay\n\nTo display a a LaTeX representation of the circuit, we can just use Quantikz.jl\n\nusing Quantikz\nc = Circuit()\n...\ndisplaycircuit(c)\n\nor\n\nsavecircuit(c, \"circuit.pdf\")\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.numbits-Tuple{Circuit}","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.numbits","text":"numbits(insts::Vector{<:Instruction})\nnumbits(c::Circuit) -> Int\n\nCompute the highest index of c-targets in the given circuit.\n\nExamples\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, Measure(), 1:2, 1:2)\n2-qubit circuit with 2 instructions:\n├── M @ q[1], c[1]\n└── M @ q[2], c[2]\n\njulia> numbits(c)\n2\n\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.numqubits-Tuple{Vector{<:Instruction}}","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.numqubits","text":"numqubits(insts::Vector{<:Instruction})\nnumqubits(c::Circuit) -> Int\n\nCompute the highest index of q-targets in the given vector of instructions or circuit.\n\nExamples\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, Measure(), 1:2, 1:2)\n2-qubit circuit with 2 instructions:\n├── M @ q[1], c[1]\n└── M @ q[2], c[2]\n\njulia> numqubits(c)\n2\n\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.numzvars-Tuple{Vector{<:Instruction}}","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.numzvars","text":"numzvars(insts::Vector{<:Instruction})\nnumzvars(c::Circuit) -> Int\n\nCompute the highest index of z-targets in the given circuit.\n\nExamples\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, Amplitude(bs\"01\"), 1:2)\n0-qubit circuit with 2 instructions:\n├── Amplitude(bs\"01\") @ z[1]\n└── Amplitude(bs\"01\") @ z[2]\n\njulia> numzvars(c)\n2\n\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.depth-Tuple{Circuit}","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.depth","text":"depth(circuit)\n\nCompute the depth of a quantum circuit.\n\nThe depth of a quantum circuit is a metric computing the maximum time (in units of quantum gates application) between the input and output of the circuit.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.emplace!","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.emplace!","text":"emplace!(circuit, operation, registers...)\n\nEmplace an operation at the end of a circuit and applies it to the given registers.\n\njulia> emplace!(Circuit(), control(3, GateSWAP()), [1,2,3], [4,5])\n5-qubit circuit with 1 instructions:\n└── C₃SWAP @ q[1:3], q[4:5]\n\njulia> QFT()\nlazy QFT(?)\n\njulia> emplace!(Circuit(), QFT(), [1,2,3])\n3-qubit circuit with 1 instructions:\n└── QFT @ q[1:3]\n\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/circuits/#MimiqCircuitsBase.draw","page":"Quantum Circuits and Instructions","title":"MimiqCircuitsBase.draw","text":"draw(circuit)\n\nDraw an ascii representation of a circuit.\n\nNOTE it automatically detects the screen width and will split the circuit if it is too wide.\n\n\n\n\n\n","category":"function"},{"location":"quick_start/#Quick-Start","page":"Quick start","title":"Quick Start","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"In this tutorial, we will walk you through the fundamental procedures for simulating a quantum circuit using MIMIQ. Throughout the tutorial, we will provide links to detailed documentation and examples that can provide a deeper understanding of each topic.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Quick Start\nInstall and load MIMIQ\nConnect to remote service\nExample: Simulate a GHZ circuit\nConstruct basic circuit\nMeasure, add noise, and extract information\nExecute circuit\nOpenQASM and Stim","category":"page"},{"location":"quick_start/#Install-and-load-MIMIQ","page":"Quick start","title":"Install and load MIMIQ","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To install MIMIQ, please open Julia's interactive session (REPL), then press the ] to start using the package manager mode, then type the following commands.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"If it is the first time opening julia update the list of packages","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"update","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Then add QPerfect's registry of Julia packages:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"registry add https://github.com/qperfect-io/QPerfectRegistry.git","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To install MimiqCircuits, to its last stable release,","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"add MimiqCircuits","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Check the installation page for more details.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"In order to use MIMIQ, we simply need to load the MimiqCircuit Julia module within your workspace like this:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using MimiqCircuits","category":"page"},{"location":"quick_start/#Connect-to-remote-service","page":"Quick start","title":"Connect to remote service","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To execute circuits you have to connect to MIMIQ's remote service, which can be achieved with a single instruction","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"conn = connect()","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using MimiqCircuits # hide\nconn = connect(ENV[\"MIMIQUSER\"], ENV[\"MIMIQPASS\"]; url=QPERFECT_CLOUD2) # hide","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For more details see cloud execution page or see the documentation of connect. If executed without supplemental arguments, connect() will start a local webpage and will try to open it with your default browser. As an alternative, connect(\"john.smith@example.com\", \"jonspassword\") allows to insert directly the username and password of the user.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"note: Note\nIn order to complete this step you need an active subscription to MIMIQ. To obtain one, please contact us or, if your organization already has a subscription, contact the organization account holder.","category":"page"},{"location":"quick_start/#Example:-Simulate-a-GHZ-circuit","page":"Quick start","title":"Example: Simulate a GHZ circuit","text":"","category":"section"},{"location":"quick_start/#Construct-basic-circuit","page":"Quick start","title":"Construct basic circuit","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"A circuit is basically a sequence of quantum operations (gates, measurements, etc...) that act on a set of qubits and potentially store information in a classical or \"z\" register (see circuit page). The classical register is a boolean vector to store the results of measurements, and the z register is a complex vector to store the result of mathematical calculations like expectation values.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"The MIMIQ interface is similar to other software, but there are some important differences:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"There are no hardcoded quantum registers. Qubits are simply indicated by an integer index starting at 1 (Julia convention). The same for classical and z registers.\nA Circuit object doesn't have a fixed number of qubits. The number of qubits in a circuit is taken from looking at the qubits the gates are applied to. It is the maximum integer index used in a circuit. The same for the number of classical bits.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To construct a GHZ circuit, we start by defining an empty Circuit","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using MimiqCircuits # hide\ncircuit = Circuit()","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"The most important tool to build circuits is the push! function. It is used like this: push!(circuit, quantum_operation, targets...). It accepts a circuit, a single quantum operation, and a series of targets, one for every qubit or bit the operation supports.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"We apply a GateH on the first qubit as","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"push!(circuit, GateH(), 1)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"The text representation H @ q[1] informs us that there is an instruction which applies the Hadamard gate to the qubit with index 1. Note that qubits start by default in the state 0.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Multiple gates can be added at once through the same push! syntax using iterables, see circuit and unitary gates page for more information. To prepare a 5-qubit GHZ state, we add 9 CX or control-X gates between the qubit 1 and all the qubits from 2 to 5.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"push!(circuit, GateCX(), 1, 2:5)","category":"page"},{"location":"quick_start/#Measure,-add-noise,-and-extract-information","page":"Quick start","title":"Measure, add noise, and extract information","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"We can extract information about the state of the system (without affecting the state) at any point in the circuit, see statistical operations page. For example, we can compute the expectation value of  11 ranglelangle 11  of qubits 1 and 5, and store it in the first z register as:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"push!(circuit, ExpectationValue(Projector11()), 1, 5, 1)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"We can measure the qubits and add other non-unitary operations at any point in the circuit, for example:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"push!(circuit, Measure(), 1:5, 1:5)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Here, we measure qubits 1 to 5 and store the result in classical register 1 to 5. In general, the ordering of targets is always like push!(circ, op, quantum_targets..., classical_targets..., z_targets...).","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"warning: Warning\nClassical and z registers can be overwritten. If you do push!(circuit, Measure(), 1, 1) followed by push!(circuit, Measure(), 2, 1), the second measurement will overwrite the first one since it will be stored on the same classical register 1. To avoid this in a circuit with many measurements you can, for example, keep track of the index of the last used register.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To simulate imperfect quantum computers we can add noise to the circuit. Noise operations can be added just like any other operations using push!. However, noise can also be added after the circuit has been built to all gates of a certain type using add_noise!. For example:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"add_noise!(circuit, GateH(), AmplitudeDamping(0.01))\nadd_noise!(circuit, GateCX(), Depolarizing2(0.1); parallel=true)\nadd_noise!(circuit, Measure(), PauliX(0.05); before=true, parallel=true)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"See symbolic operations and special operations pages for other supported operations.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"The number of qubits, classical bits, and complex z-values of a circuit can be obtained from:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"numqubits(circuit), numbits(circuit), numzvars(circuit)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"A circuit behaves in many ways like a vector (of instructions, i.e. operations + targets). You can get the length as length(circuit), access elements as circuit[2], insert elements with insert!, append other circuits with append! etc. You can also visualize circuits with draw. See circuit page for more information.","category":"page"},{"location":"quick_start/#Execute-circuit","page":"Quick start","title":"Execute circuit","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Executing a circuit on MIMIQ requires three steps:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"opening a connection to the MIMIQ Remote Services (which we did at the beginning of the tutorial),\nsend a circuit for execution,\nretrieve the results of the execution.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"After a connection has been established, an execution can be sent to the remote services using execute.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"job = execute(conn, circuit)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"This will execute a simulation of the given circuit with default parameters. The default choice of algorithm is \"auto\".  Generally, there are three available options:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"\"auto\" for the automatically selecting the best algorithm according to circuit size and complexity,\n\"statevector\" for a highly optimized state vector engine, and\n\"mps\" for the large-scale Matrix Product States (MPS) method.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Check out the documentation of the execute function for details.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Once the execution has finished, the results can be retrieved via the getresults function, which returns a QCSResults structure.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"res = getresult(conn, job)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To make a histogram out of the retrieved samples, it suffices to execute","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"histsamples(res)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To plot the results (works both with Plots.jl and Makie.jl) you can use","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Plots\nplot(res)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Check the cloud execution page for more details on job handling.","category":"page"},{"location":"quick_start/#OpenQASM-and-Stim","page":"Quick start","title":"OpenQASM and Stim","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"OpenQASM and Stim files, defining quantum algorithms can be executed on MIMIQ in the same way native circuits can, simply use execute and provide the path of the file to upload. See the import-export page for more details on how include files are handled.","category":"page"},{"location":"library/outline/#Library-Outline","page":"Outline","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Outline","title":"Outline","text":"Pages = [\n    \"mimiqcircuits.md\",\n    \"mimiqlink.md\",\n    \"mimiqcircuitsbase/general.md\",\n    \"mimiqcircuitsbase/circuits.md\",\n    \"mimiqcircuitsbase/operations.md\",\n    \"mimiqcircuitsbase/standard.md\",\n    \"mimiqcircuitsbase/generalized.md\",\n    \"mimiqcircuitsbase/noise.md\",\n    \"mimiqcircuitsbase/operators.md\",\n    \"mimiqcircuitsbase/other.md\",\n    \"mimiqcircuitsbase/bitstrings.md\",\n    \"internals.md\",\n]","category":"page"},{"location":"library/mimiqcircuitsbase/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/operators/","page":"Operators","title":"Operators","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages = [\n    \"operations/operators/projectors.jl\",\n    \"operations/expectationvalue.jl\",\n    \"operations/operators/sigmas.jl\",\n    \"operations/gates/delay.jl\",\n    \"operations/entanglement.jl\",\n]","category":"page"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Projector0","page":"Operators","title":"MimiqCircuitsBase.Projector0","text":"Projector0(a)\n\nOne-qubit operator corresponding to a projection onto 0rangle.\n\nThe corresponding matrix\n\nbeginpmatrix\n    a  0\n    0  0\nendpmatrix\n\nis parametrized by a to allow for phases/rescaling. Equivalent to DiagonalOp(a,0).\n\nThe parameter a is optional and is set to 1 by default.\n\nSee also Projector1, DiagonalOp.\n\nExamples\n\njulia> Projector0()\nP₀(1)\n\njulia> Projector0(0.5)\nP₀(0.5)\n\njulia> push!(Circuit(), ExpectationValue(Projector0()), 1, 1)\n1-qubit circuit with 1 instructions:\n└── ⟨P₀(1)⟩ @ q[1], z[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Projector00","page":"Operators","title":"MimiqCircuitsBase.Projector00","text":"Projector00(a)\n\nTwo-qubit operator corresponding to a projection onto 00rangle.\n\nThe corresponding matrix\n\nbeginpmatrix\n    a  0  0  0\n    0  0  0  0\n    0  0  0  0\n    0  0  0  0\nendpmatrix\n\nis parametrized by a to allow for phases/rescaling.\n\nThe parameter a is optional and is set to 1 by default.\n\nSee also Projector01, Projector10, Projector11.\n\nExamples\n\njulia> Projector00()\nP₀₀(1)\n\njulia> Projector00(0.5)\nP₀₀(0.5)\n\njulia> push!(Circuit(), ExpectationValue(Projector00()), 1, 2, 1)\n2-qubit circuit with 1 instructions:\n└── ⟨P₀₀(1)⟩ @ q[1:2], z[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Projector01","page":"Operators","title":"MimiqCircuitsBase.Projector01","text":"Projector01(a)\n\nTwo-qubit operator corresponding to a projection onto 01rangle.\n\nThe corresponding matrix\n\nbeginpmatrix\n    0  0  0  0\n    0  a  0  0\n    0  0  0  0\n    0  0  0  0\nendpmatrix\n\nis parametrized by a to allow for phases/rescaling.\n\nThe parameter a is optional and is set to 1 by default.\n\nSee also Projector00, Projector10, Projector11.\n\nExamples\n\njulia> Projector01()\nP₀₁(1)\n\njulia> Projector01(0.5)\nP₀₁(0.5)\n\njulia> push!(Circuit(), ExpectationValue(Projector01()), 1, 2, 1)\n2-qubit circuit with 1 instructions:\n└── ⟨P₀₁(1)⟩ @ q[1:2], z[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Projector1","page":"Operators","title":"MimiqCircuitsBase.Projector1","text":"Projector1(a)\n\nOne-qubit operator corresponding to a projection onto 1rangle.\n\nThe corresponding matrix\n\nbeginpmatrix\n    0  0\n    0  a\nendpmatrix\n\nis parametrized by a to allow for phases/rescaling. Equivalent to DiagonalOp(0,a).\n\nThe parameter a is optional and is set to 1 by default.\n\nSee also Projector0, DiagonalOp.\n\nExamples\n\njulia> Projector1()\nP₁(1)\n\njulia> Projector1(0.5)\nP₁(0.5)\n\njulia> push!(Circuit(), ExpectationValue(Projector1()), 1, 1)\n1-qubit circuit with 1 instructions:\n└── ⟨P₁(1)⟩ @ q[1], z[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Projector10","page":"Operators","title":"MimiqCircuitsBase.Projector10","text":"Projector10(a)\n\nTwo-qubit operator corresponding to a projection onto 10rangle.\n\nThe corresponding matrix\n\nbeginpmatrix\n    0  0  0  0\n    0  0  0  0\n    0  0  a  0\n    0  0  0  0\nendpmatrix\n\nis parametrized by a to allow for phases/rescaling.\n\nThe parameter a is optional and is set to 1 by default.\n\nSee also Projector00, Projector01, Projector11.\n\nExamples\n\njulia> Projector10()\nP₁₀(1)\n\njulia> Projector10(0.5)\nP₁₀(0.5)\n\njulia> push!(Circuit(), ExpectationValue(Projector10()), 1, 2, 1)\n2-qubit circuit with 1 instructions:\n└── ⟨P₁₀(1)⟩ @ q[1:2], z[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Projector11","page":"Operators","title":"MimiqCircuitsBase.Projector11","text":"Projector11(a)\n\nTwo-qubit operator corresponding to a projection onto 11rangle.\n\nThe corresponding matrix is\n\nbeginpmatrix\n    0  0  0  0\n    0  0  0  0\n    0  0  0  0\n    0  0  0  a\nendpmatrix\n\nis parametrized by a to allow for phases/rescaling.\n\nThe parameter a is optional and is set to 1 by default.\n\nSee also Projector00, Projector01, Projector10.\n\nExamples\n\njulia> Projector11()\nP₁₁(1)\n\njulia> Projector11(0.5)\nP₁₁(0.5)\n\njulia> push!(Circuit(), ExpectationValue(Projector11()), 1, 2, 1)\n2-qubit circuit with 1 instructions:\n└── ⟨P₁₁(1)⟩ @ q[1:2], z[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ProjectorX0","page":"Operators","title":"MimiqCircuitsBase.ProjectorX0","text":"ProjectorX0(a)\n\nOne-qubit operator corresponding to a projection onto +rangle.\n\nThe corresponding matrix\n\nfraca2\nbeginpmatrix\n    1  1\n    1  1\nendpmatrix\n\nis parametrized by a to allow for phases/rescaling.\n\nThe parameter a is optional and is set to 1 by default.\n\nSee also ProjectorX1.\n\nExamples\n\njulia> ProjectorX0()\nPX₀(1)\n\njulia> ProjectorX0(0.5)\nPX₀(0.5)\n\njulia> push!(Circuit(), ExpectationValue(ProjectorX0()), 1, 1)\n1-qubit circuit with 1 instructions:\n└── ⟨PX₀(1)⟩ @ q[1], z[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ProjectorX1","page":"Operators","title":"MimiqCircuitsBase.ProjectorX1","text":"ProjectorX1(a)\n\nOne-qubit operator corresponding to a projection onto -rangle.\n\nThe corresponding matrix\n\nfraca2\nbeginpmatrix\n    1  -1\n    -1  1\nendpmatrix\n\nis parametrized by a to allow for phases/rescaling.\n\nThe parameter a is optional and is set to 1 by default.\n\nSee also ProjectorX0.\n\nExamples\n\njulia> ProjectorX1()\nPX₁(1)\n\njulia> ProjectorX1(0.5)\nPX₁(0.5)\n\njulia> push!(Circuit(), ExpectationValue(ProjectorX1()), 1, 1)\n1-qubit circuit with 1 instructions:\n└── ⟨PX₁(1)⟩ @ q[1], z[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ProjectorY0","page":"Operators","title":"MimiqCircuitsBase.ProjectorY0","text":"ProjectorY0(a)\n\nOne-qubit operator corresponding to a projection onto y+rangle.\n\nThe corresponding matrix\n\nfraca2\nbeginpmatrix\n    1  -i\n    i  1\nendpmatrix\n\nis parametrized by a to allow for phases/rescaling.\n\nThe parameter a is optional and is set to 1 by default.\n\nSee also ProjectorY1.\n\nExamples\n\njulia> ProjectorY0()\nPY₀(1)\n\njulia> ProjectorY0(0.5)\nPY₀(0.5)\n\njulia> push!(Circuit(), ExpectationValue(ProjectorY0()), 1, 1)\n1-qubit circuit with 1 instructions:\n└── ⟨PY₀(1)⟩ @ q[1], z[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ProjectorY1","page":"Operators","title":"MimiqCircuitsBase.ProjectorY1","text":"ProjectorY1(a)\n\nOne-qubit operator corresponding to a projection onto y-rangle.\n\nThe corresponding matrix\n\nfraca2\nbeginpmatrix\n    1  i\n    -i  1\nendpmatrix\n\nis parametrized by a to allow for phases/rescaling.\n\nThe parameter a is optional and is set to 1 by default.\n\nSee also ProjectorY0.\n\nExamples\n\njulia> ProjectorY1()\nPY₁(1)\n\njulia> ProjectorY1(0.5)\nPY₁(0.5)\n\njulia> push!(Circuit(), ExpectationValue(ProjectorY1()), 1, 1)\n1-qubit circuit with 1 instructions:\n└── ⟨PY₁(1)⟩ @ q[1], z[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ProjectorZ0","page":"Operators","title":"MimiqCircuitsBase.ProjectorZ0","text":"ProjectorZ0(a)\n\nSee Projector0.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ProjectorZ1","page":"Operators","title":"MimiqCircuitsBase.ProjectorZ1","text":"ProjectorZ1(a)\n\nSee Projector1.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ExpectationValue","page":"Operators","title":"MimiqCircuitsBase.ExpectationValue","text":"ExpectationValue(op)\n\nOperation to compute and store expectation value of an Operator in a z-register.\n\nAn expectation value for a pure state  psi rangle is defined as\n\nlangle O rangle = langle psi  O  psi rangle\n\nwhere O is an operator. With respect to a density matrix rho it's given by\n\nlangle O rangle = mathrmTr(rho O)\n\nHowever, when using quantum trajectories to solve noisy circuits, the expectation value is computed with respect to the pure state of each trajectory.\n\nThe argument op can be any gate or non-unitary operator.\n\nnote: Note\nExpectationValue is currently restricted to one and two qubit operators.\n\nSee also AbstractOperator, AbstractGate.\n\nExamples\n\nIn push! the first argument corresponds to the qubit, and the second to the z-register\n\njulia> ExpectationValue(GateX())\n⟨X⟩\n\njulia> c = push!(Circuit(), ExpectationValue(GateX()), 1, 1)\n1-qubit circuit with 1 instructions:\n└── ⟨X⟩ @ q[1], z[1]\n\njulia> c = push!(Circuit(), ExpectationValue(SigmaPlus()), 1, 2)\n1-qubit circuit with 1 instructions:\n└── ⟨SigmaPlus(1)⟩ @ q[1], z[2]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.SigmaMinus","page":"Operators","title":"MimiqCircuitsBase.SigmaMinus","text":"SigmaMinus(a)\n\nOne-qubit operator corresponding to 0 ranglelangle 1.\n\nThe corresponding matrix\n\nbeginpmatrix\n    0  a\n    0  0\nendpmatrix\n\nis parametrized by a to allow for phases/rescaling.\n\nThe parameter a is optional and is set to 1 by default.\n\nSee also SigmaPlus.\n\nExamples\n\njulia> SigmaMinus()\nSigmaMinus(1)\n\njulia> SigmaMinus(0.5)\nSigmaMinus(0.5)\n\njulia> push!(Circuit(), ExpectationValue(SigmaMinus()), 1, 1)\n1-qubit circuit with 1 instructions:\n└── ⟨SigmaMinus(1)⟩ @ q[1], z[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.SigmaPlus","page":"Operators","title":"MimiqCircuitsBase.SigmaPlus","text":"SigmaPlus(a)\n\nOne-qubit operator corresponding to 1 ranglelangle 0.\n\nThe corresponding matrix\n\nbeginpmatrix\n    0  0\n    a  0\nendpmatrix\n\nis parametrized by a to allow for phases/rescaling.\n\nThe parameter a is optional and is set to 1 by default.\n\nSee also SigmaMinus.\n\nExamples\n\njulia> SigmaPlus()\nSigmaPlus(1)\n\njulia> SigmaPlus(0.5)\nSigmaPlus(0.5)\n\njulia> push!(Circuit(), ExpectationValue(SigmaPlus()), 1, 1)\n1-qubit circuit with 1 instructions:\n└── ⟨SigmaPlus(1)⟩ @ q[1], z[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Delay","page":"Operators","title":"MimiqCircuitsBase.Delay","text":"Delay(t)\n\n1-qubit delay gate\n\nThis gate is equivalent to a GateID gate, except that it is parametrized by a time parameter t. The parameter does not affect the action of the gate. The only purpose of this gate is to act as a placeholder to indicate idle noise, in which case the parameter t can later be used to further specify the noise properties.\n\nThe gate can be created by calling Delay(t) where t is a number.\n\nSee also GateID.\n\nMatrix representation\n\noperatornameDelay(t) =\nbeginpmatrix\n    1  0 \n    0  1\nendpmatrix\n\nExamples\n\njulia> c = push!(Circuit(), Delay(0.1), 1)\n1-qubit circuit with 1 instructions:\n└── Delay(0.1) @ q[1]\n\n\nDecomposition\n\njulia> decompose(Delay(0.2))\n1-qubit circuit with 1 instructions:\n└── ID @ q[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.BondDim","page":"Operators","title":"MimiqCircuitsBase.BondDim","text":"BondDim()\n\nOperation to get the bond dimension between two halves of the system and store in a z-register.\n\nThe bond dimension is only defined for a matrix-product state (MPS), which can be written as (with i_1=i_N+1=1)\n\npsi rangle = sum_s_1s_2ldots=1^2\nsum_i_2^chi_2 sum_i_3^chi_3 ldots sum_i_N^chi_N\nA^(s_1)_i_1i_2 A^(s_2)_i_2 i_3 A^(s_3)_i_3 i_4 ldots\nA^(s_N)_i_Ni_N+1  s_1 s_2 s_3 ldots s_N rangle \n\nHere, chi_k is the bond dimension, i.e. the dimension of the index i_k. The first and last bond dimensions are dummies, chi_0=chi_N=1. A bond dimension of 1 means there is no entanglement between the two halves of the system.\n\nSee also VonNeumannEntropy, SchmidtRank.\n\nExamples\n\nWhen pushing to a circuit, the qubit index k that we give will get back the bond dimension i_k in the above notation, i.e. the bond dimension between qubit k-1 and qubit k. For k=1 the bond dimension returned will always be 1.\n\njulia> k = 5;\n\njulia> c = push!(Circuit(), BondDim(), k, 1)\n5-qubit circuit with 1 instructions:\n└── BondDim @ q[5], z[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.SchmidtRank","page":"Operators","title":"MimiqCircuitsBase.SchmidtRank","text":"SchmidtRank()\n\nOperation to get the Schmidt rank of a bipartition and store in a z-register.\n\nA Schmidt decomposition for a bipartition into subsystems A and B is defined for a pure state as \n\npsirangle = sum_i=1^r s_i alpha_irangle otimes beta_irangle\n\nwhere alpha_irangle (beta_irangle) are orthonormal states acting on A (B). The Schmidt rank is the number of terms r in the sum. A product state gives r=1 and r1 signals entanglement.\n\nWe only consider bipartitions where A=1ldotsk-1 and B=kldotsN, for some k and where N is the total number of qubits.\n\nIn MPS, when the state is optimally compressed, the Schmidt rank should be equal to the bond dimension BondDim.\n\nSee also VonNeumannEntropy.\n\nExamples\n\nWhen pushing to a circuit, the qubit index k takes the role of the above bipartition into A and B. For k=1, A is empty and the Schmidt rank will always return 1.\n\njulia> k = 5;\n\njulia> c = push!(Circuit(), SchmidtRank(), k, 1)\n5-qubit circuit with 1 instructions:\n└── SchmidtRank @ q[5], z[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.VonNeumannEntropy","page":"Operators","title":"MimiqCircuitsBase.VonNeumannEntropy","text":"VonNeumannEntropy()\n\nOperation to get the bipartite Von Neumann entanglement entropy and store in a z-register.\n\nThe entanglement entropy for a bipartition into subsystems A and B is defined for a pure state rho =  psi ranglelangle psi  as\n\nmathcalS(rho_A) = - mathrmTr(rho_A log_2 rho_A) \n= - mathrmTr(rho_B log_2 rho_B)\n= mathcalS(rho_A)\n\nwhere rho_A = mathrmTr_B(rho) is the reduced density matrix. A product state has mathcalS(rho_A)=0 and a maximally entangled state between A and B gives mathcalS(rho_A)=1.\n\nWe only consider bipartitions where A=1ldotsk-1 and B=kldotsN, for some k and where N is the total number of qubits.\n\nWhen the system is open (i.e. with noise) and we are using quantum trajectories, the entanglement entropy of each trajectory is returned during execution.\n\nSee also BondDim, SchmidtRank.\n\nExamples\n\nWhen pushing to a circuit, the qubit index k takes the role of the above bipartition into A and B. For k=1, A is empty and the entanglement entropy will always return 0.\n\njulia> k = 5;\n\njulia> c = push!(Circuit(), VonNeumannEntropy(), k, 1)\n5-qubit circuit with 1 instructions:\n└── VonNeumannEntropy @ q[5], z[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operators/","page":"Operators","title":"Operators","text":"<!– TODO: Delay and entanglement should be replaced to where they belong They were placed here for compliation purposes –>","category":"page"},{"location":"library/internals/#Private-types-and-functions","page":"Internals","title":"Private types and functions","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [MimiqCircuits]\nPublic  = false","category":"page"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [MimiqCircuitsBase]\nPublic  = false","category":"page"},{"location":"library/internals/#MimiqCircuitsBase.LazyArg","page":"Internals","title":"MimiqCircuitsBase.LazyArg","text":"LazyArg()\n\nPlaceholder for a lazy argument in a LazyExpr.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqCircuitsBase.LazyExpr","page":"Internals","title":"MimiqCircuitsBase.LazyExpr","text":"LazyExpr(type, args)\n\nHelps evaluating expressions lazily.\n\nEvaluation occurs only then the LazyExpr is called with some arguments, and the arguments will be passed to the inner part of the expression.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqCircuitsBase.UnexpectedSymbolics","page":"Internals","title":"MimiqCircuitsBase.UnexpectedSymbolics","text":"UnexpectedSymbolics(sym, expr)\n\nError to be thrown when a unexpected symbolics is present in an expression.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#Base.append!-Tuple{Circuit, Circuit}","page":"Internals","title":"Base.append!","text":"append!(circuit1::Circuit, circuit2::Circuit)\n\nAppend all instructions from circuit2 to circuit1.\n\nArguments\n\ncircuit1::Circuit: The target circuit to which instructions will be appended.\ncircuit2::Circuit: The circuit whose instructions will be appended.\n\nExamples\n\n```jldoctests julia> c=Circuit() empty circuit\n\njulia> push!(c, GateX(), 1:4)         # Applies X to all 4 targets 4-qubit circuit with 4 instructions: ├── X @ q[1] ├── X @ q[2] ├── X @ q[3] └── X @ q[4]\n\njulia> c1 = Circuit() empty circuit\n\njulia> push!(c1, GateH(), 1:4) 4-qubit circuit with 4 instructions: ├── H @ q[1] ├── H @ q[2] ├── H @ q[3] └── H @ q[4]\n\njulia> append!(c,c1) 4-qubit circuit with 8 instructions: ├── X @ q[1] ├── X @ q[2] ├── X @ q[3] ├── X @ q[4] ├── H @ q[1] ├── H @ q[2] ├── H @ q[3] └── H @ q[4]\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Base.insert!-Tuple{Circuit, Any, Instruction}","page":"Internals","title":"Base.insert!","text":"insert!(circuit::Circuit, index::Integer, instruction::Instruction)\n\nInsert an instruction into the circuit at the specified index.\n\nArguments\n\ncircuit::Circuit: The quantum circuit where the instruction will be inserted.\nindex::Integer: The position at which the instruction will be inserted.\ninstruction::Instruction: The instruction to insert.\n\nExamples\n\n```jldoctests julia> c=Circuit() empty circuit\n\njulia> c=Circuit() empty circuit\n\njulia> push!(c, GateX(), 1:4) 4-qubit circuit with 4 instructions: ├── X @ q[1] ├── X @ q[2] ├── X @ q[3] └── X @ q[4]\n\njulia> insert!(c, 2, Instruction(GateH(), 1)) 4-qubit circuit with 5 instructions: ├── X @ q[1] ├── H @ q[1] ├── X @ q[2] ├── X @ q[3] └── X @ q[4]\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Base.insert!-Tuple{Circuit, Int64, Circuit}","page":"Internals","title":"Base.insert!","text":"insert!(circuit1::Circuit, index::Integer, circuit2::Circuit)\n\nInsert all instructions from circuit2 into circuit1 at the specified index.\n\nArguments\n\ncircuit1::Circuit: The target circuit where instructions will be inserted.\nindex::Integer: The position at which the instructions from circuit2 will be inserted.\ncircuit2::Circuit: The circuit whose instructions will be inserted.\n\nExamples\n\n```jldoctests julia> c = Circuit() empty circuit\n\njulia> push!(c, GateX(), 1:4) 4-qubit circuit with 4 instructions: ├── X @ q[1] ├── X @ q[2] ├── X @ q[3] └── X @ q[4]\n\njulia> c1 = Circuit() empty circuit\n\njulia> push!(c1, GateH(), 1:4) 4-qubit circuit with 4 instructions: ├── H @ q[1] ├── H @ q[2] ├── H @ q[3] └── H @ q[4]\n\njulia> insert!(c,1,c1) 4-qubit circuit with 8 instructions: ├── H @ q[1] ├── H @ q[2] ├── H @ q[3] ├── H @ q[4] ├── X @ q[1] ├── X @ q[2] ├── X @ q[3] └── X @ q[4]\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Base.insert!-Union{Tuple{T}, Tuple{Circuit, Integer, Type{T}, Vararg{Any}}} where T<:Operation","page":"Internals","title":"Base.insert!","text":"insert!(c::Circuit, i::Integer, operation_type::Type{T}, targets...)\n\nInsert a non-parametric operation of a specific type into the circuit at a given position.\n\nArguments\n\nc::Circuit: The quantum circuit where the operation will be inserted.\ni::Integer: The position (1-based index) in the circuit where the operation will be inserted.\noperation_type::Type{T}: The type of the operation to apply.\ntargets: The target qubits, bits, or z-variables for the operation.\n\nErrors\n\nArgumentError: Raised if the operation type is parametric (i.e., it requires parameters). \n\nExamples\n\njulia> c = Circuit()\nempty circuit\n\njulia> c=Circuit()\nempty circuit\n\njulia> push!(c, GateX(), 1:4)        \n4-qubit circuit with 4 instructions:\n├── X @ q[1]\n├── X @ q[2]\n├── X @ q[3]\n└── X @ q[4]\n\njulia> insert!(c, 3, GateRX(π/2), 5)\n5-qubit circuit with 5 instructions:\n├── X @ q[1]\n├── X @ q[2]\n├── RX(π/2) @ q[5]\n├── X @ q[3]\n└── X @ q[4]\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Base.push!-Tuple{Circuit, Instruction}","page":"Internals","title":"Base.push!","text":"push!(circuit::Circuit, instruction::Instruction)\n\nAdd an instruction to the circuit.\n\nArguments\n\ncircuit::Circuit: The quantum circuit to which the instruction will be added.\ninstruction::Instruction: The instruction to add.\n\nExamples\n\njulia> c=Circuit()\nempty circuit\n\njulia> push!(c, Instruction(GateX(),1)) \n1-qubit circuit with 1 instructions:\n└── X @ q[1]\n\njulia> push!(c, Instruction(GateCX(),1, 2))\n2-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── CX @ q[1], q[2]\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Base.push!-Union{Tuple{K}, Tuple{L}, Tuple{M}, Tuple{N}, Tuple{Circuit, Operation{N, M, L}, Vararg{Any, K}}} where {N, M, L, K}","page":"Internals","title":"Base.push!","text":"push!(circuit::Circuit, operation::Operation, targets::Vararg{Int})\n\nAdd an operation to the circuit with the specified qubit, bit, or zvar targets.\n\nThis function allows you to push quantum operations onto a circuit,  specifying the exact qubits, classical bits, or zvars (if applicable) that the operation acts on.\n\nArguments\n\ncircuit::Circuit: The quantum circuit to which the operation will be added.\noperation::Operation{N,M,L}: The operation to apply. It works on N qubits, M classical bits, and L zvars.\ntargets::Vararg{Any,K}: The target qubits, bits, or zvars for the operation.\n\nThrows\n\nArgumentError: If the wrong number of targets is provided.\nArgumentError: If any targets are invalid or not distinct.\n\nExamples\n\njulia> c=Circuit()\nempty circuit\n\njulia> push!(c, GateCX(), [1, 2], 3)  # Adds `CX @ q1, q3` and `CX @ q2, q3`\n3-qubit circuit with 2 instructions:\n├── CX @ q[1], q[3]\n└── CX @ q[2], q[3]\n\njulia> push!(c, GateX(), 1:4)         # Applies X to all 4 targets\n4-qubit circuit with 6 instructions:\n├── CX @ q[1], q[3]\n├── CX @ q[2], q[3]\n├── X @ q[1]\n├── X @ q[2]\n├── X @ q[3]\n└── X @ q[4]\n\njulia> push!(c, GateH(), 8)\n8-qubit circuit with 7 instructions:\n├── CX @ q[1], q[3]\n├── CX @ q[2], q[3]\n├── X @ q[1]\n├── X @ q[2]\n├── X @ q[3]\n├── X @ q[4]\n└── H @ q[8]\n\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Base.push!-Union{Tuple{T}, Tuple{Circuit, Type{T}, Vararg{Any}}} where T<:Operation","page":"Internals","title":"Base.push!","text":"push!(circuit::Circuit, operation_type::Type{T}, targets...)\n\nAdd an operation of a specific type to the circuit with the given targets.\n\nArguments\n\ncircuit::Circuit: The quantum circuit to which the operation will be added.\noperation_type::Type{T}: The type of the operation to apply.\ntargets: The target qubits, bits, or zvars for the operation.\n\nErrors\n\nArgumentError: Raised if the operation type requires parameters (i.e., it is a parametric operation), but none were provided. \n\nExamples\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, GateRX(π/2), 1:4)\n4-qubit circuit with 4 instructions:\n├── RX(π/2) @ q[1]\n├── RX(π/2) @ q[2]\n├── RX(π/2) @ q[3]\n└── RX(π/2) @ q[4]\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#MimiqCircuitsBase._displaypi-Tuple{Symbolics.Num}","page":"Internals","title":"MimiqCircuitsBase._displaypi","text":"Rewrite number in units of π, if number is rational multiple of π.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#MimiqCircuitsBase.add_noise_to_gate_parallel!-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}","page":"Internals","title":"MimiqCircuitsBase.add_noise_to_gate_parallel!","text":"add_noise_to_gate_parallel!(c, g, noise; before=false)\n\nAdd a block of noise operations noise after/before every block of a given operation g.\n\nThe function identifies blocks of consecutive transversal operations of type g and adds after each such block a block of transversal noise operations noise. The noise operation noise can be a Kraus channel or a gate and will act on the same qubits as the operation g it is being added to.\n\nSee add_noise! for more information.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#MimiqCircuitsBase.add_noise_to_gate_single!-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}","page":"Internals","title":"MimiqCircuitsBase.add_noise_to_gate_single!","text":"add_noise_to_gate_single!(c, g, noise; before=false)\n\nAdd a noise operation noise after/before every instance of a given operation g.\n\nThe noise operation noise can be a Kraus channel or a gate and will act on the same qubits as the operation g it is being added to.\n\nSee add_noise! for more information.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#MimiqCircuitsBase.exponent-Union{Tuple{Power{P, N} where N}, Tuple{P}} where P","page":"Internals","title":"MimiqCircuitsBase.exponent","text":"exponent(poweroperation)\n\nExponent associated with a power operation\n\nExamples\n\njulia> MimiqCircuitsBase.exponent(power(GateH(), 2))\n2\n\njulia> MimiqCircuitsBase.exponent(GateSX())\n1//2\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#MimiqCircuitsBase.isCPTP-Union{Tuple{Type{T}}, Tuple{T}} where T<:AbstractKrausChannel","page":"Internals","title":"MimiqCircuitsBase.isCPTP","text":"isCPTP(krauschannel)\n\nWhether the Kraus channel is Completely Positive, and Trace Preserving.\n\nIf the Kraus operators fulfill sum_k E_k^dagger E_k = I then the quantum operation is CPTP. If sum_k E_k^dagger E_k  I, then it's not CPTP.\n\nCurrently, all noise channels are CPTP.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#MimiqCircuitsBase.isidentity-Tuple{Operation}","page":"Internals","title":"MimiqCircuitsBase.isidentity","text":"isidentity(operation)\n\nCheck if the given operation is equivalent to an isidentity.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [MimiqLink]\nPublic  = false","category":"page"},{"location":"library/internals/#MimiqLink.DEFAULT_INTERVAL","page":"Internals","title":"MimiqLink.DEFAULT_INTERVAL","text":"const DEFAULT_INTERVAL\n\nDefault refresh interval for tokens (in seconds)\n\n\n\n\n\n","category":"constant"},{"location":"library/internals/#MimiqLink.Connection","page":"Internals","title":"MimiqLink.Connection","text":"struct Connection\n\nConnection with the MIMIQ Services.\n\nAttributes\n\nuri: the URI of the connected instance\ntokens_channel: channel updated with the latest refreshed token\nrefresher: task that refreshes the token on a configured interval\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqLink.Execution","page":"Internals","title":"MimiqLink.Execution","text":"struct Execution\n\nStructure referring to an execution on the MIMIQ Services.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqLink.Tokens","page":"Internals","title":"MimiqLink.Tokens","text":"struct Tokens\n\nStore access and refresh tokens\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqLink.deletefiles-Tuple{Connection, Execution}","page":"Internals","title":"MimiqLink.deletefiles","text":"deletefiles(conn, req)\"\n\nDelete the files associated with a request.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#MimiqLink.printrequests-Tuple{Connection}","page":"Internals","title":"MimiqLink.printrequests","text":"printrequests(conn; kwargs...)\n\nPrint the list of requests on the MIMIQ Cloud Services.\n\nKeyword arguments\n\nstatus: filter by status. Can be NEW, RUNNING, ERROR, CANCELED, DONE.\nuserEmail: filter by user email.\nlimit: limit the number of requests to retrieve. Can be [10, 50, 100, 200].\npage: page number to retrieve.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#MimiqLink.refresh-Tuple{MimiqLink.Tokens, URIs.URI}","page":"Internals","title":"MimiqLink.refresh","text":"refresh(tokens, uri)\n\nRefresh the tokens at the given uri / instance of MIMIQ.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#MimiqLink.requests-Tuple{Connection}","page":"Internals","title":"MimiqLink.requests","text":"requests(conn; kwargs...)\n\nRetrieve the list of requests on the MIMIQ Cloud Services.\n\nnote: Note\nIt is only possible to retrieve the requests that the user has permissions to see. This is often limited to the requests that the user has created, for normal users, and to all organization requests, for organization administrators.\n\nKeyword arguments\n\nstatus: filter by status. Can be NEW, RUNNING, ERROR, CANCELED, DONE.\nuserEmail: filter by user email.\nlimit: limit the number of requests to retrieve. Can be [10, 50, 100, 200].\npage: page number to retrieve.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#MimiqLink.stopexecution-Tuple{Connection, Execution}","page":"Internals","title":"MimiqLink.stopexecution","text":"stopexecution(conn, req)\n\nStop the execution of a request.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/bitstrings/#Bit-Strings","page":"Bit Strings","title":"Bit Strings","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/bitstrings/","page":"Bit Strings","title":"Bit Strings","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"bitstrings.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.BitString","page":"Bit Strings","title":"MimiqCircuitsBase.BitString","text":"BitString(numbits)\n\nRepresentation of the state of a register of bits. Can also represent the state of a register of qubits with defined values for each qubit (0 or 1).\n\nExamples\n\njulia> BitString(16)\n16-bits BitString with integer value 0:\n  00000000 00000000\n\njulia> bs = BitString(16, [1,2,3,4])\n16-bits BitString with integer value 15:\n  11110000 00000000\n\njulia> bs[10] = 1\n1\n\njulia> bs\n16-bits BitString with integer value 527:\n  11110000 01000000\n\njulia> bitstring_to_integer(bs)\n527\n\njulia> typeof(ans)\nBigInt\n\njulia> bitstring_to_integer(bs, Int)\n527\n\njulia> typeof(ans)\nInt64\n\nThere are many different ways to get bit states:\n\njulia> bs = BitString(30, 2344574)\n30-bits BitString with integer value 2344574:\n  01111110 01100011 11000100 000000\n\njulia> ones(BitString, 10) # or also trues(BitString, 10)\n10-bits BitString with integer value 1023:\n  11111111 11\n\njulia> zeros(BitString, 10) # or also falses(BitString, 10)\n10-bits BitString with integer value 0:\n  00000000 00\n\njulia> BitString(16) do i\n           iseven(i)\n       end\n16-bits BitString with integer value 43690:\n  01010101 01010101\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.bitstring_to_index-Tuple{BitString}","page":"Bit Strings","title":"MimiqCircuitsBase.bitstring_to_index","text":"bitstring_to_index(bitstring)\n\nConvert a bitstring into the corresponding index.\n\nThis is useful for indexing, for example, a vector of states.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.bitstring_to_integer","page":"Bit Strings","title":"MimiqCircuitsBase.bitstring_to_integer","text":"bitstring_to_integer(bitstring[, T])\n\nConvert a bitstring into its corresponding integer.\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.nonzeros-Tuple{BitString}","page":"Bit Strings","title":"MimiqCircuitsBase.nonzeros","text":"nonzeros(bitstring)\n\nReturn the indices of the non-zero qubits in a bit state.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.to01-Tuple{BitString}","page":"Bit Strings","title":"MimiqCircuitsBase.to01","text":"to01(bitstring[, endianess=:big])\n\nConverts a BitString into a string of 0 and 1 characters. Optionally endianess can be specified, which can be either :big or :little.\n\nExamples\n\njulia> to01(bs\"10011\")\n\"10011\"\n\njulia> to01(bs\"10011\"; endianess=:big)\n\"10011\"\n\njulia> to01(bs\"10011\"; endianess=:little)\n\"11001\"\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.tobits-Tuple{BitString}","page":"Bit Strings","title":"MimiqCircuitsBase.tobits","text":"tobits(bitstring)\n\nGet the underlying BitVector of a bit state.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/bitstrings/#MimiqCircuitsBase.@bs_str-Tuple{Any}","page":"Bit Strings","title":"MimiqCircuitsBase.@bs_str","text":"macro bs_str(s)\n\nConvert a string into a bit state.\n\nExamples\n\njulia> bs\"101011\"\n6-bits BitString with integer value 53:\n  101011\n\n\n\n\n\n","category":"macro"},{"location":"library/mimiqcircuitsbase/general/#General-functions","page":"General functions","title":"General functions","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/general/","page":"General functions","title":"General functions","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"abstract.jl\", \"docstrings.jl\", \"evaluate.jl\", \"symbolics.jl\", \"operations/measure.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.isopalias","page":"General functions","title":"MimiqCircuitsBase.isopalias","text":"isopalias(typ)\n\nChecks if a given operation type is an alias or not.\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.isunitary","page":"General functions","title":"MimiqCircuitsBase.isunitary","text":"isunitary(instruction)\nisunitary(operation)\n\nChecks if a given operation is unititary or not.\n\nSee also\n\niswrapper\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.getoperation","page":"General functions","title":"MimiqCircuitsBase.getoperation","text":"getoperation(operation)\ngetoperation(instruction)\n\nReturns the quantum operation associated to the given instruction.\n\nSee also iswrapper.\n\nExamples\n\njulia> getoperation(Instruction(GateX(), 1))\nX\n\njulia> getoperation(GateSX())\nX\n\njulia> getoperation(GateCX())\nX\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.numbits","page":"General functions","title":"MimiqCircuitsBase.numbits","text":"numbits(instruction)\nnumbits(circuit)\n\nNumber of classical bits on which the given operation or instruction is defined.\n\nSee also numqubits.\n\nExamples\n\njulia> numbits(GateCX())\n0\n\njulia> numbits(Measure())\n1\n\njulia> c = Circuit(); push!(c, Measure(), 1, 1); push!(c, Measure(),1,3)\n1-qubit circuit with 2 instructions:\n├── M @ q[1], c[1]\n└── M @ q[1], c[3]\n\njulia> numbits(c)\n3\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.numqubits","page":"General functions","title":"MimiqCircuitsBase.numqubits","text":"numqubits(operation)\nnumqubits(instruction)\nnumqubits(circuit)\n\nNumber of qubits on which the given operation or instruction is defined.\n\nSee also numbits.\n\nExamples\n\njulia> numqubits(GateCX())\n2\n\njulia> numqubits(Measure())\n1\n\njulia> c = Circuit(); push!(c, GateX(), 1); push!(c, GateCX(),3,6)\n6-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── CX @ q[3], q[6]\n\njulia> numqubits(c)\n6\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.opname","page":"General functions","title":"MimiqCircuitsBase.opname","text":"opname(instruction)\nopname(operation)\n\nName of the underlying quantum operation in a human readable format.\n\nSee also numqubits, numbits.\n\nExamples\n\njulia> opname(GateX())\n\"X\"\n\njulia> opname(GateRX(π/2))\n\"RX\"\n\njulia> opname(Instruction(GateCX(),1,2))\n\"CX\"\n\njulia> opname(QFT(4))\n\"QFT\"\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.power","page":"General functions","title":"MimiqCircuitsBase.power","text":"power(operation, exponent)\n\nElevate an operation to a given exponent.\n\nIt performs simplifications when possible otherwise wraps the operation in a Power object.\n\nSee also Power, inverse, Inverse.\n\nExamples\n\njulia> power(GateX(), 1//2)\nSX\n\njulia> power(GateX(), 0.5)\nX^0.5\n\njulia> GateX()^2\nID\n\njulia> GateCSX()^2\nCX\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#Symbolics.inverse","page":"General functions","title":"Symbolics.inverse","text":"inverse(circuit)\ninverse(instruction)\ninverse(operation)\n\nInverse of the given circuit, instruction or operation.\n\nWhen the inverse is not a known operation, it will return an Inverse object that wraps the original operation.\n\ndetails: Details\nIt throws an error if the object is not invertible. Such for example, in the case of non unitary operations, or circuits containing Measure or Reset.\n\nSee also matrix, isunitary, power.\n\nExamples\n\njulia> inverse(GateRX(λ))\nRX(-λ)\n\njulia> inverse(GateCSX())\nC(SX†)\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.evaluate","page":"General functions","title":"MimiqCircuitsBase.evaluate","text":"evaluate(object, dictionary)\n\nEvaluate all the parametric expression in object using the values specified in the given in the variable, value dictionary, returning a new object constructed on the evaluated parameters.\n\nExamples\n\nEvaluate a single parametric gate\n\njulia> @variables θ\n1-element Vector{Symbolics.Num}:\n θ\n\njulia> g  = GateRX(θ)\nRX(θ)\n\njulia> evaluate(g, Dict(θ => 3π))\nRX(3π)\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.issymbolic","page":"General functions","title":"MimiqCircuitsBase.issymbolic","text":"issymbolic(obj)\n\nChecks whether the circuit contains any symbolic (unevaluated) parameters.\n\nThis method examines each instruction in the circuit to determine if any parameter remains symbolic (i.e., unevaluated). It recursively checks through each instruction and its nested  operations, if any. Returns True if any parameter is symbolic (unevaluated), False if all parameters are fully evaluated.\n\nExamples\n\njulia> c = Circuit()\nempty circuit\n\n\njulia> push!(c, GateH(), 1)\n1-qubit circuit with 1 instructions:\n└── H @ q[1]\n\njulia> issymbolic(c)\nfalse\n\njulia> @variables x y\n2-element Vector{Symbolics.Num}:\n x\n y\n\njulia> push!(c,Control(3,GateP(x+y)),1,2,3,4)\n4-qubit circuit with 2 instructions:\n├── H @ q[1]\n└── C₃P(x + y) @ q[1:3], q[4]\n\njulia> issymbolic(c)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.Measure","page":"General functions","title":"MimiqCircuitsBase.Measure","text":"Measure()\n\nSingle qubit measurement operation in the computational basis\n\nThe operation projects the quantum state and stores the result of such measurement in a classical register.\n\nwarn: Warn\nMeasure is non-reversible.\n\nSee also Operation, Reset.\n\nExamples\n\njulia> Measure()\nM\n\njulia> c = push!(Circuit(), Measure, 1, 1)\n1-qubit circuit with 1 instructions:\n└── M @ q[1], c[1]\n\njulia> push!(c, Measure(), 3, 4)\n3-qubit circuit with 2 instructions:\n├── M @ q[1], c[1]\n└── M @ q[3], c[4]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.MeasureX","page":"General functions","title":"MimiqCircuitsBase.MeasureX","text":"MeasureX()\n\nSingle qubit measurement operation in the X basis.\n\nThe operation projects the quantum state and stores the result of such measurement in a classical register.\n\nThis operation is equivalent to the sequence GateH, Measure, GateH. \n\nwarn: Warn\nMeasure is non-reversible.\n\nSee also Measure, Operation, Reset.\n\nExamples\n\njulia> Measure()\nM\n\njulia> decompose(MeasureX())\n1-qubit circuit with 3 instructions:\n├── H @ q[1]\n├── M @ q[1], c[1]\n└── H @ q[1]\n\njulia> c = push!(Circuit(), Measure, 1, 1)\n1-qubit circuit with 1 instructions:\n└── M @ q[1], c[1]\n\njulia> push!(c, Measure(), 3, 4)\n3-qubit circuit with 2 instructions:\n├── M @ q[1], c[1]\n└── M @ q[3], c[4]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.MeasureY","page":"General functions","title":"MimiqCircuitsBase.MeasureY","text":"MeasureY()\n\nSingle qubit measurement operation in the Y basis.\n\nThe operation projects the quantum state and stores the result of such measurement in a classical register.\n\nThis operation is equivalent to the sequence GateSDG, GateH, Measure, GateH, GateS. \n\nwarn: Warn\nMeasure is non-reversible.\n\nSee also Measure, Operation, Reset.\n\nExamples\n\njulia> MeasureY()\nMeasureY\n\njulia> decompose(MeasureY())\n1-qubit circuit with 3 instructions:\n├── HYZ @ q[1]\n├── M @ q[1], c[1]\n└── HYZ @ q[1]\n\njulia> c = push!(Circuit(), MeasureY, 1, 1)\n1-qubit circuit with 1 instructions:\n└── MeasureY @ q[1], c[1]\n\njulia> push!(c, MeasureY(), 3, 4)\n3-qubit circuit with 2 instructions:\n├── MeasureY @ q[1], c[1]\n└── MeasureY @ q[3], c[4]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.MeasureZ","page":"General functions","title":"MimiqCircuitsBase.MeasureZ","text":"MeasureZ()\n\nSee Measure.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/general/#Serialization","page":"General functions","title":"Serialization","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/general/","page":"General functions","title":"General functions","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"proto/proto.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.loadproto","page":"General functions","title":"MimiqCircuitsBase.loadproto","text":"loadproto(fname, Circuit)\nloadproto(fname, QCSResults)\n\nDeserialize a Circuit or a QCSResults object from a ProtoBuf file.\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/general/#MimiqCircuitsBase.saveproto","page":"General functions","title":"MimiqCircuitsBase.saveproto","text":"saveproto(fname, c::Circuit)\nsaveproto(fname, c::QCSResults)\n\nSerialize a Circuit or a QCSResults object to a ProtoBuf file.\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/operations/","page":"Operations","title":"Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"operation.jl\", \"list.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Operation","page":"Operations","title":"MimiqCircuitsBase.Operation","text":"Operation{N,M,L}\n\nAbstract supertype for all the quantum operations acting on N qubits and M classical bits.\n\nMethods\n\niswrapper, isunitary, numbits, numqubits, opname\n\nSee also\n\nAbstractGate\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.cregsizes-Tuple{T} where T","page":"Operations","title":"MimiqCircuitsBase.cregsizes","text":"cregsizes(operation)\ncregsizes(operationtype)\n\nLength of the classicalregisters the given operation acts on.\n\nSee also\n\nqregsizes, numqubits, numbits\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.getparam","page":"Operations","title":"MimiqCircuitsBase.getparam","text":"getparam(operation, name)\n\nValue of the corresponding parameter in the given parametric operation.\n\nExamples\n\ngetparam(GateRX(π/8), :θ)\n\nSee also\n\nparnames, numparams, getparams\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.getparams","page":"Operations","title":"MimiqCircuitsBase.getparams","text":"getparams(operation)\n\nValue of the parameters in the given parametric operation.\n\nExamples\n\ngetparam(GateU(π/8, 3.1, sqrt(2)))\n\nSee also\n\nparnames, numparams, getparam\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.hilbertspacedim","page":"Operations","title":"MimiqCircuitsBase.hilbertspacedim","text":"hilbertspacedim(operation)\nhilbertspacedim(operationtype)\nhilbertspacedim(N::Integer)\n\nHilbert space dimension for the given operation. For an operation actiing on N qubits, it is 2^N.\n\nExamples\n\nhilbertspacedim(Operation{2, 1})\nhilbertspacedim(GateH)\nhilbertspacedim(GateH())\nhilbertspacedim(GateRX)\nhilbertspacedim(GateCX)\nhilbertspacedim(4)\n\nSee also\n\nnumqubits, numbits, Operation, AbstractGate\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.iswrapper","page":"Operations","title":"MimiqCircuitsBase.iswrapper","text":"iswrapper(operation)\niswrapper(operationtype)\n\nChecks if a given operation is a wrapper or not.\n\nExamples\n\niswrapper(Control)\niswrapper(GateX)\niswrapper(GateSX) # SX is defined as Power(1//2, GateX())\niswrapper(GateCX) # CX is defined as Control(1, GateX())\n\nSee also\n\nisunitary, getoperation\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.numparams","page":"Operations","title":"MimiqCircuitsBase.numparams","text":"numparams(operation)\nnumparams(operationtype)\n\nNumber of parameters for the given parametric operation. Zero for non parametric operations.\n\nBy default it returns the number of fields of the operations.\n\nExamples\n\njulia> numparams(GateH)\n0\n\njulia> numparams(GateU)\n4\n\njulia> numparams(GateRX)\n1\n\njulia> numparams(Measure)\n0\n\n\nSee also\n\nparnames, getparam\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.parnames","page":"Operations","title":"MimiqCircuitsBase.parnames","text":"parnames(operation)\nparnames(operationtype)\n\nName of the parameters allowed for the given operation.\n\nBy default it returns the fieldnames of the operation type.\n\nExamples\n\nparnames(GateH)\nparnames(GateRX)\nparnames(GateCRX)\nparnames(Measure)\n\nSee also\n\nnumparams, getparam\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.qregsizes-Tuple{T} where T","page":"Operations","title":"MimiqCircuitsBase.qregsizes","text":"qregsizes(operation)\nqregsizes(operationtype)\n\nLength of the quantum registers the given operation acts on.\n\ndetails: Details\nSome operations, such as adders or multipliers, acts on different groups of qubits (quantum registers).\n\nExamples\n\njulia> qregsizes(GateRX(0.1))\n(1,)\n\njulia> qregsizes(GateCRX(0.1))\n(1, 1)\n\njulia> qregsizes(QFT(4))\n(4,)\n\nSee also\n\ncregsizes, numqubits, numbits\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.zregsizes-Tuple{T} where T","page":"Operations","title":"MimiqCircuitsBase.zregsizes","text":"zregsizes(operation)\nzregsizes(operationtype)\n\nLength of the zregisters the given operation acts on.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.GATES","page":"Operations","title":"MimiqCircuitsBase.GATES","text":"GATES\n\nList of gates provided by the library.\n\nSingle qubit gates\n\nGateID, GateX, GateY, GateZ, GateH, GateS, GateSDG, GateT, GateTDG, GateSX, GateSXDG. GateSY, GateSYDG.\n\nSingle qubit parametric gates\n\nGateU, GateP, GateRX, GateRY, GateRZ, GateR, GateU1, GateU2, GateU3.\n\nTwo qubit gates\n\nGateCX, GateCY, GateCZ, GateCH, GateSWAP, GateISWAP, GateCS, GateCSDG, GateCSX, GateCSXDG, GateECR, GateDCX,\n\nTwo qubit parametric gates\n\nGateCP, GateCU, GateCRX, GateCRY, GateCRZ, GateRXX, GateRYY, GateRZZ, GateRZX, GateXXplusYY, GateXXminusYY.\n\nMulti qubit Gates\n\nGateCCX, GateC3X, GateCCP, GateCSWAP.\n\nGeneralized gates\n\nThese defines an unitary quantum operation on non fixed number of qubits.\n\nSee GENERALIZED for a list of them.\n\nOperations\n\nSee OPERATIONS for a complete list of operations.\n\nNoise channels\n\nThese define a non-unitary quantum operation based on the Kraus representation.\n\nSee NOISECHANNELS for a list of them.\n\n\n\n\n\n","category":"constant"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.GENERALIZED","page":"Operations","title":"MimiqCircuitsBase.GENERALIZED","text":"GENERALIZED\n\nDefinition of complex unitary quantum opteration on a not fixed number of qubits, or on multiple groups of qubits (registers).\n\nUsually they are initialized with the number of qubits they operate on, or with the size of each group of qubits they act on\n\nQFT, PhaseGradient\n\n\n\n\n\n","category":"constant"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.NOISECHANNELS","page":"Operations","title":"MimiqCircuitsBase.NOISECHANNELS","text":"NOISECHANNELS\n\nList of noise channels provided by the library.\n\nNot mixed-unitary noise channels\n\nKraus, AmplitudeDamping, GeneralizedAmplitudeDamping, PhaseAmplitudeDamping, ThermalNoise, Reset,\n\nMixed-Unitary noise channels\n\nMixedUnitary, PauliNoise, PauliX, PauliY, PauliZ, Depolarizing,\n\n\n\n\n\n","category":"constant"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.OPERATIONS","page":"Operations","title":"MimiqCircuitsBase.OPERATIONS","text":"OPERATIONS\n\nPhases and other unitaries\n\nSee GATES for a complete list unitary gates.\n\nGateCustom\n\nFor gate definitions and calls, see GateDecl and GateCall\n\nOther circuits elements\n\nBarrier, IfStatement\n\nModifiers\n\nControl, Parallel, Power, Inverse\n\nNon-unitary operations\n\nMeasure, MeasureX, MeasureY, MeasureZ, MeasureXX, MeasureYY, MeasureZZ MeasureReset, MeasureResetX, MeasureResetY, MeasureResetZ, Reset,\n\nAlgorithms or complex gate builders\n\nSee GENERALIZED for a complete list of generalized gates or algorithms.\n\n\n\n\n\n","category":"constant"},{"location":"library/mimiqcircuitsbase/operations/#Gates","page":"Operations","title":"Gates","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/operations/","page":"Operations","title":"Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\n    \"gate.jl\",\n    \"operations/gates/standard/sy.jl\",\n    \"operations/pairmeasure.jl\"\n]","category":"page"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.AbstractGate","page":"Operations","title":"MimiqCircuitsBase.AbstractGate","text":"AbstractGate{N} <: AbstractOperator{N}\n\nSupertype for all the N-qubit unitary gates.\n\nSee also hilbertspacedim, inverse, isunitary, matrix, numqubits, opname\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.RescaledGate","page":"Operations","title":"MimiqCircuitsBase.RescaledGate","text":"TODO\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.GateSY","page":"Operations","title":"MimiqCircuitsBase.GateSY","text":"GateSY()\n\nSingle qubit sqrtY gate.\n\nSee also GateSYDG, GateY, Power\n\nMatrix representation\n\noperatornameSY =\nsqrtoperatornameY =\nfrac12\nbeginpmatrix\n    1+i  -1-i \n    1+i  1+i\nendpmatrix\n\nExamples\n\njulia> GateSY()\nSY\n\njulia> matrix(GateSY())\n2×2 Matrix{ComplexF64}:\n 0.5+0.5im  -0.5-0.5im\n 0.5+0.5im   0.5+0.5im\n\njulia> c = push!(Circuit(), GateSY(), 1)\n1-qubit circuit with 1 instructions:\n└── SY @ q[1]\n\njulia> push!(c, GateSY, 2)\n2-qubit circuit with 2 instructions:\n├── SY @ q[1]\n└── SY @ q[2]\n\njulia> power(GateSY(), 2)\nY\n\n\nDecomposition\n\njulia> decompose(GateSY())\n1-qubit circuit with 4 instructions:\n├── S @ q[1]\n├── S @ q[1]\n├── H @ q[1]\n└── U(0,0,0,π/4) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.GateSYDG","page":"Operations","title":"MimiqCircuitsBase.GateSYDG","text":"GateSYDG()\n\nSingle qubit sqrtY^dagger gate (conjugate transpose of the sqrtY gate)\n\nSee also GateSY, GateY, Power, Inverse\n\nMatrix representation\n\noperatornameSYDG =\nsqrtoperatornameY^dagger =\nfrac12\nbeginpmatrix\n    1-i  1-i \n    -1+i  1-i\nendpmatrix\n\nExamples\n\njulia> GateSYDG()\nSY†\n\njulia> matrix(GateSYDG())\n2×2 adjoint(::Matrix{ComplexF64}) with eltype ComplexF64:\n  0.5-0.5im  0.5-0.5im\n -0.5+0.5im  0.5-0.5im\n\njulia> c = push!(Circuit(), GateSYDG(), 1)\n1-qubit circuit with 1 instructions:\n└── SY† @ q[1]\n\njulia> push!(c, GateSYDG, 2)\n2-qubit circuit with 2 instructions:\n├── SY† @ q[1]\n└── SY† @ q[2]\n\njulia> power(GateSYDG(), 2)\n(SY†)^2\n\njulia> inverse(GateSYDG())\nSY\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.MeasureXX","page":"Operations","title":"MimiqCircuitsBase.MeasureXX","text":"MeasureXX()\n\nThe MeasureXX operation measures the joint parity of two qubits in the X-basis, determining whether the qubits are in the same or different states within this basis. The operation begins by applying a controlled-X (CX) gate between the two qubits to entangle them. Following this, a Hadamard (H) gate is applied to the first qubit, rotating it into the X-basis. The second qubit, designated as the target, is then measured to extract the parity information. After the measurement, the Hadamard gate is applied again to the first qubit to reverse the rotation, and a second controlled-X (CX) gate is applied to disentangle the qubits, restoring the system to its original state. Through this sequence, the MeasureXX operation efficiently captures the parity relationship of the qubits in the X-basis.\n\nA result of 0 indicates that the qubits are in the same state, while a result of 1 indicates that they are in different states.\n\nSee Also MeasureYY, MeasureZZ\n\nExamples\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, MeasureXX(), 1, 2, 1)\n2-qubit circuit with 1 instructions:\n└── MXX @ q[1:2], c[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.MeasureYY","page":"Operations","title":"MimiqCircuitsBase.MeasureYY","text":"MeasureYY()\n\nThe MeasureYY operation measures the joint parity of two qubits in the Y-basis, determining whether they are in the same or different states in this basis. This is achieved by first applying an S gate (a π/2 phase shift) to both qubits, followed by a controlled-X (CX) gate. A Hadamard gate (H) is then applied to the first qubit, and the second qubit is measured. To restore the system, a Z gate is applied to the first qubit, followed by another Hadamard gate, another CX gate, and finally another S gate to both qubits. The measurement result reflects whether the qubits are in the same or different states in the Y-basis.\n\nA result of 0 indicates that the qubits are in the same state, while a result of 1 indicates that they are in different states.\n\nSee Also MeasureXX, MeasureZZ\n\nExamples\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, MeasureYY(), 1, 2, 1)\n2-qubit circuit with 1 instructions:\n└── MYY @ q[1:2], c[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.MeasureZZ","page":"Operations","title":"MimiqCircuitsBase.MeasureZZ","text":"MeasureZZ()\n\nThe MeasureZZ operation measures the joint parity of two qubits in the Z-basis. This is achieved by applying a controlled-X (CX) gate, measuring the target qubit, and then applying another CX gate to undo the entanglement. The measurement result indicates whether the qubits are in the same or different states in the Z-basis.\n\nSee Also MeasureYY, MeasureXX\n\nExamples\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, MeasureZZ(), 1, 2, 1)\n2-qubit circuit with 1 instructions:\n└── MZZ @ q[1:2], c[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#Wrappers","page":"Operations","title":"Wrappers","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/operations/","page":"Operations","title":"Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\n    \"operations/control.jl\",\n    \"operations/inverse.jl\",\n    \"operations/power.jl\",\n    \"operations/parallel.jl\",\n    \"operations/ifstatement.jl\",\n]","category":"page"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Control","page":"Operations","title":"MimiqCircuitsBase.Control","text":"Control(numcontrols, gate) <: AbstractGate\n\nControl modifier, similar to OpenQASM 3.0 ctrl @ gate. It wraps a given gate and adds a number of controls to it.\n\nnote: Note\nBy default the first numcontrols qubits are used as controls, and the remaining ones as targets for the wrapped gate.\n\nSee also Power, Inverse, getoperation, iswrapper, numcontrols, numtargets.\n\nExamples\n\njulia> Control(1, GateX())\nCX\n\njulia> Control(3, GateH())\nC₃H\n\njulia> Control(24, GateSWAP())\nC₂₄SWAP\n\nDecomposition\n\nThe default decomposition of a Control gate is build by applying recursively Lemma 7.3 of [1]. This requires to decompose multicontrolled-X gates, which is done recursively, according to Lemma 7.2 and 7.3 of [1].\n\nHere we give a simple example of a decomposition of a C_5T gate.\n\njulia> decompose(Control(3,GateT()))\n4-qubit circuit with 9 instructions:\n├── C(Z^(1//8)) @ q[3], q[4]\n├── C₂X @ q[1:2], q[3]\n├── C((Z^(1//8))†) @ q[3], q[4]\n├── C₂X @ q[1:2], q[3]\n├── C(Z^(1//16)) @ q[2], q[4]\n├── CX @ q[1], q[2]\n├── C((Z^(1//16))†) @ q[2], q[4]\n├── CX @ q[1], q[2]\n└── C(Z^(1//16)) @ q[1], q[4]\n\ndetail: Detail\nSome decompositions have been overrided with optimized versions, to reduce the number of gates used.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Control-Union{Tuple{Operation{N, 0}}, Tuple{N}} where N","page":"Operations","title":"MimiqCircuitsBase.Control","text":"Control(gate)\n\nBuild a controlled gate with 1 control.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.control","page":"Operations","title":"MimiqCircuitsBase.control","text":"control([numcontrols], gate)\n\nBuild a multicontrolled gate.\n\nThe number of controls can be omitted to be lazily evaluated later.\n\nExamples\n\nStandard examples, with all the arguments spefcified.\n\njulia> control(1, GateX())\nCX\n\njulia> control(2, GateX())\nC₂X\n\njulia> control(3, GateCH())\nC₄H\n\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.numcontrols","page":"Operations","title":"MimiqCircuitsBase.numcontrols","text":"numcontrols(control)\n\nNumber of controls of a given multicontrolled gate.\n\nSee also\n\nControl, numtargets, numqubits\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.numtargets","page":"Operations","title":"MimiqCircuitsBase.numtargets","text":"numtargets(control)\n\nGet the number of targets of a given multicontrolled gate.\n\nExamples\n\nnumcontro\n\nSee also\n\nControl, numtargets, numqubits\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Inverse","page":"Operations","title":"MimiqCircuitsBase.Inverse","text":"Inverse(operation)\n\nInverse of the wrapped quantum operation.\n\nThe inversion is not performed right away, but only when the circuit is cached or executed.\n\nSome simplifications are already carried out at construction, for example, Inverse(Inverse(op)) is simplified as Inverse(op).\n\nwarn: Warn\nUsers should not use directly Inverse but the inverse method, which performs already all the simplifications.\n\nSee also inverse, iswrapper, Control, Power.\n\nExamples\n\njulia> Inverse(GateX())\nX†\n\njulia> Inverse(GateH())\nH†\n\njulia> Inverse(GateSX())\nSX†\n\njulia> Inverse(GateCSX())\nCSX†\n\njulia> Inverse(QFT(4))\nQFT†\n\n\nDecomposition\n\nDecomposition of the inverse is carring out by inverting the decomposition of the wrapped operation.\n\njulia> decompose(Inverse(GateCSX()))\n2-qubit circuit with 3 instructions:\n├── H @ q[2]\n├── CU1(-1π/2) @ q[1], q[2]\n└── H @ q[2]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Power","page":"Operations","title":"MimiqCircuitsBase.Power","text":"Power(pow, operation)\n\nWraps an operation and raises it to the given power.\n\nSome simplifications are already carried out at construction, for example Power(pow2, Power(pow1, op)) is simplified as Power(pow1 * pow2, op).\n\nnote: Note\nFor allowing simplifications, always prefer rational powers, such as 1//2 over floating point ones, such as 0.5.\n\nwarn: Warn\nUsers should not use directly Power but the power method, which performs already all the simplifications. Gates should implement the _power method instead.\n\nSee also power, Inverse , inverse.\n\nExample\n\njulia> Power(GateZ(), 1//2)\nS\n\njulia> Power(GateZ(), 2)\nZ^2\n\njulia> Power(GateCH(), 1//2)\nCH^(1//2)\n\njulia> Power(GateCX(), 1//2)\nCX^(1//2)\n\nDecomposition\n\nIn the general case, if a decomposition is not known for a given operation and power, the Power operation is not decomposed.\n\nIf the exponent is an integer, then the gate is decomposed by repeating it.\n\njulia> decompose(Power(GateH(), 2))\n1-qubit circuit with 2 instructions:\n├── H @ q[1]\n└── H @ q[1]\n\njulia> decompose(Power(GateH(), 1//2))\n1-qubit circuit with 1 instructions:\n└── U(1.0471975511966005,-0.9553166181245096,2.1862760354652835,0.16991845472706107) @ q[1]\n\njulia> decompose(Power(GateX(), 1//2)) # same as decomposing GateSX\n1-qubit circuit with 4 instructions:\n├── S† @ q[1]\n├── H @ q[1]\n├── S† @ q[1]\n└── U(0,0,0,π/4) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Parallel","page":"Operations","title":"MimiqCircuitsBase.Parallel","text":"Parallel(repeats, operation)\n\nWrapper that applies the same operation on multiple qubits.\n\nIf the operation is a N-qubit operation, then the resulting operation is applied over N * repeats qubits.\n\nExamples\n\njulia> Parallel(5, GateX())\n⨷ ⁵ X\n\njulia> Parallel(3, GateRX(λ))\n⨷ ³ RX(λ)\n\njulia> Parallel(2, Parallel(3, GateX()))\n⨷ ² (⨷ ³ X)\n\n\nDecomposition\n\nA parallel is decomposed into a sequence of operation, one for each group of qubits.\n\njulia> decompose(Parallel(2, GateX()))\n2-qubit circuit with 2 instructions:\n├── X @ q[1]\n└── X @ q[2]\n\njulia> decompose(Parallel(3, GateSWAP()))\n6-qubit circuit with 3 instructions:\n├── SWAP @ q[1:2]\n├── SWAP @ q[3:4]\n└── SWAP @ q[5:6]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.numrepeats","page":"Operations","title":"MimiqCircuitsBase.numrepeats","text":"numrepeats(paralleloperation)\n\nGet the number of repetitions of a parallel operation.\n\nSee also Parallel.\n\nExamples\n\njulia> numrepeats(Parallel(5, GateX()))\n5\n\njulia> numrepeats(Parallel(3, GateSWAP()))\n3\n\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.parallel","page":"Operations","title":"MimiqCircuitsBase.parallel","text":"parallel(repeats, operation)\n\nBuild a parallel operation.\n\nThe resulting operation is applied over N * repeats qubits.\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.IfStatement","page":"Operations","title":"MimiqCircuitsBase.IfStatement","text":"IfStatement(op, bs::BitString)\n\nApplies the provided operation only if the classical register matches the specified BitString.\n\nIfStatement enables conditional operations in a quantum circuit based on the state of a classical register.  If the classical register's state matches the BitString, the operation (op) is applied to the target qubits.\n\nArguments\n\nop: The quantum operation to apply, such as GateX() or another gate.\nbs: A BitString object representing the target state of the classical register that triggers op.\n\nExamples\n\nBasic Usage\n\njulia> using MimiqCircuitsBase\n\n# Define a condition as a BitString\njulia> condition = BitString(\"01011\")\n5-bits BitString with integer value 26:\n  01011\n\n# Apply GateX only if the condition is met\njulia> if_statement = IfStatement(GateX(), condition)\nIF(c==01011) X\n\n# Add this conditional operation to a circuit\njulia> c = Circuit()\njulia> push!(c, if_statement, 1, 2, 3, 4, 5, 6)\n1-qubit circuit with 1 instructions:\n└── IF(c==01011) X @ q[1], c[2:6]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/operations/#Decompositions","page":"Operations","title":"Decompositions","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/operations/","page":"Operations","title":"Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"decompose.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.decompose","page":"Operations","title":"MimiqCircuitsBase.decompose","text":"decompose(operation)\ndecompose(circuit)\n\nDecompose the given operation or circuit into a circuit of more elementary gates. If applied recursively, it will decompose the given object into a circuit of GateCX and GateU gates.\n\nSee also decompose!.\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.decompose!","page":"Operations","title":"MimiqCircuitsBase.decompose!","text":"decompose!(circuit, operation[, qtargets, ctargets])\n\nIn place version of decompose.\n\nIt decomposes the given object, appending all the resulting operations to the given circuit. The optional qtargets and ctargets arguments can be used to map the qubits and classical bits of the decomposed operation to the ones of the target circuit.\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/operations/#Classical-operations","page":"Operations","title":"Classical operations","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/operations/","page":"Operations","title":"Operations","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages = [\"operations/classical/not.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.Not","page":"Operations","title":"MimiqCircuitsBase.Not","text":"struct Not <: Operation{0,1,0}\n\n\n\n\n\n","category":"type"},{"location":"manual/simulation/#Simulating-circuits","page":"Simulating Circuits","title":"Simulating circuits","text":"","category":"section"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"This page provides information on how MIMIQ simulates quantum circuits.","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"Simulating circuits\nSimulator backends\nState Vector\nMatrix-Product States\nFidelity and Error estimates\nUnderstanding sampling","category":"page"},{"location":"manual/simulation/#Simulator-backends","page":"Simulating Circuits","title":"Simulator backends","text":"","category":"section"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"To execute quantum circuits with MIMIQ you can use different simulator backends, i.e. different numerical methods to apply operations to the state of the qubits. Here we give a short introduction into these methods.","category":"page"},{"location":"manual/simulation/#State-Vector","page":"Simulating Circuits","title":"State Vector","text":"","category":"section"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"The pure quantum state of a system of N qubits can be represented exactly by 2N complex numbers. The state vector method consists in explicitly storing the full state of the system and evolving it exactly as described by the given quantum algorithm. The method can be considered exact up to machine precision errors (due to the finite representation of complex numbers on a computer). Since every added qubit doubles the size of the state, this method is practically impossible to be used on systems > 50 qubits. On a laptop with 8GB of free RAM, only 28-29 qubits can be simulated.","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"On our current remote service, we can simulate circuits of up to 32 qubits with this method. Premium plans and on-premises solutions are designed to increase this limit. If you are interested, contact us at contact@qperfect.io.","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"Our state vector simulator is highly optimized for simulation on a single CPU, delivering a significant speedup with respect to publicly available alternatives.","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"Performance Tips:","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"The efficiency of the state vector simulator can depend on the specific way that the circuit is implemented. Specifically, it depends on how gates are defined by the user. The most important thing is to avoid using GateCustom whenever possible, and instead use specific gate implementations. For example, use GateX() instead of GateCustom([0 1; 1 0]), and use CU(...) instead of GateCustom([1 0 0 0; 0 1 0 0; 0 0 U_{11} U_{12}; 0 0 U_{21} U_{22}]).","category":"page"},{"location":"manual/simulation/#Matrix-Product-States","page":"Simulating Circuits","title":"Matrix-Product States","text":"","category":"section"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"Matrix-Product States algorithms were originally developed within the field of many-body quantum physics (see Wikipedia article and references therein), and offer an alternative approach to scale up the size of simulations. Instead of tracking the entire state, MPS captures the entanglement structure efficiently. This method excels in scenarios where entanglement is localized, offering computational advantages and reducing memory requirements compared to state vector simulations. The benefits of MPS include its ability to simulate larger quantum systems and efficiently represent states with substantial entanglement. However, challenges arise when dealing with circuits that exhibit extensive long-range entanglement.","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"Our MPS simulator is optimized for speed of execution and fidelity. For entanglement bound circuits MPS can calculate circuits of even hundreds of qubits exactly. For circuits with too much entanglement MPS calculates approximate solutions and provides a lower bound estimate of the real fidelity of the calculation (see next section).","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"Performance Tips:","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"The efficiency of the MPS simulation can depend on implementation details. To optimize performance, you can vary the following parameters that specify the level of approximation and compression (see also Execution page):","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"Bond dimension (bonddim): The bond dimension specifies the maximal dimension of the matrices that appear in the MPS representation. Choosing a larger bonddim means we can simulate more entanglement, which leads to larger fidelities, at the cost of more memory and typically longer run times. However, when bonddim is chosen large enough that the simulation can be run exactly, then it generally runs much faster than lower bond dimensions. The default is 256.\nEntanglement dimension (entdim): The entanglement dimension is related to the way gates are applied to the state. In some cases, a large entdim can lead to better compression and thus shorter runtimes, at the potential cost of more memory. In others, a lower entdim is more favourable. The default is 16.","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"Moreover, the performance of MPS, especially the bond dimension required, also depends on the specific way that circuits are implemented. Here are some general tips:","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"Qubit ordering: The most crucial choice that affects MPS performance is the ordering of qubits in the circuit. If we have qubits 1 to N, it matters which qubit of the algorithm has which index. Ideally, the indices should be chosen such that qubits that are strongly entangled during the circuit are close to each other, i.e. small |i-j| where i and j are indices. When a good ordering is chosen, this will translate into lower bond dimensions.\nGate ordering: In nature, the order of transversal gates, or gates that commute with each other, does not play a role. However, for MPS it can change the performance. The reason is that in a simulation we typicall apply gates, even transversal ones, sequentially. During the application of the gates, the entanglement of the intermediate state can depend on the order in which the gates are applied. Thus, experimenting with different gate orderings can lead to better performance, typically because of lower bond dimensions.","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"You can access the bond dimensions of the state during execution through BondDim, see also page on entanglement. This can be helpful to understand the effect of different optimizations.","category":"page"},{"location":"manual/simulation/#Fidelity-and-Error-estimates","page":"Simulating Circuits","title":"Fidelity and Error estimates","text":"","category":"section"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"Since we allow for the execution of circuits on MIMIQ with non exact methods (MPS), we return always a fidelity estimate for each execution.","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"Fidelity in this case is defined as the squared modulus of the overlap between the final state obtained by the execution and the ideal one. It is a number between 0 and 1, where 1 means that the final state is exactly the one we wanted to obtain.","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"The fidelity will always be 1.0 for exact methods (State Vector), but it can be less than that for non exact methods.","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"In the case of MPS methods, the number returned is an estimate of the actual fidelity of the state. More specifically, it is a lower bound for the fidelity, meaning that the actual fidelity will always be larger or equal to the number reported. For example, if the fidelity is 0.8 it means that the state computed by MPS has at least an 80% overlap with the real solution.","category":"page"},{"location":"manual/simulation/#Understanding-sampling","page":"Simulating Circuits","title":"Understanding sampling","text":"","category":"section"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"When running a circuit with MIMIQ we compute and return measurement samples, among other quantities (see Cloud Execution section). Which measurement samples are returned depends on the type of circuit executed. There are three fundamental cases based on the presence of non-unitary operations such as measurements (Measure...), resets (Reset), if statements (IfStatement), or noise.","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"No non-unitary operations","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"In this case the circuit is executed only once and the final state is sampled as many times as specified by the  number of samples (nsamples) parameter of the execution. The sampled value of all the qubits is returned (in the obvious ordering).","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"No mid-circuit measurements and no non-unitary operations","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"In this case the circuit is executed only once again, and the final state is sampled as many times as specified by nsamples, but only the sampled value of all the classical bits used in the circuit is returned (usually the targets of the measurements at the end of the circuit).","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"Mid-circuit measurements or non-unitary operations","category":"page"},{"location":"manual/simulation/","page":"Simulating Circuits","title":"Simulating Circuits","text":"In this case the circuit is executed nsamples times, and the final state is sampled only once per run. The sampled value of all the classical bits used in the circuit is returned.","category":"page"},{"location":"manual/special_topics/#Special-Topics","page":"Special Topics","title":"Special Topics","text":"","category":"section"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"This page provides detailed information on specialized functionalities in MIMIQ.","category":"page"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"Special Topics\nBitString\nUsing BitString in MIMIQ Operations\nConstructors\nAccessing and Modifying Bits\nConversion and Manipulation Methods\nBitwise Operators\nConcatenation and Repetition","category":"page"},{"location":"manual/special_topics/#BitString","page":"Special Topics","title":"BitString","text":"","category":"section"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"The BitString class represents the state of bits and can be used to represent classical registers with specified values for each bit (0 or 1). At its core, it is simply a vector of Bools. BitString allows direct bit manipulation, bitwise operations, and conversion to other data formats like integers. It’s designed for flexibility in binary manipulation tasks within quantum computations.","category":"page"},{"location":"manual/special_topics/#Using-BitString-in-MIMIQ-Operations","page":"Special Topics","title":"Using BitString in MIMIQ Operations","text":"","category":"section"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"In MIMIQ, several operations use BitString as a direct input for conditional logic or specific quantum operations, such as IfStatement and Amplitude, see non-unitary operations and statistical operations pages. Here are some examples:","category":"page"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"using MimiqCircuits # hide\n\n# Conditional Operation: IfStatement\nif_statement = IfStatement(GateX(), BitString(\"01011\"))\n\n# Amplitude Operation\nAmplitude(BitString(\"001\"))","category":"page"},{"location":"manual/special_topics/#Constructors","page":"Special Topics","title":"Constructors","text":"","category":"section"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"BitStrings can be constructed in different ways.","category":"page"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"From a String: You can use the BitString(\"binary_string\") to initialize a BitString by parsing a string in binary format.\nusing MimiqCircuits # hide\n\n# Initialize a BitString from a binary string representation\nBitString(\"1101\")\nAlternatively, you can use the syntax bs\"binary_string\" to create the same BitString.\nusing MimiqCircuits # hide\n\n# Initialize a BitString using the bs\"...\" literal syntax\nbs\"01\"\nFrom bit locations: You can use the BitString(numbits[; bit_indices]) syntax to initialize a BitString of numbits bits, setting specific bits indicated by bit_indices to 1.\nusing MimiqCircuits # hide\n\n# Initializing with Specific Bits\nBitString(8, [2, 4, 6])\nFrom a function: You can use the BitString(f::Function, numbits) syntax to initialize a BitString with numbits, where each bit is set based on the result of the provided function f applied on each index.\nusing MimiqCircuits # hide\n\n# Initialize an 8-bit BitString where bits are set based on even indices\nBitString(8) do i\n        iseven(i)\n      end","category":"page"},{"location":"manual/special_topics/#Accessing-and-Modifying-Bits","page":"Special Topics","title":"Accessing and Modifying Bits","text":"","category":"section"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"Each bit in a BitString can be accessed or modified individually in the same way as vectors, making it easy to retrieve or set specific bit values.","category":"page"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"using MimiqCircuits # hide\n\n# Accessing a Bit\nbs=BitString(4, [1, 3])\n\nprintln(bs[2])\n\n# Modifying a Bit\nbs[2] = true\n\nbs","category":"page"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"A useful function is nonzeros which returns the indices of the non-zero bits in a BitString.","category":"page"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"  using MimiqCircuits # hide\n\n  bs = BitString(6, [1, 3, 5]) # hide\n\n  # Retrieve Non-Zero Indices\n  nonzeros(bs)","category":"page"},{"location":"manual/special_topics/#Conversion-and-Manipulation-Methods","page":"Special Topics","title":"Conversion and Manipulation Methods","text":"","category":"section"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"The BitString class includes functionality for conversion to integer representations, indexing, and other methods for retrieving and manipulating bit values:","category":"page"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"BitString to Integer: To convert a BitString into its integer representation, you can use the function bitstring_to_integer. By default it uses a big-endian order.\nusing MimiqCircuits # hide\nbs = BitString(\"101010\")\n\n# Convert BitString to Integer (big-endian by default)\nbitstring_to_integer(bs)\nAlternatively, you can use the function bitstring_to_index, which converts a BitString to an index for purposes like vector indexing, checking bounds, and compatibility with 64-bit indexing constraints. It's essentially the same as bitstring_to_integer but shifted by 1.\nusing MimiqCircuits # hide\nbs = BitString(\"101010\")\n\n# Convert BitString to Index (Offset by 1 for Julia's 1-based indexing)\nbitstring_to_index(bs)\nBitString to String: To convert a BitString into a String of \"0\" and \"1\" characters, you can use the function to01.\nusing MimiqCircuits # hide\nbs = BitString(\"101010\")\n\n# Convert BitString to String of \"0\"s and \"1\"s (big-endian)\nprintln(to01(bs))\n\n# Convert BitString to String of \"0\"s and \"1\"s (little-endian)\nto01(bs, endianess=:little)","category":"page"},{"location":"manual/special_topics/#Bitwise-Operators","page":"Special Topics","title":"Bitwise Operators","text":"","category":"section"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"BitString supports bitwise operations such as NOT, AND, OR, XOR, as well as bitwise shifts:","category":"page"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"Bitwise NOT: ~\n  using MimiqCircuits # hide\n  bs = BitString(\"1011\")\n\n  # Bitwise NOT\n  ~bs\nBitwise AND and OR: &, |\n  using MimiqCircuits # hide\n  bs1 = BitString(\"1100\")\n  bs2 = BitString(\"0110\")\n\n  # Bitwise AND\n  bs1 & bs2\n  # Bitwise OR\n  bs1 | bs2\nBitwise XOR: ⊻\n  using MimiqCircuits # hide\n  bs1 = BitString(\"1100\") # hide\n  bs2 = BitString(\"0110\") # hide\n\n  # Bitwise XOR\n  bs1 ⊻ bs2\nLeft Shift: <<, and Right Shift: >>\n  using MimiqCircuits # hide\n  bs1 = BitString(\"1100\") # hide\n  bs2 = BitString(\"0110\") # hide\n\n  # Left Shift\n  bs << 1\n  # Right Shift\n  bs >> 1","category":"page"},{"location":"manual/special_topics/#Concatenation-and-Repetition","page":"Special Topics","title":"Concatenation and Repetition","text":"","category":"section"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"BitString supports concatenation and repetition, allowing you to combine or extend bitstrings efficiently:","category":"page"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"Concatenation: Use vcat to combines two BitString objects by appending the bits of rhs to lhs.\nRepetition: Use repeat to repeats the BitString a specified number of times, creating a new BitString with the pattern repeated.","category":"page"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"Examples:","category":"page"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"using MimiqCircuits # hide\n\n# Define two BitString objects\nbs1 = BitString(\"1010\")\nbs2 = BitString(\"0101\")\n\n# Concatenate bs1 and bs2\nvcat(bs1, bs2)","category":"page"},{"location":"manual/special_topics/","page":"Special Topics","title":"Special Topics","text":"# Repeat bs1 two times\nrepeat(bs1, 2)","category":"page"},{"location":"library/function_index/#main-index","page":"Function Index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function Index","title":"Function Index","text":"Pages = [\n    \"mimiqcircuits.md\",\n    \"mimiqlink.md\",\n    \"mimiqcircuitsbase/general.md\",\n    \"mimiqcircuitsbase/circuits.md\",\n    \"mimiqcircuitsbase/operations.md\",\n    \"mimiqcircuitsbase/standard.md\",\n    \"mimiqcircuitsbase/generalized.md\",\n    \"mimiqcircuitsbase/other.md\",\n    \"mimiqcircuitsbase/bitstrings.md\",\n    \"mimiqcircuitsbase/noise.md\",\n    \"mimiqcircuitsbase/operators.md\",\n    \"internals.md\",\n]","category":"page"},{"location":"library/mimiqcircuitsbase/results/#Quantum-Circuit-Simulation-Results","page":"Quantum Circuit Simulation Results","title":"Quantum Circuit Simulation Results","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/results/","page":"Quantum Circuit Simulation Results","title":"Quantum Circuit Simulation Results","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"qcsresults.jl\"]","category":"page"},{"location":"library/mimiqcircuitsbase/results/#MimiqCircuitsBase.QCSResults","page":"Quantum Circuit Simulation Results","title":"MimiqCircuitsBase.QCSResults","text":"QCSRresults()\nQCSRresults(simulator, version, fidelities, avggateerrors, cstates, zstates, amplitudes, timings)\n\nStorage for the results of a quantum circuit simulation.\n\nFields\n\nsimulator: name of the simulator used,\nversion: version of the simulator used,\nfidelities: fidelity estimates,\navggateerrors: average multiqubit gate errors,\ncstates: classical states content,\nzstates: complex valued states content (not used),\namplitudes: amplitudes,\ntimings: precise timings of the execution.\n\n\n\n\n\n","category":"type"},{"location":"manual/import_export/#Import-and-export-circuits","page":"Import & Export Circuits","title":"Import and export circuits","text":"","category":"section"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"In this section we introduce different options to import and export circuits. In particular, MIMIQ allows to import circuits in well-known languages such as OpenQASM and Stim, as well as save and import circuits using its own ProtoBuf structure.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"Import and export circuits\nProtoBuf\nExport ProtoBuf files from MIMIQ\nImport ProtoBuf file to MIMIQ\nOpenQASM\nExecute OpenQASM file in MIMIQ\nBehaviour of include files\nRelations between OpenQASM registers and MIMIQ indices\nStim\nExecute Stim file on MIMIQ","category":"page"},{"location":"manual/import_export/#ProtoBuf","page":"Import & Export Circuits","title":"ProtoBuf","text":"","category":"section"},{"location":"manual/import_export/#Export-ProtoBuf-files-from-MIMIQ","page":"Import & Export Circuits","title":"Export ProtoBuf files from MIMIQ","text":"","category":"section"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"After building a circuit in MIMIQ you can export it into a ProtoBuf format using the saveproto function. You need to give it two arguments, the name of the file to create (.pb format) and the circuit to save.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"saveproto(\"my_circuit.pb\", circuit)","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"The same method allows you to save your simulation results in a ProtoBuf file.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"# get the results\nresults = getresults(conn, job)\n# save the results\nsaveproto(\"my_results.pb\", results)","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"note: Note\nProtoBuf is a serialized file format developed by google. It is very lightweight and efficient to parse. Check the  ProtoBuf repository for more information.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"note: Note\nYou can only export a circuit into ProtoBuf format and cannot export an OpenQASM or Stim file in the current version of MIMIQ.","category":"page"},{"location":"manual/import_export/#Import-ProtoBuf-file-to-MIMIQ","page":"Import & Export Circuits","title":"Import ProtoBuf file to MIMIQ","text":"","category":"section"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"MIMIQ allows you to import ProtoBuf files using the loadproto function. With this function you can get previously saved circuit or get previous simulation results. You need to give this function the name of the file to parse and the type of object to parse.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"# Import circuit from ProtoBuf to MIMIQ\ncircuit = loadproto(\"my_circuit.pb\", Circuit) # Do not instatiate the Circuit\n\n# Import results from ProtoBuf to MIMIQ\nresults = loadproto(\"my_results.pb\", QCSResults)","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"details: Details\nAlternatively to import results you can also use the loadresults function.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"The circuit imported with loadproto can be manipulated like any other circuit on MIMIQ to add or insert gates, see circuit page.","category":"page"},{"location":"manual/import_export/#OpenQASM","page":"Import & Export Circuits","title":"OpenQASM","text":"","category":"section"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"Open Quantum Assembly Language is a programming language designed for describing quantum circuits and algorithms for execution on quantum computers. It is a very convenient middle ground for different quantum computer architectures to interpret and execute circuits.","category":"page"},{"location":"manual/import_export/#Execute-OpenQASM-file-in-MIMIQ","page":"Import & Export Circuits","title":"Execute OpenQASM file in MIMIQ","text":"","category":"section"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"The remote MIMIQ services can readily process and execute OpenQASM files, thanks to fast and feature-complete Julia and C++ parsers and interpreters.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"Here is a simple comprehensive example of executing a QASM file on MIMIQ.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"using MimiqCircuits # hide\nusing Plots # hide\nstr_name = get(ENV, \"MIMIQCLOUD\", nothing) # hide\nnew_url = # hide\n    str_name == \"QPERFECT_CLOUD\" ? QPERFECT_CLOUD : # hide\n    str_name == \"QPERFECT_CLOUD2\" ? QPERFECT_CLOUD2 : # hide\n    isnothing(str_name) ? QPERFECT_CLOUD : # hide\n    str_name # hide\nconn = connect(ENV[\"MIMIQUSER\"], ENV[\"MIMIQPASS\"]; url=new_url) # hide\n# after connecting to MIMIQ\n#\n# ...\n\nqasm = \"\"\"\n// Implementation of Deutsch algorithm with two qubits for f(x)=x\n// taken from https://github.com/pnnl/QASMBench/blob/master/small/deutsch_n2/deutsch_n2.qasm\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\n\nqreg q[2];\ncreg c[2];\n\nx q[1];\nh q[0];\nh q[1];\ncx q[0],q[1];\nh q[0];\nmeasure q[0] -> c[0];\nmeasure q[1] -> c[1];\n\"\"\"\n\n# Write the OPENQASM as a file\nopen(\"/tmp/deutsch_n2.qasm\", \"w\") do io\n    write(io, qasm)\nend\n\n# actual execution of the QASM file\njob = executeqasm(conn, \"/tmp/deutsch_n2.qasm\"; algorithm=\"statevector\")\nres = getresult(conn, job)\nplot(res)","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"For more informations, read the documentation of execute and check the remote execution page.","category":"page"},{"location":"manual/import_export/#Behaviour-of-include-files","page":"Import & Export Circuits","title":"Behaviour of include files","text":"","category":"section"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"A common file used by many QASM files is the qelib1.inc file. This file is not defined as being part of OpenQASM 2.0, but its usage is so widespread that it might be considered as de-facto part of the specifications.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"details: Details\nWe remind the careful reader that OpenQASM 2.0 specifications only define 6 operations: U,CX, measure, reset, barrier and if.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"If we were to parse every file together with qelib1.inc, we would have at the end just a list of simple U and CX gates, leaving behind any speed improvement that we would gain by using more complex gates as blocks. For this reason, if you don't explicitly provide the include files, MIMIQ will not parse the usual qelib1.inc file but will instead use a simplified version of it, where almost all gate definitions are replaced by opaque definitions. These opaque definitions will be converted to the corresponding MIMIQ gates listed in GATES.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"Another alternative is to use the mimiqlib.inc directly in your file. For now it's almost a copy of the modified qelib1.inc but in the future it will be extended to contain more gates and operations, diverging from qelib1.inc.","category":"page"},{"location":"manual/import_export/#Relations-between-OpenQASM-registers-and-MIMIQ-indices","page":"Import & Export Circuits","title":"Relations between OpenQASM registers and MIMIQ indices","text":"","category":"section"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"During the parsing of the QASM file, we will assign a unique index to each qubit and classical bit. This index will be used to identify the qubit or bit in the MIMIQ service. The indices are assigned in the following way:","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"The first qubit is assigned index 1 (Julia), the second 2, and so on.\nAll registers retain the same ordering as in the QASM file.\nQubits and classical bits behave similarly but each has its own sequence of indices, starting from 1.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"A simple example will clarify this behaviour:","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"OPENQASM 2.0;\nqreg q[2];\ncreg m[10];\nqreg a[10];\ncreg g[2];","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"Will be parsed as:","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"QASM name MIMIQ Qubit index MIMIQ Bit index\nq[0] 1 \nq[1] 2 \na[0] 3 \na[1] 4 \n... ... ...\na[9] 12 \nm[0]  1\nm[1]  2\n... ... ...\nm[9]  10\ng[0]  11\ng[1]  12","category":"page"},{"location":"manual/import_export/#Stim","page":"Import & Export Circuits","title":"Stim","text":"","category":"section"},{"location":"manual/import_export/#Execute-Stim-file-on-MIMIQ","page":"Import & Export Circuits","title":"Execute Stim file on MIMIQ","text":"","category":"section"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"Stim is a fast stabilizer circuit simulator commonly used for Clifford circuit simulation. Stim allows users to export their circuit to a text format usually with the .stim extension. The remote MIMIQ services can readily process and execute Stim files as follows:","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"job = execute(conn, \"my_stim_circuit.stim\")","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"warning: Warning\nThe support of Stim is still in progress and some of the most specific Stim features are not supported. For instance, detectors will be completely ignored by MIMIQ at exectution time.","category":"page"},{"location":"manual/import_export/","page":"Import & Export Circuits","title":"Import & Export Circuits","text":"The results of the simulation can be accessed as usual on MIMIQ, see remote execution page.","category":"page"},{"location":"manual/remote_execution/#Execution-on-MIMIQ","page":"Cloud Execution","title":"Execution on MIMIQ","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"This page provides detailed information on how to execute quantum circuits on MIMIQ's remote services. Use the following links to navigate through the sections:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Execution on MIMIQ\nCloud Service\nOverview\nJob Management\nTerms of Service\nUser Management\nConnecting to server for sending jobs\nCredentials\nTokens\nExecution\nResults\nGetting results (Cloud server)\nGetting results (Julia session)\nFormat of Results\nPlotting results\nSaving and loading results\nUseful Job Management Features\nCheck job status\nList all jobs\nGet inputs","category":"page"},{"location":"manual/remote_execution/#Cloud-Service","page":"Cloud Execution","title":"Cloud Service","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"MIMIQ provides remote execution of quantum circuits via its cloud services, allowing users to run quantum jobs on high-performance infrastructure. You can connect to the cloud server by providing your credentials and accessing the MIMIQ cloud URL at [https://mimiq.qperfect.io/sign-in].","category":"page"},{"location":"manual/remote_execution/#Overview","page":"Cloud Execution","title":"Overview","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"The MIMIQ Cloud Service offers multiple features for managing job executions, user roles, and organizational access. Below is a screenshot of the Cloud Dashboard that you will find in the server website.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"(Image: Cloud Dashboard)","category":"page"},{"location":"manual/remote_execution/#Job-Management","page":"Cloud Execution","title":"Job Management","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"The Job Management or Executions section provides a comprehensive view of all quantum jobs submitted. Users can track the status of their jobs, cancel jobs, retrieve results and view detailed information, including start time, completion time, and current status. For Organization Managers, additional features are available:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"View Other Users' Jobs: Organization managers can view jobs submitted by all users in their organization, allowing them to monitor the workload.\nCancel Jobs: Managers also have the ability to cancel any job within their organization if necessary, providing greater control over resource management.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"This section is essential for both tracking the progress of jobs and managing computational resources effectively.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Job status","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"The Status tab allows you to filter jobs based on their status. By clicking on the tab, you can select a specific status (e.g., NEW), and then click on the Search button to view all jobs that match the selected status.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"When a job is submitted to the MIMIQ cloud services, it goes through various status stages:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"NEW: When a job is initially submitted, its status is marked as NEW, indicating that it has entered the queue but has not started executing yet. In this stage, the job is waiting for previous jobs in the queue to complete, whether they finish successfully or encounter errors.\nRUNNING: Once all prior jobs are completed, your job will begin execution, and its status will change to RUNNING. At this point, the job is actively being processed by the MIMIQ engine, either by the statevector simulator or MPS algorithm, depending on the job configuration.\nDONE: Upon successful completion, the job status changes to DONE, indicating that the quantum circuit has finished executing and the results are available for retrieval.\nERROR: If the job encounters an issue during execution, such as exceeding the time limit or encountering hardware or software errors, its status will change to ERROR. Users can then review the error logs to diagnose the problem. You can also hover your mouse over the word ERROR and a short error message will appear.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Job ID","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"The ID tab shows a unique identifier for each job. This identifier can be used to retrieve results using getresults, see results section.","category":"page"},{"location":"manual/remote_execution/#Terms-of-Service","page":"Cloud Execution","title":"Terms of Service","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"When an Organization Manager first connects to the server they need to accept the Terms of Service in order to activate the cloud subscription. The organization users will then be able to send jobs. The Terms of Service is also available for the users to read it.","category":"page"},{"location":"manual/remote_execution/#User-Management","page":"Cloud Execution","title":"User Management","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"The User Management section is available exclusively to users with the Organization Manager role.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Key features of user management include:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Adding New Users: Organization managers can invite new users to join their organization, enabling them to submit jobs. However, there is a limit to how many users can be added based on the organization’s plan.\nRole Management: Organization managers can assign roles and manage permissions within their team, ensuring that the right users have the necessary access to cloud resources.","category":"page"},{"location":"manual/remote_execution/#Connecting-to-server-for-sending-jobs","page":"Cloud Execution","title":"Connecting to server for sending jobs","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"In order to execute a circuit in the remote, you first need to connect to it, see also quickstart page.","category":"page"},{"location":"manual/remote_execution/#Credentials","page":"Cloud Execution","title":"Credentials","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"You can connect to the MIMIQ server using the connect function and providing your credentials (username and password). If you do not supply your credentials directly in the function call, you will be redirected to a localhost page where you can securely enter your credentials. This method is preferred for better security, as it avoids storing your username and password in the script.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"# Connect to the server (opens a browser for login)\nconn = connect()\n\n# Connect using Credentials directly\nconn = connect(\"your_username\", \"your_password\")","category":"page"},{"location":"manual/remote_execution/#Tokens","page":"Cloud Execution","title":"Tokens","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Instead of using your credentials every time you connect to the MIMIQ services, you can authenticate once and save a token. This token can be saved to a JSON file and reused across different sessions, making it a secure and efficient way to manage authentication.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"How Token Authentication Works:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"First Authentication: You log in once using your credentials (via browser or directly), and the token is generated.\nSaving the Token: You can save this token in a JSON file using the savetoken method.\nLoading the Token: Later, you can load the saved token with the loadtoken method to reconnect without providing your credentials again.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"This is a safer method, as it avoids hardcoding sensitive information like passwords in your scripts.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"After authentication, this is how it looks:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"# Save the token to a file (example_token.json)\nsavetoken(\"example_token.json\")\n\n# Load the token from a saved file to reconnect\nconn = loadtoken(\"example_token.json\")","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"You can also accomplish all at once (connecting through a token if possible, otherwise connecting via the browser and then saving the token) using this code block:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"conn = try\n    loadtoken()\ncatch\n    savetoken()\n    loadtoken()\nend","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"note: Note\nTokens stay valid only for one day.","category":"page"},{"location":"manual/remote_execution/#Execution","page":"Cloud Execution","title":"Execution","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"MIMIQ supports sending quantum circuits to its remote services for execution either as a single circuit or in batch mode, i.e. multiple circuits at once. In both cases, circuits are initialized in the zero state, and results are obtained by running the circuit and sampling.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"You can submit one or multiple circuits for execution using the execute function, which can be called as execute(connection, circuits; kwargs...). This unified interface simplifies quantum job management, whether you're running a single job or a batch of jobs.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Parameters:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"connection: The connection object used to communicate with the MIMIQ remote services.\ncircuit(s): A single quantum circuit or a list of circuits. These can be provided as MIMIQ Circuit objects or paths to valid .pb, .qasm or .stim files. See Import and Export and circuits pages.\nkwargs...: Additional options to customize execution:\nlabel: A descriptive name for the simulation or batch.\nalgorithm: The backend method to perform the simulation: \"auto\", \"statevector\", or \"mps\". The default is \"auto\", which automatically selects between the statevector or MPS algorithm, depending on the circuit sent. See simulation page for more information.\nnsamples: Number of measurement samples to generate (default: 1000, maximum: 65536). See simulation for details on sampling.\nbitstrings: A list of bitstrings to compute amplitudes for. This is equivalent to adding an Amplitude operation at the end of the circuit, see amplitudes section. The results will be stored at the end of the Z-register.\ntimelimit: Maximum execution time in minutes (default: 30).\nbonddim: Bond dimension for MPS (default: 256). See simulation page.\nentdim: Entangling dimension for MPS (default: 16). See simulation page.\nseed: Seed for random number generator.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Return type: Jobs:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"It is important to note that the execute function returns an object of type Execution. This object can then be passed to other functions to get results or status updates (see results and job management sections). However, if for some reason we lose access to this object, or we simply want to connect to the same job in a different session, we can do so like this:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"job = Execution(\"job-id\")","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Here, \"job-id\" is the unique identifier of the job, which you can find in the dashboard of the web interface, see cloud service section.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Example:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"using MimiqCircuits # hide\nstr_name = get(ENV, \"MIMIQCLOUD\", nothing) # hide\nnew_url = # hide\n    str_name == \"QPERFECT_CLOUD\" ? QPERFECT_CLOUD : # hide\n    str_name == \"QPERFECT_CLOUD2\" ? QPERFECT_CLOUD2 : # hide\n    isnothing(str_name) ? QPERFECT_CLOUD : # hide\n    str_name # hide\nconn = connect(ENV[\"MIMIQUSER\"], ENV[\"MIMIQPASS\"]; url=new_url) # hide\n# Prepare multiple circuits and execute them in batch mode # hide\n\n# Prepare circuits\nc1 = Circuit()\nc2 = Circuit()\n\n# Add gates to the circuits\npush!(c1, GateX(), 1)\npush!(c2, GateH(), 2)\n\n# Execute Single circuit\njob_single = execute(conn, c1; nsamples=1000, label=\"Single_run\")\n\n# Execute circuits in batch mode\njob_batch = execute(conn, [c1, c2]; nsamples=1000, label=\"batch_run\")","category":"page"},{"location":"manual/remote_execution/#Results","page":"Cloud Execution","title":"Results","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"After submitting executions, you can retrieve your simulation results in two different ways: through the cloud server, or from your Julia session.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"warning: Warning\nThe job results will be deleted from the remote server after some time, so make sure to retrieve them in time. Contact your organization manager to understand how long results will be stored in the server. Note also that results will be deleted after a shorter period of time once the user has downloaded them at least once.","category":"page"},{"location":"manual/remote_execution/#Getting-results-(Cloud-server)","page":"Cloud Execution","title":"Getting results (Cloud server)","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"You can download results directly from the cloud server web interface by clicking the box under the Resulted files tab, see cloud server section. This will download a Protobuf file (.pb) and save it locally. The results can then be loaded to your Julia session using the loadproto function. ","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"To learn more about Protobuf and how to save/load results, check out the import & export page, and the saving and loading results section.","category":"page"},{"location":"manual/remote_execution/#Getting-results-(Julia-session)","page":"Cloud Execution","title":"Getting results (Julia session)","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"You can download results from your Julia session using two functions: getresult and getresults.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"The only difference between the two is that getresults retrieves the results of all the circuits sent in a job, whereas getresult only returns the result of the first circuit making it a more lightweight version. This is useful if you want to peek at the results before all circuits of a given job have finished. (If only one circuit was sent then there's no difference.)","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"They are both called in a similar way as getresults(connection, execution; kwargs...).","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Parameters:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"connection (Connection): The active connection to the MIMIQ services, see connection section.\nexecution (Execution): The execution object representing the job whose results are to be fetched, see execution section. If you saved the output of execute then you can pass it to getresults (see example below). If you didn't save it, then you can copy the job ID from the Cloud server (see cloud service section) and pass it to getresults as Execution(\"job-id\").\ninterval (Int): Time interval in seconds between calls to the remote to check for job completion (default: 1 second). A shorter interval results in more frequent checks, while a longer interval reduces the frequency of status checks, saving computational resources.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"warning: Warning\nBoth getresults and getresult block further code execution until the job requested has finished. If you want to check the status of the job before attempting to retrieve results, we recommend using isjobdone, see job management section.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"note: Note\ngetresult internally calls getresults but only returns the first result if multiple results are retrieved.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Example:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"using MimiqCircuits # hide\nstr_name = get(ENV, \"MIMIQCLOUD\", nothing) # hide\nnew_url = # hide\n    str_name == \"QPERFECT_CLOUD\" ? QPERFECT_CLOUD : # hide\n    str_name == \"QPERFECT_CLOUD2\" ? QPERFECT_CLOUD2 : # hide\n    isnothing(str_name) ? QPERFECT_CLOUD : # hide\n    str_name # hide\nconn = connect(ENV[\"MIMIQUSER\"], ENV[\"MIMIQPASS\"]; url=new_url) # hide\n# Prepare multiple circuits and execute them in batch mode # hide\n\n# Prepare circuits # hide\nc1 = Circuit() # hide\nc2 = Circuit() # hide\n\n# Add gates to the circuits # hide\npush!(c1, GateX(), 1) # hide\npush!(c2, GateH(), 2) # hide\n\n# Execute Single circuit # hide\njob_single = execute(conn, c1; nsamples=1000, label=\"Single_run\") # hide\n\n# Execute circuits in batch mode # hide\njob_batch = execute(conn, [c1, c2]; nsamples=1000, label=\"batch_run\") # hide\n\n# Getting the Results\nres_single = getresult(conn, job_single)\nres_batch = getresults(conn, job_batch)","category":"page"},{"location":"manual/remote_execution/#Format-of-Results","page":"Cloud Execution","title":"Format of Results","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"When you retrieve jobs results, you will get back a QCSResults object (when using getresult) or a Vector{QCSResults} (when using getresults). Each QCSResults object contains information about job executed. You can get an overview by printing it:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"QCSResults:\n├── simulator: MIMIQ-StateVector 0.14.1\n├── timings:\n│    ├── total time: 0.00036376400000000004s\n│    ├── compression time: 4.792e-06s\n│    ├── apply time: 2.2727e-05s\n│    └── parse time: 8.9539e-05s\n├── fidelity estimate: 1\n├── average multi-qubit gate error estimate: 0\n├── creg (most sampled):\n│    ├── bs\"0011\" => 136\n│    ├── bs\"0101\" => 135\n│    ├── bs\"0111\" => 134\n│    ├── bs\"0010\" => 129\n│    └── bs\"0100\" => 117\n├── 1 executions\n├── 0 amplitudes\n└── 1000 samples","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"The QCSResults object has different fields that you can access:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Key fields:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"simulator (String): Name of the simulator used, e.g., MIMIQ-StateVector.\nversion (String): Version of the simulator used, e.g. 0.14.1.\nfidelities (Vector{Float64}): Fidelity estimates for each of the circuits executed (between 0 and 1).\navggateerrors (Vector{Float64}): Average multiqubit gate errors. This value represents the average fidelity that multi-qubit gates would need to have in a real quantum computer in order to yield the same fidelity as the MIMIQ simulation.\ncstates (Vector{BitString}): Vector with the sampled values of the classical registers, i.e. of measurements. See circuit and non-unitary operations pages.\nzstates (Vector{ComplexF64}): Vector with the values of the Z-registers, i.e. of expectation values, entanglement measures, etc. See circuit and statistical operations pages.\namplitudes (Dict{BitString, ComplexF64}): Number of amplitudes retrieved.\ntimings (Dict{String, Float64}): Time taken for different stages of the execution. You can access:\n\"total\" (Float64): The entire time elapsed during execution.\n\"parse\" (Float64): Time taken to parse the circuit.\n\"compression\" (Float64): Time to convert the circuit to an efficient execution format.\n\"apply\" (Float64): Time to apply all operations. It also includes the time to allocate the initial state.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"note: Note\nTo understand how MIMIQ samples measurements into the classical register, check the simulation page.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Here's an example of how to access different fields:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"using MimiqCircuits # hide\nstr_name = get(ENV, \"MIMIQCLOUD\", nothing) # hide\nnew_url = # hide\n    str_name == \"QPERFECT_CLOUD\" ? QPERFECT_CLOUD : # hide\n    str_name == \"QPERFECT_CLOUD2\" ? QPERFECT_CLOUD2 : # hide\n    isnothing(str_name) ? QPERFECT_CLOUD : # hide\n    str_name # hide\nconn = connect(ENV[\"MIMIQUSER\"], ENV[\"MIMIQPASS\"]; url=new_url) # hide\n# Prepare multiple circuits and execute them in batch mode # hide\n\n# Prepare circuits # hide\nghz = Circuit() # hide\n\n# Add gates to the circuits # hide\npush!(ghz, GateH(), 1) # hide\npush!(ghz, GateCX(), 1, 2:10) # hide\n\n# Execute Single circuit # hide\njob_single = execute(conn, ghz; nsamples=1000, label=\"Single_run\") # hide\n\n# Getting the Results # hide\nres_single = getresult(conn, job_single) # hide\n\n# Get fidelity\nfids = res_single.fidelities\nprintln(fids)\n\n# Get total execution time\ntot = res_single.timings[\"total\"]\nprintln(tot)\n\n# Get classical registers of the first 10 samples\nfirst_samples = res_single.cstates[1:10]\nprintln(first_samples)","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"With the output of getresults it works the same way, except you have to access one of the circuit results, i.e. res_batch[index] instead of res_single.","category":"page"},{"location":"manual/remote_execution/#Plotting-results","page":"Cloud Execution","title":"Plotting results","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"You can visualize the results of your circuit execution using the Plots package. The example below shows how to plot the results from executing a single circuit.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Example:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"using MimiqCircuits # hide\nstr_name = get(ENV, \"MIMIQCLOUD\", nothing) # hide\nnew_url = # hide\n    str_name == \"QPERFECT_CLOUD\" ? QPERFECT_CLOUD : # hide\n    str_name == \"QPERFECT_CLOUD2\" ? QPERFECT_CLOUD2 : # hide\n    isnothing(str_name) ? QPERFECT_CLOUD : # hide\n    str_name # hide\nconn = connect(ENV[\"MIMIQUSER\"], ENV[\"MIMIQPASS\"]; url=new_url) # hide\n# Prepare multiple circuits and execute them in batch mode # hide\n\n# Prepare circuits # hide\nc1 = Circuit() # hide\n\n# Add gates to the circuits # hide\npush!(c1, GateH(), 1) # hide\npush!(c1, GateCX(), 1, 2:10) # hide\n\n# Execute Single circuit # hide\njob_single = execute(conn, c1; nsamples=1000, label=\"Single_run\") # hide\n\n# Getting the Results # hide\nres_single = getresult(conn, job_single) # hide\n\nusing Plots\nplot(res_single)","category":"page"},{"location":"manual/remote_execution/#Saving-and-loading-results","page":"Cloud Execution","title":"Saving and loading results","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"After retrieval, if you want to save the results locally, you can save them as a Protobuf file (.pb) using the saveproto function. You can load back the results using loadproto. This format ensures minimal file size while maintaining all the necessary data.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"To learn more about Protobuf and how to save/load results, check out the import & export page.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"note: Note\nResults from batch simulations need to be saved one by one.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Here is an example:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"using MimiqCircuits # hide\nstr_name = get(ENV, \"MIMIQCLOUD\", nothing) # hide\nnew_url = # hide\n    str_name == \"QPERFECT_CLOUD\" ? QPERFECT_CLOUD : # hide\n    str_name == \"QPERFECT_CLOUD2\" ? QPERFECT_CLOUD2 : # hide\n    isnothing(str_name) ? QPERFECT_CLOUD : # hide\n    str_name # hide\nconn = connect(ENV[\"MIMIQUSER\"], ENV[\"MIMIQPASS\"]; url=new_url) # hide\n# Prepare multiple circuits and execute them in batch mode # hide\n\n# Prepare circuits # hide\nc1 = Circuit() # hide\nc2 = Circuit() # hide\n\n# Add gates to the circuits # hide\npush!(c1, GateX(), 1) # hide\npush!(c2, GateH(), 2) # hide\n\n# Execute Single circuit # hide\njob_single = execute(conn, c1; nsamples=1000, label=\"Single_run\") # hide\n\n# Execute circuits in batch mode # hide\njob_batch = execute(conn, [c1, c2]; nsamples=1000, label=\"batch_run\") # hide\n\n# Getting the Results # hide\nres_single = getresult(conn, job_single) # hide\nres_batch = getresults(conn, job_batch) # hide\n\n# Saving Single Result\nsaveproto(\"res_single.pb\", res_single)\n\n# Saving Batch Result (Should be saved one by one)\nsaveproto(\"res_batch_1.pb\", res_batch[1])\n\n# Loading Results\nloadproto(\"res_single.pb\", QCSResults)\nloadproto(\"res_batch_1.pb\", QCSResults)","category":"page"},{"location":"manual/remote_execution/#Useful-Job-Management-Features","page":"Cloud Execution","title":"Useful Job Management Features","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"MIMIQ provides several functions to facilitate job management. For this you need to have a connection established, and possibly a job id or object (see connection and execution sections).","category":"page"},{"location":"manual/remote_execution/#Check-job-status","page":"Cloud Execution","title":"Check job status","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"You can check the status of jobs using isjobdone, isjobfailed, isjobcanceled, isjobstarted. These functions check whether the job's status is DONE, ERROR, CANCELED or RUNNING, respectively, and return a boolean.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"You can find this information also in the cloud server, but doing it from within the Julia session allows you to perform different actions depending on job status. It is particularly useful to avoid a call to getresults to take too long because a job has not finished yet (check results section).","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"To call them, we simply do:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"isjobdone(connection, job)\nisjobfailed(connection, job)\nisjobcanceled(connection, job)\nisjobstarted(connection, job)","category":"page"},{"location":"manual/remote_execution/#List-all-jobs","page":"Cloud Execution","title":"List all jobs","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"You can get a list of all job requests sent to MIMIQ's cloud server using requests. This can be useful for monitoring job history and active requests.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"This function accepts several options, which you can use to filter by status (i.e. \"NEW\", \"RUNNING\", \"ERROR\", \"CANCELED\", \"DONE\") or by userEmail. You can also change the limit for the amount of requests retrieved using limit.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"Here's an example to get the last 100 new jobs:","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"requests(connection, status = \"NEW\", limit = 100)","category":"page"},{"location":"manual/remote_execution/#Get-inputs","page":"Cloud Execution","title":"Get inputs","text":"","category":"section"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"You can retrieve the input circuits and parameter files for every job using getinput or getinputs. The former fetches the data of the first circuit in the job, whereas the latter retrieves all inputs from all circuits in the job (useful in batch mode). This is similar to getresult vs getresults.","category":"page"},{"location":"manual/remote_execution/","page":"Cloud Execution","title":"Cloud Execution","text":"  circuits, parameters = getinputs(connection, job)","category":"page"},{"location":"manual/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"This manual introduces all concepts and syntax necessary to use MIMIQ to its fullest capabilities.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"MIMIQ is a quantum circuit simulator framework. It allows to numerically calculate the effect of applying quantum operations on quantum objects like qubits. Mathematically, this is a linear algebra problem where a complex vector representing the quantum state of qubits is sequentially updated through multiplication with matrices that represent operations.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"The manual starts by introducing the central object of this framework: the Circuit (see circuit page). A Circuit is essentially a vector of Instructions to be applied to the qubits. An Instruction contains information about the quantum operation to be applied and the desired targets of the operation. We call the targets registers and there are three types:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Quantum registers represent the qubits (0rangle or 1rangle). They are indexed from 1 to N and their state representation depends on the simulator backend chosen. \nClassical registers represent boolean information (0 or 1) that can be used to store the result of measuring the state of the qubits. They are represented by a vector of Bools.\nZ registers represent complex number information that can be used to store the result of mathematical calculations on the quantum state such as expectation values. They are represented by a vector of Complex numbers.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"MIMIQ supports many different types of quantum operations to apply to these registers. Some of these operations correspond to physical operations one could perform on a real quantum computer, whereas other operations are mathematical operations only possible in a simulation framework. The manual introduces the following types of operations:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Unitary Gates correspond to transformations of the quantum state that preserve the norm (i.e. unitary matrices), and are usually the basis of quantum algorithms.\nNon-unitary Operations encompass both measurement and reset operations that project the quantum state and are physically implementable, as well as more general operators, i.e. linear transformations, which are only mathematical tools. We include also conditional logic (if statements) in this category.\nNoise is a type of non-unitary operation describing the effect of the environment on the qubits. We discuss it separately because it has its own intricacies (Kraus operators).\nStatistical Operations correspond to all mathematical operations that are only possible inside the simulation framework (e.g. expectation values, entanglement measures...), which however do not change the quantum state of the qubits.\nSpecial Operations such as more complex composite gates (e.g. QFT, oracles...) or custom gate declarations.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Until here, all these tools allow the user to define a circuit. In order to simulate the circuit MIMIQ offers two backends: a State Vector (SV) simulator, and a Matrix-Product States (MPS) simulator. These are introduced in the simulation page. The SV simulator allows to run calculations exactly for small systems up to 32 qubits in the remote server, whereas the MPS simulator uses efficient compression techniques and can simulate large-scale circuits either exactly (if entanglement is bound), or approximately. In the latter case, a fidelity helps the user estimate the accuracy of the approximation.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"The circuits are executed remotely, using a Cloud Service that gives the user access to large resources and high-performance hardware. Details on the cloud interface are discussed in the cloud execution page.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"MIMIQ uses its own Protobuf based format to export and import circuits defined through the MIMIQ language. However, it also allows to import and execute circuits from files written in OpenQASM or Stim format. This is all discussed in the import-export page.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"The last section discuss some special topics such as bitstrings.","category":"page"},{"location":"manual/special_ops/#Special-Operations","page":"Special Operations","title":"Special Operations","text":"","category":"section"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"MIMIQ offers further possibilities to create circuits, such as new gate declarations, or wrappers for common combinations of gates.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"Special Operations\nGate Declaration \\& Gate Calls\nComposite Gates\nPauli String\nQuantum Fourier Transform\nPhase Gradient\nPolynomial Oracle\nDiffusion\nMore about composite gates\nBarrier","category":"page"},{"location":"manual/special_ops/#Gate-Declaration-and-Gate-Calls","page":"Special Operations","title":"Gate Declaration & Gate Calls","text":"","category":"section"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"Using MIMIQ you can define your own gates with a given name, arguments and instructions. For examples if you wish to apply an H gate followed by an RX gate with a specific argument for the rotation you can use GateDecl or @gatedecl as follows:","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"using MimiqCircuits # hide\n@gatedecl ansatz(rot) = begin\n    # build the equivalent circuit defining the gate\n    c = Circuit()\n    push!(c, GateH(), 1)\n    push!(c, GateRX(rot), 2)\n\n    # return the circuit\n    return c\nend","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"Here, ansatz is the name that will be shown when printing or drawing the circuit and the variable name for the declaration. Then ansatz(...) is how we instantiate the gate and (rot) defines the gate parameters.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"As you can see in the code above, to generate your own gate declaration you will need to instantiate Instructions. Instructions are instantiated using one operation followed by a list of targets needed by the operation. The order of the target follows the usual quantum register -> classical register -> Z-register order. Basically, it works the same way as push! except that no circuit is passed as an argument.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"After declaration you can add it to your circuit using push!.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"circuit = Circuit() # hide\npush!(circuit, ansatz(pi), 1, 2)","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"note: Note\nA gate declared with GateDecl must be unitary.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"note: Note\nansatz is an object of type GateDecl, whereas ansatz(pi) is of type GateCall.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"Creating a gate declaration allows you to add easily the same sequence of gates in a very versatile way and manipulate your new gate like you would with any other gate. This means that you can combine it with other gates via Control, add noise to the whole block in one call, use it as an operator for ExpectationValue, use it within an IfStatement etc. See unitary gates, non-unitary operations, and noise pages.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"For example, here is how to add noise to the previous gate declaration:","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"circuit = Circuit()\nmy_gate = ansatz(pi)\npush!(circuit, my_gate, 1, 2)\n\n## Add noise to the gate declared\nadd_noise!(circuit, my_gate, Depolarizing2(0.1))\n\ndraw(circuit)","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"You can use it in an IfStatement as follows:","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"IfStatement(my_gate, bs\"111\")","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"Note that this type of combined operation does not work if we pass a circuit as an argument, instead of a declared gate (more precisely, a GateCall, see note above).","category":"page"},{"location":"manual/special_ops/#Composite-Gates","page":"Special Operations","title":"Composite Gates","text":"","category":"section"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"MIMIQ provides a list of composite gates to facilitate the circuit building process. Here is the full list of generalized gates available on MIMIQ: QFT, PhaseGradient, PolynomialOracle, Diffusion, PauliString.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"These composite gates are different from the other gates in that the number of targeted qubits is variable and require user input.","category":"page"},{"location":"manual/special_ops/#Pauli-String","page":"Special Operations","title":"Pauli String","text":"","category":"section"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"A PauliString is an N-qubit tensor product of Pauli operators of the form","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"P_1 otimes P_2 otimes P_3 otimes ldots otimes P_N","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"where each P_i in  I X Y Z  is a single-qubit Pauli operator, including the identity.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"To create an operator using PauliString we simply pass as argument the Pauli string written as a String:","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"circuit = Circuit() # hide\npush!(circuit, PauliString(\"IXYZ\"), 1, 2, 3, 4)","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"You can give it an arbitrary number of Pauli operators.","category":"page"},{"location":"manual/special_ops/#Quantum-Fourier-Transform","page":"Special Operations","title":"Quantum Fourier Transform","text":"","category":"section"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"The Quantum Fourier transform is a circuit used to realize a linear tranformation on qubits and is a building block of many larger circuits such as Shor's algorithm or the quantum phase estimation. ","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"The QFT maps an arbitrary quantum state ketx = sum_j = 0^N-1 x_jketj to a quantum state sum_k=0^N-1 y_kketk according to the formula","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"beginaligned\ny_k = frac1sqrtN sum_j=0^N-1 x_jw_N^-jk\nendaligned","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"where w_N = e^2pi i  N.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"In MIMIQ the QFT gate allows you to quickly implement a QFT in your circuit on an arbitrary N number of qubits. You can instantiate the QFT gate by giving it the number of qubits you want to use QFT(N) and you can add it like any other gate in the circuit.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"circuit = Circuit() # hide\npush!(circuit, QFT(5), 1:5...)","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"This will add a 5 qubits QFT to the first five qubits of your circuit.","category":"page"},{"location":"manual/special_ops/#Phase-Gradient","page":"Special Operations","title":"Phase Gradient","text":"","category":"section"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"A phase gradient gate applies a phase shift to a quantum register of N qubits, where each computational basis state ketk experiences a phase proportional to its integer value k:","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"beginaligned\noperatornamePhaseGradient =\nsum_k=0^N-1 mathrme^i frac2 piN k ketkbrak\nendaligned","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"To use it you can simply give it the number of qubit targets and add it to the circuit like the following examples:","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"circuit = Circuit() # hide\npush!(circuit, PhaseGradient(5), 1:5...)","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"This will add a 5 qubits PhaseGradient to the first 5 qubits of the quantum register.","category":"page"},{"location":"manual/special_ops/#Polynomial-Oracle","page":"Special Operations","title":"Polynomial Oracle","text":"","category":"section"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"warning: Warning\nThis gate can only be used with the state vector simulator and not with MPS, because of ancillas qubit use.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"The PolynomialOracle is a quantum oracle for a polynomial function of two registers. It applies a pi phase shift to any basis state which satifies a xy + bx + cy + d == 0, where ketx and kety are the states of the two registers.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"Here is how to use the PolynomialOracle:","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"circuit = Circuit() # hide\npush!(circuit, PolynomialOracle(5,5,1,2,3,4), 1:10...)","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"The arguments for PolynomialOracle follow this order: N_x (size of x register), N_y (size of y register), a, b, c, d, see definitions above.","category":"page"},{"location":"manual/special_ops/#Diffusion","page":"Special Operations","title":"Diffusion","text":"","category":"section"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"The Diffusion operator corresponds to Grover's diffusion operator. It implements the unitary transformation.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"H^otimes n (1-2ket0^n bra0^n) H^otimes n","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"Here is how to use Diffusion:","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"circuit = Circuit() # hide\npush!(circuit, Diffusion(10), 1:10...)","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"Again, you need to give the number of targets and the index of the targets.","category":"page"},{"location":"manual/special_ops/#More-about-composite-gates","page":"Special Operations","title":"More about composite gates","text":"","category":"section"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"All composite gates can be decomposed with decompose to extract the implementation (except for PolynomialOracle).","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"decompose(QFT(5))","category":"page"},{"location":"manual/special_ops/#Barrier","page":"Special Operations","title":"Barrier","text":"","category":"section"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"Barrier is a Non-op operation that does not affect the quantum state, but prevents compression or optimization across the execution. As of now Barrier is only useful when combined with the MPS backend.","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"To add barriers to the circuit you can use the Barrier operation:","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"circuit = Circuit() # hide \npush!(circuit, GateX(), 1)\n\n# Apply the Barrier on one qubit.\npush!(circuit, Barrier(1), 1)\n\n# Add a Gate between barriers\npush!(circuit, GateX(), 1)\npush!(circuit, GateX(), 1)\n\n# apply individual barriers on multiple qubits\npush!(circuit, Barrier(1), 1:3)\n\n#Add gates between barriers\npush!(circuit, GateX(), 1:3)\n\n# Apply one general Barrier on multiple qubits (is effectively the same as above)\npush!(circuit, Barrier(3), 1, 2, 3)\n\ndraw(circuit)","category":"page"},{"location":"manual/special_ops/","page":"Special Operations","title":"Special Operations","text":"In the example above when executing the second and third X gates can be compressed as one ID operator but the first and fourth X gate will not be merged with the others.","category":"page"},{"location":"library/mimiqcircuitsbase/module/#MimiqCircuitsBase.jl-public-documentation","page":"MimiqCircuitsBase.jl public documentation","title":"MimiqCircuitsBase.jl public documentation","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/module/","page":"MimiqCircuitsBase.jl public documentation","title":"MimiqCircuitsBase.jl public documentation","text":"Documentation for MimiqCircuitsBase.jl's public interface.","category":"page"},{"location":"library/mimiqcircuitsbase/module/#MimiqCircuitsBase","page":"MimiqCircuitsBase.jl public documentation","title":"MimiqCircuitsBase","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/module/","page":"MimiqCircuitsBase.jl public documentation","title":"MimiqCircuitsBase.jl public documentation","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"MimiqCircuitsBase.jl\"]","category":"page"},{"location":"TODO_doc/","page":"-","title":"-","text":"DO NOT DELETE this file, it is needed to generate the documentation. and the user can't find it. All not mentionned references are listed here so the compilation works TODO: Every ref below should be documented in the real documentation at some point","category":"page"},{"location":"TODO_doc/","page":"-","title":"-","text":"Detector ShiftCoordinates Tick ObservableInclude AbstractAnnotation QubitCoordinates","category":"page"},{"location":"manual/circuits/#Circuits","page":"Circuits","title":"Circuits","text":"","category":"section"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"On this page you can find all the information needed to build a circuit using MIMIQ. Every useful function will be presented below, accompanied by an explanation of their purpose and examples of use.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"Circuits\nWhat is a circuit and what are instructions\nCircuits \\& Instructions in MIMIQ\nRegisters: quantum/classical/Z-register\nCreating a circuit\nAdding Gates\nPush\nPush! specifics\nInsert\nAppend\nVisualizing circuits\nDecompose","category":"page"},{"location":"manual/circuits/#What-is-a-circuit-and-what-are-instructions","page":"Circuits","title":"What is a circuit and what are instructions","text":"","category":"section"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"A quantum circuit, similar to a classical circuit, represents a sequence of quantum gates applied to qubits, which are the carriers of quantum information. Quantum circuits are essential for designing quantum algorithms. The complexity of a quantum circuit is typically measured by two key metrics: width and depth. Width refers to the number of qubits in the circuit, while depth indicates the maximum number of sequential gates applied to any single qubit.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"Here is a representation of a simple GHZ circuit on 4 qubits:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"using MimiqCircuits\nghz = Circuit()\npush!(ghz, GateH(), 1)\nfor i in 2:4\n  push!(ghz, GateCX(), 1, i)\nend\ndraw(ghz)","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"In this representation, each qubit is depicted by a horizontal line labeled q[x], where x is the qubit’s index. The circuit is read from left to right, with each 'block' or symbol along a line representing an operation applied to that specific qubit.","category":"page"},{"location":"manual/circuits/#Circuits-and-Instructions-in-MIMIQ","page":"Circuits","title":"Circuits & Instructions in MIMIQ","text":"","category":"section"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"MIMIQ implements a circuit using the Circuit structure, in essence this structure is a wrapper for a vector of Instruction to be applied on the qubits in the order of the vector. Since it is a vector a circuit can be manipulated as such, for example you can use for loops to iterate over the different instructions of the circuit, do vector comprehension or access all common vector attributes such as the length.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"An Instruction is composed of the quantum operation to be applied to the qubits, and the targets on which to apply it. There are many types of quantum operations, as discussed in the unitary gates, non-unitary operations and other pages of the manual. The targets can be qubits, as well as boolean or complex number vectors where classical information can be stored. You will generally not need to interact with the Instruction class directly (for exceptions, see special operations), but it is useful to understand how MIMIQ works.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"See the following sections to learn how to add operations to your circuit.","category":"page"},{"location":"manual/circuits/#Registers:-quantum/classical/Z-register","page":"Circuits","title":"Registers: quantum/classical/Z-register","text":"","category":"section"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"Before explaining how to build a circuit it is important to make a distinction between the different target registers your operations will be applied to. ","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"The circuits in MIMIQ are composed of three registers that can be used by the instructions:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"The Quantum Register: Used to store the qubits state. Most of the operators in MIMIQ will interact with the quantum register. When printing or drawing a circuit (with the function draw) the quantum registers will be denoted as q[x] with x being the index of the qubit in the quantum register.\nThe classical register: Used to store the bits state. Some gates will need to interact with classical bits (ex: Measure) and the state of the classical bits is stored in the classical register, which is a vector of booleans. When printing or drawing a circuit the classical register will be denoted by the letter c.\nThe Z-register: Used to store the result of some specific operations when the expected result is a complex number (ex: ExpectationValue). The Z-register is basically a vector of complex numbers. When printing or drawing a circuit the Z-Register will be denoted by the letter z.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"For the three registers operators can be applied on an arbitrary index starting from 1 (as does Julia in general contrary to python). When possible you should always use the minimal index available as going for an arbitrary high index N will imply that N qubits will be simulated and might result in a loss of performance and will also make the circuit drawing more complex to understand. ","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"Here is a circuit interacting with all registers:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"using MimiqCircuits\n# create empty circuit\ncircuit = Circuit()\n\n# add X to the first qubit of the Quantum register\npush!(circuit, GateX(), 1)\n\n# compute Expectation value of qubit 1 and store complex number on the first Z-Register\nev = ExpectationValue(GateZ())\npush!(circuit, ev, 1, 1)\n\n# Measure the qubit state and store bit into the first classical register\npush!(circuit, Measure(), 1, 1)\n\n#drw the circuit\ndraw(circuit)","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"As you can see in the code above the indexing of the different registers always starts by the quantum register. If your operator interacts with the three registers the index will have to be provided in the following order: ","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"Index of the quantum register.\nIndex of the classical register.\nIndex of the z-register.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"Be careful when writing information to the z-register or to the classical register as the information can be easily overwritten if the same index is used multiple times. For example if you measure two different qubits and store both in the same classical bit the results of the sampling will only report the last measurement.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"To retrieve information on the number of element of each register you can use the numqubits, numbits and numzvars.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"numqubits(circuit), numbits(circuit), numzvars(circuit)","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"In the following sections you will learn in details how to build a circuit in MIMIQ.","category":"page"},{"location":"manual/circuits/#Creating-a-circuit","page":"Circuits","title":"Creating a circuit","text":"","category":"section"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"The first step in executing quantum algorithm on MIMIQ always consists in implementing the corresponding quantum circuit, a sequence of quantum operations (quantum gates, measurements, resets, etc...) that acts on a set of qubits. In MIMIQ we always start by defining an empty circuit","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"circuit = Circuit()","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"There is no need to give any arguments. Not even the number of qubits, classical or Z-registers is necessary as it will be directly inferred from the operations added to the circuit.","category":"page"},{"location":"manual/circuits/#Adding-Gates","page":"Circuits","title":"Adding Gates","text":"","category":"section"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"Once a circuit is instantiated operations can be added to it. To see the list of gates available head to OPERATIONS, GATES, NOISECHANNELS and GENERALIZED or enter the following command in your Julia session:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"?GATES","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"To know more about the types of operations you can use in a circuit head to the unitary gates, non-unitary operations, noise, symbolic operations and special operations pages.","category":"page"},{"location":"manual/circuits/#Push","page":"Circuits","title":"Push","text":"","category":"section"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"To add gates to circuits in Julia we will mainly be using the push! function. The arguments needed by push! can vary, but in general it expects the following: ","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"The circuit to add the operation to.\nThe operator to be added. \nAs many targets as needed by the operator (qubits/bits/zvars).","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"For instance you can add the gate X by simply running the following command","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"push!(circuit, GateX(), 1)","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"The text representation H @ q[1] informs us that there is an instruction which applies the Hadamard gate to the qubit of index 1.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"Some gates require multiple target qubits such as the CX gate. Here is how to add such a gate to the circuit:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"circuit = Circuit() # hide\npush!(circuit, GateCX(), 1, 2)","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"This will add the gate GateCX using the qubit number 1 as the control qubit and number 2 as the target qubit in the circuit.","category":"page"},{"location":"manual/circuits/#Push!-specifics","page":"Circuits","title":"Push! specifics","text":"","category":"section"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"push! is very versatile, it can be used to add multiple operators to multiple targets at once using iterators.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"To add one type of gate to multiple qubits use:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"circuit = Circuit() # hide\npush!(circuit, GateX(), 1:10)","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"This will add one X gate on each qubit from number 1 to 10.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"This also works on 2-qubit gates:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"circuit = Circuit() # hide\n# Adds 3 CX gates using respectively 1, 2 & 3 as the control qubits and 4 as the target qubit for all \npush!(circuit, GateCX(), 1:3, 4)\n# Adds 3 CX gates using respectively 2, 3 & 4 qubits as the target and 1 as the control qubit for all\npush!(circuit, GateCX(), 1, 2:4)\n\n# adds 3 CX gates using respectively the couples (1, 4), (2, 5), (3, 6) as the control and target qubits\npush!(circuit, GateCX(), 1:3, 4:6)\n\ndraw(circuit)","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"Be careful when using vectors for both control and target, if one of the two vectors in longer than the other only the N first element of the vector will be accounted for with N = min(length.(vector1, vector2)). See the output of the code below to see the implication in practice:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"circuit = Circuit()\n# Adds only 3 CX gates\npush!(circuit, GateCX(), 1:3, 4:18)\n\ndraw(circuit)","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"You can also use tuples or vectors in the exact same fashion:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"circuit = Circuit() # hide\n\npush!(circuit, GateCX(), (1, 2), (3, 4))\npush!(circuit, GateCX(), [1, 3], [2, 4])\n\ndraw(circuit)","category":"page"},{"location":"manual/circuits/#Insert","page":"Circuits","title":"Insert","text":"","category":"section"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"You can also insert an operation at a given index in the circuit using the insert! function:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"circuit = Circuit()\npush!(circuit, GateX(), 1)\npush!(circuit, GateZ(), 1)\n\n# Insert the gate at a specific index\ninsert!(circuit, 2, GateY(), 1)\ncircuit","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"This will insert GateY applied on qubit 1 at the second position in the circuit.","category":"page"},{"location":"manual/circuits/#Append","page":"Circuits","title":"Append","text":"","category":"section"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"To append one circuit to another you can use the append! function:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"# Build a first circuit\ncircuit1 = Circuit()\npush!(circuit1, GateX(), 1:3)\n\n# Build a second circuit\ncircuit2 = Circuit()\npush!(circuit2, GateY(), 1:3)\n\n# Append the second circuit to the first one\nappend!(circuit1, circuit2)\ncircuit1","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"This will modify circuit1 by appending all the operations from circuit2.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"This function is particularly useful for building circuits by combining smaller circuit blocks.","category":"page"},{"location":"manual/circuits/#Visualizing-circuits","page":"Circuits","title":"Visualizing circuits","text":"","category":"section"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"To visualize a circuit use the draw method.","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"circuit = Circuit() # hide\npush!(circuit, GateX(), 1:5) # hide\ndraw(circuit)","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"Information such as the depth and the width (numqubits) can be extracted from the circuit:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"depth(circuit), numqubits(circuit)","category":"page"},{"location":"manual/circuits/#Decompose","page":"Circuits","title":"Decompose","text":"","category":"section"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"Most gates can be decomposed into a combination of U and CX gates, the decompose function extracts such decomposition from a given circuit:","category":"page"},{"location":"manual/circuits/","page":"Circuits","title":"Circuits","text":"circuit = Circuit()\npush!(circuit, GateX(), 1)\n\n# decompose the circuit\ndecompose(circuit)","category":"page"},{"location":"manual/non_unitary_ops/#Non-unitary-Operations","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"","category":"section"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Contrary to unitary gates, non-unitary operations based on measurements make the quantum state collapse. Find in the following sections all the non-unitary operations supported by MIMIQ.","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Non-unitary Operations\nMeasure\nMathematical definition\nHow to use measurements\nReset\nMeasure-Reset\nConditional logic\nIf statements\nOperators\nMathematical definition\nOperators available in MIMIQ\nHow to use operators","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"note: Note\nAs a rule of thumb all non-unitary operations can be added to the circuit using the function push! by giving the index of the targets in the following order: quantum register index -> classical register index. ","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"note: Note\nNoise can also be interpreted as a non-unitary operations but will not be treated here, check the noise documentation page to learn more about it.","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"note: Note\nOnce a non-unitary operation is added to your circuit the speed of execution might be reduced. This is because in this case the circuit needs to be re-run for every sample since the final quantum state might be different each time. This is always true except for Measure operations placed at the very end of a circuit. To learn more about this head to the simulation page.","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"note: Note\nSome features of unitary gates are not available for non-unitary operations, for instance, matrix, inverse, power, control, parallel.","category":"page"},{"location":"manual/non_unitary_ops/#Measure","page":"Non-unitary Operations","title":"Measure","text":"","category":"section"},{"location":"manual/non_unitary_ops/#Mathematical-definition","page":"Non-unitary Operations","title":"Mathematical definition","text":"","category":"section"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Measurements are defined by a basis of projection operators P_k, one for each different possible outcome k. The probability p_k of measuring outcome k is given by the expectation value of P_k, that is","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"p_k = brapsi P_k ketpsi","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"If the outcome k is observed, the system is left in the state","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"fracP_kketpsisqrtp_k ","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"It is common to measure in the Z basis (P_0=ket0bra0 and P_1=ket1bra1), but measurements in other bases are possible too.","category":"page"},{"location":"manual/non_unitary_ops/#How-to-use-measurements","page":"Non-unitary Operations","title":"How to use measurements","text":"","category":"section"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Available measurement operations: Measure, MeasureX, MeasureY, MeasureZ, MeasureXX, MeasureYY, MeasureZZ.","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"With MIMIQ you can measure the qubits at any point in the circuit (not only at the end of the circuit) using one of the measurement operations (Measure...). You can add it to the circuit like gates using push!, but you will need to precise both the index for the quantum register (qubit to measure) and classical register (where to store the result):","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"using MimiqCircuits # hide \ncircuit = Circuit() # hide\npush!(circuit, Measure(), 1, 1)","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"This will add a Measure on the first qubit of the quantum register to the circuit and write the result on the first bit of the classical register. Recall that the targets are always ordered as quantum register -> classical register -> z register. To learn more about registers head to the circuit page.  ","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"You can also use iterators to Measure multiple qubits at once, as for gates:","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"push!(Circuit(), Measure(), 1:10, 1:10)","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"note: Note\nIn the absence of any non-unitary operations in the circuit, MIMIQ will sample (and, therefore, measure) all the qubits at the end of the circuit by default, see simulation page.","category":"page"},{"location":"manual/non_unitary_ops/#Reset","page":"Non-unitary Operations","title":"Reset","text":"","category":"section"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Available reset operations: Reset, ResetX, ResetY, ResetZ.","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"A reset operation consists in measuring the qubits in some basis and then applying an operation conditioned on the measurement outcome to leave the qubits in some pre-defined state. For example, Reset leaves all qubits in ket0 (by measuring in Z and flipping the state if the outcome is 1).","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Here is an example of how to add a reset operation to a circuit:","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"circuit = Circuit() # hide \npush!(circuit, Reset(), 1) ","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Importantly, even though a reset operation technically measures the qubits, the information is not stored in the classical register, so we only need to specify the qubit register. If you want to store the result, see the measure-reset section.","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Note that a reset operation can be technically seen as noise and is described by the same mathematical machinery, see noise page. For this reason, some of the functionality provided by MIMIQ for noise is also available for resets. Here is one example:","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"krausoperators(Reset())","category":"page"},{"location":"manual/non_unitary_ops/#Measure-Reset","page":"Non-unitary Operations","title":"Measure-Reset","text":"","category":"section"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Available measure-reset operations: MeasureReset, MeasureResetX, MeasureResetY, MeasureResetZ.","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"A measure-reset operation is the same as a reset operation except that we store the result of the measurement, see measure and reset sections. Because of that, we need to specify both quantum and classical registers when adding it to a circuit:","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"circuit = Circuit() # hide \npush!(circuit, MeasureReset(), 1, 1)","category":"page"},{"location":"manual/non_unitary_ops/#Conditional-logic","page":"Non-unitary Operations","title":"Conditional logic","text":"","category":"section"},{"location":"manual/non_unitary_ops/#If-statements","page":"Non-unitary Operations","title":"If statements","text":"","category":"section"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"An if statement consists in applying an operation conditional on the value of some classical register. In that sense, it resembles a classical if statement.","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"In MIMIQ you can implement it using IfStatement, which requires two arguments: an operation to apply and a BitString as the condition (see bitstrings page for more information):","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"IfStatement(GateX(), BitString(\"111\"))","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"note: Note\nAt the moment, MIMIQ only allows to pass unitary gates as arguments to an if statement (which makes if statements unitary for now).","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"To add an IfStatement to a circuit use the push! function. The first (quantum) indices will determine the qubits to apply the gate to, whereas the last (classical) indices will be used to compare against the condition given. For example:","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"circuit  = Circuit() # hide\n# Apply a GateX on qubit 1 if the qubits 2 and 4 are in the state 1 and qubit 3 in the state 0. \npush!(circuit, IfStatement(GateX(), bs\"101\"), 1, 2, 3, 4)","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Here, an X gate will be applied to qubit 1, if classical registers 2 and 4 are 1, and classical register 3 is 0. Of course, if the gate targets more than 1 qubit, then all qubit indices will be specified before the classical registers, as usual (see circuit page).","category":"page"},{"location":"manual/non_unitary_ops/#Operators","page":"Non-unitary Operations","title":"Operators","text":"","category":"section"},{"location":"manual/non_unitary_ops/#Mathematical-definition-2","page":"Non-unitary Operations","title":"Mathematical definition","text":"","category":"section"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Operators refer to any linear operation on a state. An operator does not need to be unitary, as is the case of a gate. This means that any 2^N times 2^N matrix can in principle represent an operator on N qubits.","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"note: Note\nDo not confuse operator with operation. In MIMIQ, the word operation is used as the supertype for all transformations of a quantum state (gates, measurements, statistical operations...), whereas an operator is a sort of generalized gate, a linear tranformation.","category":"page"},{"location":"manual/non_unitary_ops/#Operators-available-in-MIMIQ","page":"Non-unitary Operations","title":"Operators available in MIMIQ","text":"","category":"section"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Custom operators: Operator","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Special operators: DiagonalOp, SigmaPlus, SigmaMinus, Projector0, ProjectorZ0, Projector1, ProjectorZ1, ProjectorX0, ProjectorX1, ProjectorY0, ProjectorY1, Projector00, Projector01, Projector10, Projector11","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Methods available: matrix.","category":"page"},{"location":"manual/non_unitary_ops/#How-to-use-operators","page":"Non-unitary Operations","title":"How to use operators","text":"","category":"section"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Operators cannot be applied to a state directly (it cannot be added to a circuit using push!), because that would correspond to an unphysical transformation. However, they can be used within other operations such as ExpectationValue or to create custom noise models with Kraus, see noise and statistical operations pages.","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Operators can be used to compute expectation values as follows (see also ExpectationValue):","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"using MimiqCircuits\nop = SigmaPlus()\nev = ExpectationValue(op)","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"push!(Circuit(), ev, 1,1)","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"Similarly, operators can also be used to define non-mixed unitary Kraus channels (see also Kraus). For example, we can define the amplitude damping channel as follows:","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"gamma = 0.1\nk1 = DiagonalOp(1, sqrt(1-gamma))    # Kraus operator 1\nk2 = SigmaMinus(sqrt(gamma))    # Kraus operator 2\nkraus = Kraus([k1,k2])","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"This is equivalent to","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"gamma = 0.1\nampdamp = AmplitudeDamping(gamma)\nkrausoperators(ampdamp)","category":"page"},{"location":"manual/non_unitary_ops/","page":"Non-unitary Operations","title":"Non-unitary Operations","text":"note: Note\nWhenever possible, using specialized operators, such as DiagonalOp and SigmaMinus, as opposed to custom operators, such as Operator, is generally better for performance.","category":"page"},{"location":"#MIMIQ-Documentation","page":"MIMIQ Documentation","title":"MIMIQ Documentation","text":"","category":"section"},{"location":"","page":"MIMIQ Documentation","title":"MIMIQ Documentation","text":"Welcome to the documentation of MIMIQ, a quantum emulation platform developed by QPerfect.","category":"page"},{"location":"#Important-Links","page":"MIMIQ Documentation","title":"Important Links","text":"","category":"section"},{"location":"","page":"MIMIQ Documentation","title":"MIMIQ Documentation","text":"MIMIQ product page\nInstall MIMIQ\nQuick start\nContact QPerfect","category":"page"},{"location":"#What-is-MIMIQ","page":"MIMIQ Documentation","title":"What is MIMIQ","text":"","category":"section"},{"location":"","page":"MIMIQ Documentation","title":"MIMIQ Documentation","text":"MIMIQ is a feature-rich quantum computing framework that allows users to design quantum circuits and execute them on MIMIQ's remote service.","category":"page"},{"location":"","page":"MIMIQ Documentation","title":"MIMIQ Documentation","text":"With MIMIQ you can test new quantum algorithms fast and at scale, emulate their implementation on noisy quantum hardware, and grow your understanding of quantum computing by peeking into the properties of the state during emulation. From variational quantum algorithms to quantum error correction, MIMIQ is a universal emulator well-equipped to handle most quantum circuits of interest.","category":"page"},{"location":"#MIMIQ's-advantage","page":"MIMIQ Documentation","title":"MIMIQ's advantage","text":"","category":"section"},{"location":"","page":"MIMIQ Documentation","title":"MIMIQ Documentation","text":"We developed MIMIQ as a tool for quantum computing researchers and application developers.  Therefore, it has been built for speed, scale and accuracy, as well as ease of use. We achieve this by providing:","category":"page"},{"location":"","page":"MIMIQ Documentation","title":"MIMIQ Documentation","text":"Efficient implementations of state-of-the-art simulation and compression techniques, which allows to emulate small circuits fast, and large circuits (up to 100s-1000s of qubits) accurately and with fewer resources.\nA cloud interface that gives you greater power for large-scale emulation at your fingertips and allows to parallel execute multiple jobs without disturbing the workflow.\nSimple interface and customizable functionality that facilitates the process of designing and executing quantum circuits.\nAccess to a professional set of advanced features for circuit composition (noise, conditional logic, mid-circuit measurements...), access to full quantum state properties (state amplitudes, expectation values, entanglement measures...), and workflow integration (parsers).","category":"page"},{"location":"#Simulation-Methods","page":"MIMIQ Documentation","title":"Simulation Methods","text":"","category":"section"},{"location":"","page":"MIMIQ Documentation","title":"MIMIQ Documentation","text":"MIMIQ gives access to efficient implementations of state-of-the-art emulation methods. This includes a State Vector simulator for perfectly accurate simulations on small-scale circuits and a Matrix Product State simulator for larger-scale simulations with a controlled and transparent fidelity metric. To see more about the simulators available on the platform head to the Simulators page.","category":"page"},{"location":"#How-to-use-the-Documentation","page":"MIMIQ Documentation","title":"How to use the Documentation","text":"","category":"section"},{"location":"#Exploring-the-Documentation","page":"MIMIQ Documentation","title":"Exploring the Documentation","text":"","category":"section"},{"location":"","page":"MIMIQ Documentation","title":"MIMIQ Documentation","text":"On the left panel is located the tree of the different pages that can be found in this documentation. You can click on each part to access the pages of your interest. Alternatively if you need to look for something more specific (e.g. a specific function) you can use the search bar above the tree. From Julia's REPL you can also type ? followed by the function you're interested in to get some information.","category":"page"},{"location":"#Documentation-Content","page":"MIMIQ Documentation","title":"Documentation Content","text":"","category":"section"},{"location":"","page":"MIMIQ Documentation","title":"MIMIQ Documentation","text":"If you are using MIMIQ for the first time it is highly recommended to head to the installation and quick start pages to install MIMIQ and understand its basic functionalities. The core of documentation can be found in the \"Manual\" where every feature offered by MIMIQ will be covered with explanations and examples. For more complete examples of use cases and their implementation take a look at the \"Use cases\" Section. If you encounter any issues using MIMIQ take a look at the \"Performance Tips and Common Issues\" section, or contact us at QPerfect. Finally for more in depth explanation of the different functions available you can head to the API section.","category":"page"},{"location":"manual/symbolic_ops/#Symbolic-Operations","page":"Symbolic Operations","title":"Symbolic Operations","text":"","category":"section"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"This section provides detailed information on how to use symbolic operations in MIMIQ, including defining symbols, creating symbolic operations, substituting values, and running circuits with symbolic parameters.","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"Symbolic Operations\nWhen Symbolic Operations Can Be Useful\nDefining Symbols\nDefining Symbolic Operations\nSubstituting Symbols with Values","category":"page"},{"location":"manual/symbolic_ops/#When-Symbolic-Operations-Can-Be-Useful","page":"Symbolic Operations","title":"When Symbolic Operations Can Be Useful","text":"","category":"section"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"Symbolic operations are valuable in several quantum computing scenarios:","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"Parameter Optimization: In algorithms like the Variational Quantum Eigensolver (VQE), parameters need to be optimized iteratively. Using symbolic variables allows you to define a circuit once and update it with new parameter values during the optimization process. However, before executing the circuit, you must substitute the symbolic parameters with concrete values. This approach simplifies managing parameterized circuits.\nCircuit Analysis: Symbolic operations are useful for analyzing the structure of a quantum circuit. By keeping parameters symbolic, you can explore how different components of the circuit affect the output, such as measurement probabilities or expectation values, without needing to reconstruct the circuit.","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"<!– Parameter Optimization in VQE:","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"In the Variational Quantum Eigensolver (VQE), the goal is to find the ground state energy of a Hamiltonian. This involves:","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"Preparing a parameterized quantum state.\nMeasuring the expectation value of the Hamiltonian.\nUpdating the parameters to minimize this expectation value.","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"Step 1: Use symbolic variables to define the parameterized circuit.\nStep 2: Substitute the symbolic variables with specific values during each optimization iteration and execute the circuit.","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"Exploring Parameter Sensitivity in Circuit Analysis:","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"In circuit analysis, the focus is on understanding how parameter changes affect the circuit's output. For instance, how measurement probabilities or expectation values change as parameters are varied.","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"Step 1: Use symbolic variables to define the parameterized circuit.\nStep 2: Substitute different values for the symbolic parameters and analyze the resulting circuit outputs to see how they are affected.","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"warning: Warning\nSymbolic parameters are useful tools for circuit design and analysis but before executing a circuit on a simulator you must substitute all symbolic parameters with numerical values. –>","category":"page"},{"location":"manual/symbolic_ops/#Defining-Symbols","page":"Symbolic Operations","title":"Defining Symbols","text":"","category":"section"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"MIMIQ leverages the Symbolics.jl library to define symbolic variables. These variables act as placeholders for parameters in quantum operations, allowing you to create circuits with adjustable parameters that can be optimized or substituted later.","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"To define symbols in MIMIQ, you will need to create symbolic variables and then use them as parameters for parametric operations. Here's how to get started:","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"# Import the Symbolics package by importing MimiqCircuits\nusing MimiqCircuits\n\n# Define symbols\n@variables θ φ\nif get(ENV, \"MIMIQOUTPUTFORMAT\", nothing) == \"PDF\" # hide\n    \"[θ, φ]\" # hide\nelse # hide\n    @variables θ φ # hide\nend # hide","category":"page"},{"location":"manual/symbolic_ops/#Defining-Symbolic-Operations","page":"Symbolic Operations","title":"Defining Symbolic Operations","text":"","category":"section"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"Once you have defined symbols, you can use them in your quantum circuit operations. This allows you to create parameterized gates that depend on symbolic variables.","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"using MimiqCircuits #hide\n@variables θ φ #hide\n\n# Create a new circuit\nc = Circuit()\n\n# Add symbolic rotation gates\npush!(c, GateRX(θ), 1)\npush!(c, GateRY(φ), 2)","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"In this example, θ and φ are symbolic variables that can be used in operations.","category":"page"},{"location":"manual/symbolic_ops/#Substituting-Symbols-with-Values","page":"Symbolic Operations","title":"Substituting Symbols with Values","text":"","category":"section"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"Before executing a circuit that includes symbolic parameters, you need to replace these symbols with specific numerical values. This is done using a dictionary to map each symbolic variable to its corresponding value. Here is an example of how to do it.","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"using MimiqCircuits #hide\n@variables θ φ #hide\nc = Circuit() #hide\npush!(c, GateRX(θ), 1) #hide\npush!(c, GateRY(φ), 2) #hide\n\n# Substitute θ = π/2 and φ = π/4\nsubstitutions = Dict(θ => π/2, φ => π/4)\n\n# Apply the substitutions to the circuit\nevaluated_circuit = evaluate(c, substitutions)","category":"page"},{"location":"manual/symbolic_ops/","page":"Symbolic Operations","title":"Symbolic Operations","text":"In this example, evaluate is used to create a new circuit where θ is replaced by π/2 and φ by π/4.","category":"page"},{"location":"library/mimiqcircuitsbase/noise/#Noise","page":"Noise","title":"Noise","text":"","category":"section"},{"location":"library/mimiqcircuitsbase/noise/","page":"Noise","title":"Noise","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages = [\n    \"noisemodels.jl\",\n    \"samplenoise.jl\",\n    \"operations/noisechannels/standard/projectivenoise.jl\",\n    \"operations/noisechannels/kraus.jl\",\n    \"operations/krauschannel.jl\",\n    \"operations/amplitude.jl\",\n    \"operations/operators/diagonals.jl\",\n    \"operations/noisechannels/standard/ampdamping.jl\",\n    \"operations/noisechannels/standard/phaseampdamping.jl\",\n    \"operations/noisechannels/standard/depolarizing.jl\",\n    \"operations/noisechannels/standard/pauli.jl\",\n    \"operations/noisechannels/mixedunitary.jl\",\n    \"operations/generalized/paulistrings.jl\",\n]","category":"page"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.add_noise!-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}","page":"Noise","title":"MimiqCircuitsBase.add_noise!","text":"add_noise!(c, g, noise; before=false, parallel=false)\n\nAdd a noise operation noise to every operation g in the circuit c.\n\nThe noise operation noise can be a Kraus channel or a gate and will act on the same qubits as the operation g it is being added to.\n\nThe operations g and noise have to act on the same number of qubits.\n\nArguments\n\nc: Circuit.\ng: Operation to which noise will be added.\nnoise: Kraus channel or gate that will be added to each operation g.\nbefore: (optional) Bool, default=false. If before is false then the noise is added right after the operation; if it's true it's added right before.\nparallel: (optional) Bool, default=false. If parallel is false then the noise is added immediately after/before the operation. If it's true the function identifies blocks of consecutive transversal operations of type g and adds after each such block a block of transversal noise operations noise. The result of both should be equivalent, it's only the order of operations that changes.\n\nReturns\n\nThe circuit c with the noise added in place.\n\nExamples\n\nParallel vs not parallel.\n\njulia> c = push!(Circuit(), GateH(), 1:3);\n\njulia> add_noise!(c, GateH(), AmplitudeDamping(0.2))\n3-qubit circuit with 6 instructions:\n├── H @ q[1]\n├── AmplitudeDamping(0.2) @ q[1]\n├── H @ q[2]\n├── AmplitudeDamping(0.2) @ q[2]\n├── H @ q[3]\n└── AmplitudeDamping(0.2) @ q[3]\n\njulia> c = push!(Circuit(), GateH(), 1:3);\n\njulia> add_noise!(c, GateH(), AmplitudeDamping(0.2); parallel=true)\n3-qubit circuit with 6 instructions:\n├── H @ q[1]\n├── H @ q[2]\n├── H @ q[3]\n├── AmplitudeDamping(0.2) @ q[1]\n├── AmplitudeDamping(0.2) @ q[2]\n└── AmplitudeDamping(0.2) @ q[3]\n\nParallel will not work if gates aren't transversal.\n\njulia> c = push!(Circuit(), GateCZ(), 1, 2:4);\n\njulia> add_noise!(c, GateCZ(), Depolarizing2(0.1); parallel=true)\n4-qubit circuit with 6 instructions:\n├── CZ @ q[1], q[2]\n├── Depolarizing(2,0.1) @ q[1:2]\n├── CZ @ q[1], q[3]\n├── Depolarizing(2,0.1) @ q[1,3]\n├── CZ @ q[1], q[4]\n└── Depolarizing(2,0.1) @ q[1,4]\n\nThe before=true option is mostly used for Measure.\n\njulia> c = push!(Circuit(), Measure(), 1:3, 1:3);\n\njulia> add_noise!(c, Measure(), PauliX(0.1); before=true)\n3-qubit circuit with 6 instructions:\n├── PauliX(0.1) @ q[1]\n├── M @ q[1], c[1]\n├── PauliX(0.1) @ q[2]\n├── M @ q[2], c[2]\n├── PauliX(0.1) @ q[3]\n└── M @ q[3], c[3]\n\nUnitary gates are added in the same way.\n\njulia> c = push!(Circuit(), GateH(), 1:3);\n\njulia> add_noise!(c, GateH(), GateRX(0.01))\n3-qubit circuit with 6 instructions:\n├── H @ q[1]\n├── RX(0.01) @ q[1]\n├── H @ q[2]\n├── RX(0.01) @ q[2]\n├── H @ q[3]\n└── RX(0.01) @ q[3]\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.add_noise-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}","page":"Noise","title":"MimiqCircuitsBase.add_noise","text":"add_noise(c, g, noise; before=false, parallel=false)\n\nAdd noise operation noise to every operation g in circuit c.\n\nA copy of c is created and then noise is added to the copy.\n\nSee [add_noise!] for more information.\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.sample_mixedunitaries-Tuple{Circuit}","page":"Noise","title":"MimiqCircuitsBase.sample_mixedunitaries","text":"sample_mixedunitaries(c; rng, ids=false)\n\nSamples one unitary gate for each mixed unitary Kraus channel in the circuit.\n\nThis is possible because for mixed unitary noise channels the probabilities of each Kraus operator are fixed (state-independent).\n\nNote: This function is internally called (before applying any gate) when executing a circuit with noise using trajectories, but it can also be used to generate samples of circuits without running them.\n\nSee also ismixedunitary, MixedUnitary, probabilities, and unitarygates.\n\nArguments\n\nc: Circuit to be sampled.\nrng: (optional) Random number generator.\nids: (optional) Boolean, default=false. When the selected Kraus operator is an identity it has no effect on the circuit. The parameter ids decides whether to add it to the circuit (ids=true) or not (ids=false`; default). Usually, most of the Kraus operators selected will be identity gates.\n\nReturns\n\nA copy of circuit but with every mixed unitary Kraus channel replaced by one of the unitary gates of the channel (or nothing if identity and ids==false).\n\nExamples\n\nGates and non-mixed-unitary Kraus channels remain unchanged.\n\njulia> using Random\n\njulia> c = push!(Circuit(), GateH(), 1:3);\n\njulia> push!(c, Depolarizing1(0.5), 1:3);\n\njulia> push!(c, AmplitudeDamping(0.5), 1:3)\n3-qubit circuit with 9 instructions:\n├── H @ q[1]\n├── H @ q[2]\n├── H @ q[3]\n├── Depolarizing(1,0.5) @ q[1]\n├── Depolarizing(1,0.5) @ q[2]\n├── Depolarizing(1,0.5) @ q[3]\n├── AmplitudeDamping(0.5) @ q[1]\n├── AmplitudeDamping(0.5) @ q[2]\n└── AmplitudeDamping(0.5) @ q[3]\n\njulia> rng = MersenneTwister(42);\n\njulia> sample_mixedunitaries(c; rng=rng, ids=true)\n3-qubit circuit with 9 instructions:\n├── H @ q[1]\n├── H @ q[2]\n├── H @ q[3]\n├── Y @ q[1]\n├── ID @ q[2]\n├── ID @ q[3]\n├── AmplitudeDamping(0.5) @ q[1]\n├── AmplitudeDamping(0.5) @ q[2]\n└── AmplitudeDamping(0.5) @ q[3]\n\nBy default identities are not included.\n\njulia> rng = MersenneTwister(42);\n\njulia> sample_mixedunitaries(c; rng=rng)\n3-qubit circuit with 7 instructions:\n├── H @ q[1]\n├── H @ q[2]\n├── H @ q[3]\n├── Y @ q[1]\n├── AmplitudeDamping(0.5) @ q[1]\n├── AmplitudeDamping(0.5) @ q[2]\n└── AmplitudeDamping(0.5) @ q[3]\n\nDifferent calls to the function generate different results.\n\njulia> sample_mixedunitaries(c; rng=rng)\n3-qubit circuit with 6 instructions:\n├── H @ q[1]\n├── H @ q[2]\n├── H @ q[3]\n├── AmplitudeDamping(0.5) @ q[1]\n├── AmplitudeDamping(0.5) @ q[2]\n└── AmplitudeDamping(0.5) @ q[3]\n\njulia> sample_mixedunitaries(c; rng=rng)\n3-qubit circuit with 6 instructions:\n├── H @ q[1]\n├── H @ q[2]\n├── H @ q[3]\n├── AmplitudeDamping(0.5) @ q[1]\n├── AmplitudeDamping(0.5) @ q[2]\n└── AmplitudeDamping(0.5) @ q[3]\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.ProjectiveNoiseX","page":"Noise","title":"MimiqCircuitsBase.ProjectiveNoiseX","text":"ProjectiveNoiseX()\n\nSingle qubit projection noise onto a X Pauli basis.\n\nThis channel is defined by the Kraus operators\n\nE_1 = -rangle langle- quad E_2 = +rangle langle+\n\nWhere ket+ and ket- are the eigenstates of Pauli X.\n\nSee also ProjectiveNoise, ProjectiveNoiseY, or ProjectiveNoiseZ.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.ProjectiveNoiseY","page":"Noise","title":"MimiqCircuitsBase.ProjectiveNoiseY","text":"ProjectiveNoiseY()\n\nSingle qubit projection noise onto a Y Pauli basis.\n\nThis channel is defined by the Kraus operators\n\nE_1 = Y0rangle langle Y0 quad E_2 = Y1rangle langle Y1\n\nWhere ketY0 and ketY1 are the eigenstates of Pauli Y.\n\nSee also ProjectiveNoise, ProjectiveNoiseX, or ProjectiveNoiseZ.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.ProjectiveNoiseZ","page":"Noise","title":"MimiqCircuitsBase.ProjectiveNoiseZ","text":"ProjectiveNoiseZ()\n\nSingle qubit projection noise onto a Z Pauli basis.\n\nThis channel is defined by the Kraus operators\n\nE_1 = 0rangle langle Z0 quad E_2 = 1rangle langle Z1\n\nWhere ket0 and ket1 are the eigenstates of Pauli Z.\n\nSee also ProjectiveNoise, ProjectiveNoiseX, or ProjectiveNoiseY.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.ProjectiveNoise","page":"Noise","title":"MimiqCircuitsBase.ProjectiveNoise","text":"ProjectiveNoise(basis)\n\nSingle qubit projection noise onto a Pauli basis.\n\nThis channel is defined by the Kraus operators\n\nE_1 = alpharangle langlealpha quad E_2 = betarangle langlebeta\n\nwhere the states alpharangle and betarangle are the +1 and -1 eigenstates of a Pauli operator. Specifically, they correspond to  0langle 1langle  (Z basis),  +langle -langle  (X basis), or  y+langle y-langle  (Y basis).\n\nThis operation is similar to measuring in the corresponding basis (X, Y, or Z), except that the outcome of the measurement is not stored, i.e. there's loss of information.\n\nArguments\n\nbasis: Symbol, String or Char that selects the Pauli basis, \"X\", \"Y\", or \"Z\".\n\nExamples\n\njulia> push!(Circuit(), ProjectiveNoise(\"Z\"), 1)\n1-qubit circuit with 1 instructions:\n└── ProjectiveNoiseZ @ q[1]\n\nThe Kraus matrices are given by:\n\njulia> krausmatrices(ProjectiveNoise(\"X\"))\n2-element Vector{Matrix{Float64}}:\n [0.5 0.5; 0.5 0.5]\n [0.5 -0.5; -0.5 0.5]\n\njulia> krausmatrices(ProjectiveNoise(\"Y\"))\n2-element Vector{Matrix{ComplexF64}}:\n [0.5 + 0.0im 0.0 - 0.5im; 0.0 + 0.5im 0.5 + 0.0im]\n [0.5 + 0.0im 0.0 + 0.5im; 0.0 - 0.5im 0.5 + 0.0im]\n\njulia> krausmatrices(ProjectiveNoise(\"Z\"))\n2-element Vector{Matrix{Int64}}:\n [1 0; 0 0]\n [0 0; 0 1]\n\n\n\n\n\n","category":"function"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.Kraus","page":"Noise","title":"MimiqCircuitsBase.Kraus","text":"Kraus(E)\n\nCustom N qubit Kraus channel specified by a list of Kraus operators.\n\nA Kraus channel is defined by\n\nmathcalE(rho) = sum_k E_k rho E_k^dagger\n\nwhere E_k are Kraus operators that need to fulfill sum_k E_k^dagger E_k = I.\n\nIf the Kraus operators are all proportional to unitaries, use MixedUnitary instead.\n\nThe Kraus matrices are defined in the computational basis in the usual textbook order (the first qubit corresponds to the left-most qubit). For 1 qubit we have 0rangle, 1rangle. For 2 qubits we have 00rangle, 01rangle, 10rangle, 11rangle. See also GateCustom.\n\nnote: Note\nCurrently only 1 and 2-qubit custom Kraus channels are supported.\n\nSee also MixedUnitary, AbstractKrausChannel.\n\nArguments\n\nE: Vector of 2^N times 2^N complex matrices or N qubit operators. Both can be mixed.\n\nExamples\n\njulia> push!(Circuit(), Kraus([[1 0; 0 sqrt(0.9)], [0 sqrt(0.1); 0 0]]), 1)\n1-qubit circuit with 1 instructions:\n└── Kraus(Operator([1.0 0.0; 0.0 0.948683]), Operator([0.0 0.316228; 0.0 0.0])) @ q[1]\n\njulia> push!(Circuit(), Kraus([Projector0(), Projector1()]), 1)\n1-qubit circuit with 1 instructions:\n└── Kraus(Projector0(1), Projector1(1)) @ q[1]\n\njulia> push!(Circuit(), Kraus([[1 0; 0 0], Projector1()]), 1)\n1-qubit circuit with 1 instructions:\n└── Kraus(Operator([1.0 0.0; 0.0 0.0]), Projector1(1)) @ q[1]\n\njulia> @variables x\n1-element Vector{Symbolics.Num}:\n x\n\njulia> g = Kraus([Projector0(), Projector1(x)])\nKraus(Projector0(1), Projector1(x))\n\njulia> evaluate(g,Dict(x=>1))\nKraus(Projector0(1), Projector1(1))\n\njulia> g = Kraus([[1 0; 0 sqrt(0.9)], [0 sqrt(0.1); 0 x]])\nKraus(Operator([1.0 0.0; 0.0 0.948683]), Operator([0 0.316228; 0 x]))\n\njulia> evaluate(g,Dict(x=>0))\nKraus(Operator([1.0 0.0; 0.0 0.948683]), Operator([0 0.316228; 0 0]))\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.AbstractKrausChannel","page":"Noise","title":"MimiqCircuitsBase.AbstractKrausChannel","text":"AbstractKrausChannel{N} <: Operation{N,0,0}\n\nSupertype for all the N-qubit Kraus channels.\n\nA Kraus channel is a quantum operation on a density matrix rho of the form\n\nmathcalE(rho) = sum_k E_k rho E_k^dagger\n\nwhere E_k are Kraus operators that need to fulfill sum_k E_k^dagger E_k leq I.\n\nSpecial properties:\n\nisCPTP: A Kraus channel a completely positive and trace preserving (CPTP) operation when sum_k E_k^dagger E_k = I. Currently, all noise channels are CPTP.\nismixedunitary: A Kraus channel is called a mixed unitary channel when the Kraus operators E_k are each proportional to a unitary matrix U_k, i.e. when mathcalE(rho) = sum_k p_k U_k rho U_k^dagger with some probabilities 0leq p_k leq 1 that add up to 1 and U_k^dagger U_k = I.\n\nSee also krausmatrices, unitarymatrices, probabilities.\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.cumprobabilities-Tuple{AbstractKrausChannel}","page":"Noise","title":"MimiqCircuitsBase.cumprobabilities","text":"cumprobabilities(mixedunitarychannel)\n\nCumulative sum of probabilities of a mixed unitary Kraus channel.\n\nA mixed unitary channel is written as sum_k p_k U_k rho U_k^dagger, where p_k are the probabilities.\n\nAn error is returned for Kraus channels with ismixedunitary(krauschannel)==false.\n\nnote: Note\nif the Kraus channel is parametric, the cumprobabilities are wrapped in a Symbolics.Num object. To manipulate expressions use the Symbolics package.\n\nSee also probabilities, ismixedunitary.\n\nExamples\n\njulia> cumprobabilities(Depolarizing1(0.1))\n4-element Vector{Symbolics.Num}:\n                0.9\n 0.9333333333333333\n 0.9666666666666667\n                1.0\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T<:AbstractKrausChannel","page":"Noise","title":"MimiqCircuitsBase.ismixedunitary","text":"ismixedunitary(krauschannel)\n\nWhether the quantum operation is a mixed unitary channel.\n\nThis is the case when all the Kraus operators E_k are proportional to a unitary U_k, i.e. mathcalE(rho) = sum_k p_k U_k rho U_k^dagger with some probabilities 0leq p_k leq 1 that add up to 1 and U_k^dagger U_k = I.\n\nExamples\n\njulia> ismixedunitary(PauliX(0.1))\ntrue\n\njulia> ismixedunitary(AmplitudeDamping(0.1))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.krausmatrices-Tuple{AbstractKrausChannel}","page":"Noise","title":"MimiqCircuitsBase.krausmatrices","text":"krausmatrices(krauschannel)\n\nKraus matrices associated to the given Kraus channel.\n\nA mixed unitary channel is written as sum_k p_k U_k rho U_k^dagger, where U_k are the unitary matrices returned by this function.\n\nnote: Note\nif the Kraus channel is parametric, the matrix elements are wrapped in a Symbolics.Num object. To manipulate expressions use the Symbolics package.\n\nExamples\n\njulia> krausmatrices(AmplitudeDamping(0.1))\n2-element Vector{Matrix{Float64}}:\n [1.0 0.0; 0.0 0.9486832980505138]\n [0.0 0.31622776601683794; 0.0 0.0]\n\nFor mixed unitary channels the Kraus matrices are the unitary matrices times the square root of the probabilities.\n\njulia> krausmatrices(PauliX(0.2))\n2-element Vector{Matrix{Symbolics.Num}}:\n [0.8944271909999159 -0.0; 0.0 0.8944271909999159]\n [0.0 0.4472135954999579; 0.4472135954999579 0.0]\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.krausoperators-Tuple{AbstractKrausChannel}","page":"Noise","title":"MimiqCircuitsBase.krausoperators","text":"krausoperators(kraus)\n\nKraus operators associated to the given Kraus channel.\n\nSee also krausmatrices.\n\nExamples\n\njulia> krausoperators(PauliX(0.2))\n2-element Vector{Operator{1}}:\n Operator([0.8944271909999159 -0.0; 0.0 0.8944271909999159])\n Operator([0.0 0.4472135954999579; 0.4472135954999579 0.0])\n\njulia> krausoperators(AmplitudeDamping(0.1))\n2-element Vector{AbstractOperator{1}}:\n D(1, 0.9486832980505138)\n SigmaMinus(0.31622776601683794)\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.probabilities-Tuple{AbstractKrausChannel}","page":"Noise","title":"MimiqCircuitsBase.probabilities","text":"probabilities(mixedunitarychannel)\n\nProbabilities of each Kraus operator for mixed unitary Kraus channels.\n\nA mixed unitary channel is written as sum_k p_k U_k rho U_k^dagger, where p_k are the probabilities.\n\nAn error is returned for Kraus channels with ismixedunitary(krauschannel)==false.\n\nnote: Note\nif the Kraus channel is parametric, the probabilities are wrapped in a Symbolics.Num object. To manipulate expressions use the Symbolics package.\n\nSee also ismixedunitary, unitarymatrices, and krausmatrices.\n\nExamples\n\njulia> probabilities(PauliX(0.1))\n2-element Vector{Symbolics.Num}:\n 0.9\n 0.1\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.squaredkrausoperators-Tuple{AbstractKrausChannel}","page":"Noise","title":"MimiqCircuitsBase.squaredkrausoperators","text":"squaredkrausoperators(kraus)\n\nSquare of of Kraus operators (O^dagger O) associated to the given Kraus channel.\n\nSee also krausoperators.\n\nExamples\n\njulia> squaredkrausoperators(AmplitudeDamping(0.1))\n2-element Vector{AbstractOperator{1}}:\n D(1, 0.8999999999999999)\n P₁(0.1)\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.unitarygates-Tuple{AbstractKrausChannel}","page":"Noise","title":"MimiqCircuitsBase.unitarygates","text":"unitarygates(krauschannel)\n\nUnitary gates associated to the given mixed unitary Kraus channel.\n\nA mixed unitary channel is written as sum_k p_k U_k rho U_k^dagger, where U_k are the unitary operators returned by this function.\n\nAn error is returned for Kraus channels with ismixedunitary(krauschannel)==false.\n\nSee also ismixedunitary, unitarymatrices, and krausmatrices.\n\nExamples\n\njulia> unitarygates(PauliNoise([0.9,0.1],[\"II\",\"XX\"]))\n2-element Vector{PauliString{2}}:\n II\n XX\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.unitarymatrices-Tuple{AbstractKrausChannel}","page":"Noise","title":"MimiqCircuitsBase.unitarymatrices","text":"unitarymatrices(mixedunitarychannel)\n\nUnitary matrices associated to the given mixed unitary Kraus channel.\n\nA mixed unitary channel is written as sum_k p_k U_k rho U_k^dagger, where U_k are the unitary matrices.\n\nAn error is returned for Kraus channels with ismixedunitary(krauschannel)==false.\n\nnote: Note\nif the Kraus channel is parametric, the matrix elements are wrapped in a Symbolics.Num object. To manipulate expressions use the Symbolics package.\n\nSee also ismixedunitary, probabilities, and krausmatrices.\n\nExamples\n\njulia> unitarymatrices(PauliX(0.2))\n2-element Vector{Matrix}:\n [1.0 -0.0; 0.0 1.0]\n [0 1; 1 0]\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.unwrappedcumprobabilities-Tuple{AbstractKrausChannel}","page":"Noise","title":"MimiqCircuitsBase.unwrappedcumprobabilities","text":"unwrappedcumprobabilities(mixedunitarychannel)\n\nCumulative sum of probabilities associated to the specified mixed unitary Kraus channel without the Symbolics.Num wrapper.\n\nnote: Note\nIf any of the noise channel's parameters is symbolic, an error is thrown.\n\nSee cumprobabilities for more information.\n\njulia> unwrappedcumprobabilities(Depolarizing1(0.1))\n4-element Vector{Float64}:\n 0.9\n 0.9333333333333333\n 0.9666666666666667\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.unwrappedkrausmatrices-Tuple{AbstractKrausChannel}","page":"Noise","title":"MimiqCircuitsBase.unwrappedkrausmatrices","text":"unwrappedkrausmatrices(krauschannel)\n\nReturns the Kraus matrices associated to the specified Kraus channel without the Symbolics.Num wrapper.\n\nnote: Note\nIf any of the noise channel's parameters is symbolic, an error is thrown.\n\nSee krausmatrices for more information.\n\nExamples\n\njulia> unwrappedkrausmatrices(AmplitudeDamping(0.1))\n2-element Vector{Matrix{Float64}}:\n [1.0 0.0; 0.0 0.9486832980505138]\n [0.0 0.31622776601683794; 0.0 0.0]\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.unwrappedprobabilities-Tuple{AbstractKrausChannel}","page":"Noise","title":"MimiqCircuitsBase.unwrappedprobabilities","text":"unwrappedprobabilities(mixedunitarychannel)\n\nProbabilities associated to the specified mixed unitary Kraus channel without the Symbolics.Num wrapper.\n\nnote: Note\nIf any of the noise channel's parameters is symbolic, an error is thrown.\n\nSee probabilities for more information.\n\njulia> unwrappedprobabilities(PauliX(0.1))\n2-element Vector{Float64}:\n 0.9\n 0.1\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.unwrappedunitarymatrices-Tuple{AbstractKrausChannel}","page":"Noise","title":"MimiqCircuitsBase.unwrappedunitarymatrices","text":"unwrappedunitarymatrices(krauschannel)\n\nReturns the unitary Kraus matrices associated to the mixed unitary Kraus channel without the Symbolics.Num wrapper.\n\nnote: Note\nIf any of the noise channel's parameters is symbolic, an error is thrown.\n\nSee unitarymatrices for more information.\n\nExamples\n\njulia> unwrappedunitarymatrices(PauliX(0.2))\n2-element Vector{Matrix}:\n [1.0 -0.0; 0.0 1.0]\n [0 1; 1 0]\n\n\n\n\n\n","category":"method"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.Amplitude","page":"Noise","title":"MimiqCircuitsBase.Amplitude","text":"Amplitude(bs::BitString)\n\nOperation to get amplitude of a state vector element.\n\nThe operation gets the quantum state's amplitude (which is a complex number) corresponding to the state defined by the  bitstring bs in the computational basis and stores it in a z-register.\n\nSee BitString.\n\nExamples\n\nWhen defining a circuit, only the z-register to store the result needs to be specified.\n\njulia> Amplitude(BitString(\"001\"))\nAmplitude(bs\"001\")\n\njulia> c = push!(Circuit(),Amplitude(BitString(\"001\")), 1)\n0-qubit circuit with 1 instructions:\n└── Amplitude(bs\"001\") @ z[1]\n\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.DiagonalOp","page":"Noise","title":"MimiqCircuitsBase.DiagonalOp","text":"DiagonalOp(a,b)\n\nOne-qubit diagonal operator.\n\nThe corresponding matrix\n\nbeginpmatrix\n    a  0\n    0  b\nendpmatrix\n\nis parametrized by complex numbers a and b.\n\nSee also Operator, Projector0, Projector1.\n\nExamples\n\njulia> DiagonalOp(1,0.5)\nD(1, 0.5)\n\njulia> push!(Circuit(), ExpectationValue(DiagonalOp(1,0.5)), 1, 2)\n1-qubit circuit with 1 instructions:\n└── ⟨D(1,0.5)⟩ @ q[1], z[2]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.AmplitudeDamping","page":"Noise","title":"MimiqCircuitsBase.AmplitudeDamping","text":"AmplitudeDamping(γ)\n\nOne-qubit amplitude damping noise channel.\n\nThis channel is defined by the Kraus operators\n\nE_1 =\nbeginpmatrix\n    1  0 \n    0  sqrt1-gamma\nendpmatrix\nquad\nE_2 =\nbeginpmatrix\n    0  sqrtgamma \n    0  0\nendpmatrix\n\nwhere gamma in 01.\n\nPhysically, it corresponds to an energy gain/loss process, such as spontaneous emission.\n\nExamples\n\njulia> push!(Circuit(), AmplitudeDamping(0.1), 1)\n1-qubit circuit with 1 instructions:\n└── AmplitudeDamping(0.1) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.GeneralizedAmplitudeDamping","page":"Noise","title":"MimiqCircuitsBase.GeneralizedAmplitudeDamping","text":"GeneralizedAmplitudeDamping(p,γ)\n\nOne-qubit generalized amplitude damping noise channel.\n\nThis channel is defined by the Kraus operators\n\nE_1 =\nsqrtp\nbeginpmatrix\n    1  0 \n    0  sqrt1-gamma\nendpmatrix\nquad\nE_2 =\nsqrtp\nbeginpmatrix\n    0  sqrtgamma \n    0  0\nendpmatrix\nquad\nE_3 =\nsqrt1-p\nbeginpmatrix\n    sqrt1-gamma  0 \n    0  1\nendpmatrix\nquad\nE_4 =\nsqrt1-p\nbeginpmatrix\n    0  0 \n    sqrtgamma  0\nendpmatrix\n\nwhere gamma p in 01.\n\nPhysically, it corresponds to a combination of spontaneous emission and spontaneous absorption with probabilities p and 1-p, respectively.\n\nExamples\n\njulia> push!(Circuit(), GeneralizedAmplitudeDamping(0.1, 0.3), 1)\n1-qubit circuit with 1 instructions:\n└── GeneralizedAmplitudeDamping(0.1,0.3) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PhaseAmplitudeDamping","page":"Noise","title":"MimiqCircuitsBase.PhaseAmplitudeDamping","text":"PhaseAmplitudeDamping(p,γ,β)\n\nOne-qubit phase amplitude damping noise channel.\n\nThis channel is defined by:\n\nmathcalE(rho) =\nbeginpmatrix\n    (1-gamma)rho_00+gamma p  (1-2beta)sqrt1-gammarho_01 \n    (1-2beta)sqrt1-gammarho_10  (1-gamma)rho_11 + (1-p)gamma\nendpmatrix\n\nHere, p gamma beta in 01.\n\nThis channel is equivalent to a GeneralizedAmplitudeDamping(p,γ) channel (see GeneralizedAmplitudeDamping), followed by a PauliZ(β) channel (see PauliZ).\n\nUse krausmatrices to see a Kraus matrix representation of the channel.\n\nSee also AmplitudeDamping, GeneralizedAmplitudeDamping, and ThermalNoise.\n\nExamples\n\njulia> push!(Circuit(), PhaseAmplitudeDamping(0.1, 0.2, 0.3), 1)\n1-qubit circuit with 1 instructions:\n└── PhaseAmplitudeDamping(0.1,0.2,0.3) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.ThermalNoise","page":"Noise","title":"MimiqCircuitsBase.ThermalNoise","text":"ThermalNoise(T₁, T₂, t, nₑ)\n\nOne-qubit thermal noise channel.\n\nThe thermal noise channel is equivalent to the PhaseAmplitudeDamping channel, but it is parametrized instead as\n\nmathcalE(rho) =\nbeginpmatrix\n    e^-Gamma_1 trho_00+(1-n_e)(1-e^-Gamma_1 t)  e^-Gamma_2 trho_01 \n    e^-Gamma_2 trho_10  e^-Gamma_1 trho_11 + n_e(1-e^-Gamma_1 t)\nendpmatrix\n\nwhere Gamma_1=1T_1 and Gamma_2=1T_2, and the parameters must fulfill T_1 geq 0, T_2 leq 2 T_1, t geq 0, and 0 leq n_e leq 1.\n\nThese parameters can be related to the ones used to define the PhaseAmplitudeDamping channel through p = 1-n_e, gamma = 1-e^-Gamma_1 t, and beta = frac12(1-e^-(Gamma_2-Gamma_12)t).\n\nSee also PhaseAmplitudeDamping, AmplitudeDamping, and GeneralizedAmplitudeDamping.\n\nArguments\n\nT₁: Longitudinal relaxation rate.\nT₂: Transversal relaxation rate.\nt: Time duration of gate.\nnₑ: Excitation fraction when in thermal equilibrium with the environment.\n\nExamples\n\njulia> push!(Circuit(), ThermalNoise(0.5, 0.6, 1.2, 0.3), 1)\n1-qubit circuit with 1 instructions:\n└── ThermalNoise(0.5,0.6,1.2,0.3) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.Depolarizing","page":"Noise","title":"MimiqCircuitsBase.Depolarizing","text":"Depolarizing(N,p)\n\nN qubit depolarizing noise channel.\n\nThe Kraus operators for the depolarizing channel are given by\n\nE_1 = sqrt1-p I_N quad E_i = sqrtp(4^N-1) P_i\n\nwhere pin 01 is a probability, and P_i is anN-qubit Pauli string operator ie a tensor product of one-qubit Pauli operators (see Paulistring(ref)) There is exactly one Kraus operatorE{i>1}for each distinct combination of Pauli operatorsPi except for theN-qubit identityI_N = I\\otimes I \\otimes I \\otimes...``\n\nFor example, for one qubit we have 3 operators P_i in XYZ, and for two qubits we have 15 operators P_i in  Iotimes X Iotimes Y Iotimes Z Xotimes I Yotimes I Zotimes I Xotimes X Xotimes Y Xotimes Z Yotimes X Yotimes Y Yotimes Z Zotimes X Zotimes Y Zotimes Z . Use unitarygates to see this.\n\nThis channel is a mixed unitary channel, see ismixedunitary, and is a special case of PauliNoise.\n\nSee also PauliString and PauliNoise.\n\nArguments\n\nN: Number of qubits.\np: Probability of error, i.e. of not applying identity.\n\nExamples\n\nDepolarizing channels can be defined for any N:\n\njulia> push!(Circuit(), Depolarizing(1, 0.1), 1)\n1-qubit circuit with 1 instructions:\n└── Depolarizing(1,0.1) @ q[1]\n\njulia> push!(Circuit(), Depolarizing(5, 0.1), 1, 2, 3, 4, 5)\n5-qubit circuit with 1 instructions:\n└── Depolarizing(5,0.1) @ q[1:5]\n\nFor one and two qubits you can use the shorthand notation:\n\njulia> push!(Circuit(), Depolarizing1(0.1), 1)\n1-qubit circuit with 1 instructions:\n└── Depolarizing(1,0.1) @ q[1]\n\njulia> push!(Circuit(), Depolarizing2(0.1), 1, 2)\n2-qubit circuit with 1 instructions:\n└── Depolarizing(2,0.1) @ q[1:2]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.Depolarizing1","page":"Noise","title":"MimiqCircuitsBase.Depolarizing1","text":"Depolarizing1(p) Doc TODO\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.Depolarizing2","page":"Noise","title":"MimiqCircuitsBase.Depolarizing2","text":"Depolarizing2(p) Doc TODO\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PauliNoise","page":"Noise","title":"MimiqCircuitsBase.PauliNoise","text":"PauliNoise(p, paulistrings)\n\nN qubit Pauli noise channel specified by a list of probabilities and Pauli gates.\n\nA Pauli channel is defined by\n\nmathcalE(rho) = sum_k p_k P_k rho P_k\n\nwhere 0 leq p_k leq 1 and P_k are Pauli string operators, defined as tensor products of one-qubit Pauli operators (see PauliString) The probabilities must fulfill sum_k p_k = 1.\n\nThis channel is a mixed unitary channel, see ismixedunitary.\n\nSee also Depolarizing, PauliX, PauliY, PauliZ, which are special cases of PauliNoise.\n\nArguments\n\np: Vector of probabilities that must add up to 1.\npaulistrings: Vector of strings, each one of length N and with each character being either \"I\", \"X\", \"Y\", or \"Z\". The number of qubits is equal to N.\n\nThe vectors p and paulistrings must have the same length.\n\nExamples\n\nPauliNoise channels can be defined for any number of qubits, and for any number of Pauli strings.\n\njulia> push!(Circuit(), PauliNoise([0.8, 0.1, 0.1], [\"I\",\"X\",\"Y\"]), 1)\n1-qubit circuit with 1 instructions:\n└── PauliNoise((0.8,pauli\"I\"),(0.1,pauli\"X\"),(0.1,pauli\"Y\")) @ q[1]\n\njulia> push!(Circuit(), PauliNoise([0.9, 0.1], [\"XY\",\"II\"]), 1, 2)\n2-qubit circuit with 1 instructions:\n└── PauliNoise((0.9,pauli\"XY\"),(0.1,pauli\"II\")) @ q[1:2]\n\njulia> push!(Circuit(), PauliNoise([0.5, 0.2, 0.2, 0.1], [\"IXIX\",\"XYXY\",\"ZZZZ\",\"IXYZ\"]), 1, 2, 3, 4)\n4-qubit circuit with 1 instructions:\n└── PauliNoise((0.5,pauli\"IXIX\"),(0.2,pauli\"XYXY\"),(0.2,pauli\"ZZZZ\"),(0.1,pauli\"IXYZ\")) @ q[1:4]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PauliX","page":"Noise","title":"MimiqCircuitsBase.PauliX","text":"PauliX(p)\n\nOne-qubit Pauli X noise channel (bit flip error).\n\nThis channel is defined by the Kraus operators\n\nE_1 = sqrt1-pI quad E_2 = sqrtpX\n\nwhere 0 leq p leq 1.\n\nThis channel is a mixed unitary channel, see ismixedunitary, and is a special case of PauliNoise.\n\nPauliX(p) is the same as PauliNoise([1-p,p],[\"I\",\"X\"]).\n\nExamples\n\njulia> push!(Circuit(), PauliX(0.1), 1)\n1-qubit circuit with 1 instructions:\n└── PauliX(0.1) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PauliY","page":"Noise","title":"MimiqCircuitsBase.PauliY","text":"PauliY(p)\n\nOne-qubit Pauli Y noise channel (bit-phase flip error).\n\nThis channel is determined by the Kraus operators\n\nE_1 = sqrt1-pI quad E_2 = sqrtpY\n\nwhere 0leq p leq 1.\n\nThis channel is a mixed unitary channel, see ismixedunitary, and is a special case of PauliNoise.\n\nPauliY(p) is the same as PauliNoise([1-p,p],[\"I\",\"Y\"]).\n\nExamples\n\njulia> push!(Circuit(), PauliY(0.1), 1)\n1-qubit circuit with 1 instructions:\n└── PauliY(0.1) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PauliZ","page":"Noise","title":"MimiqCircuitsBase.PauliZ","text":"PauliZ(p)\n\nOne-qubit Pauli Z noise channel (phase flip error).\n\nThis channel is determined by the Kraus operators\n\nE_1 = sqrt1-pI quad E_2 = sqrtpZ\n\nwhere 0 leq p leq 1.\n\nThis channel is a mixed unitary channel, see ismixedunitary, and is a special case of PauliNoise.\n\nPauliZ(p) is the same as PauliNoise([1-p,p],[\"I\",\"Z\"]).\n\nExamples\n\njulia> push!(Circuit(), PauliZ(0.1), 1)\n1-qubit circuit with 1 instructions:\n└── PauliZ(0.1) @ q[1]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.MixedUnitary","page":"Noise","title":"MimiqCircuitsBase.MixedUnitary","text":"MixedUnitary(p,U)\n\nCustom N qubit mixed unitary channel specified by a list of unitary gates and a list of probabilities that add up to 1.\n\nA mixed unitary noise channel is defined by\n\nmathcalE(rho) = sum_k p_k U_k rho U_k^dagger\n\nwhere 0leq p_k leq 1 and U_k are unitary matrices. The probabilities must fulfill sum_k p_k = 1.\n\nIf your Kraus matrices are not all proportional to unitaries, use Kraus instead.\n\nThe Kraus matrices are defined in the computational basis in the usual textbook order (the first qubit corresponds to the left-most qubit). For 1 qubit we have 0rangle, 1rangle. For 2 qubits we have 00rangle, 01rangle, 10rangle, 11rangle. See also GateCustom.\n\nnote: Note\nCurrently only 1 and 2-qubit custom MixedUnitary channels are supported.\n\nSee also Kraus, ismixedunitary, AbstractKrausChannel, and RescaledGate.\n\nArguments\n\np: Vector of probabilities, must be positive real numbers and add up to 1.\nU: Vector of either complex-valued 2^N times 2^N matrices or unitary gates acting on N qubits. Both can be mixed.\n\nThe length of the vectors p and U must be equal.\n\nExamples\n\njulia> push!(Circuit(), MixedUnitary([0.9, 0.1], [[1 0; 0 1], [0 1; 1 0]]), 1)\n1-qubit circuit with 1 instructions:\n└── MixedUnitary((0.9,Custom([1.0 0.0; 0.0 1.0])),(0.1,Custom([0.0 1.0; 1.0 0.0]))) @ q[1]\n\njulia> push!(Circuit(), MixedUnitary([0.8, 0.2], [GateID(), GateRX(0.2)]), 1)\n1-qubit circuit with 1 instructions:\n└── MixedUnitary((0.8,ID),(0.2,RX(0.2))) @ q[1]\n\njulia> push!(Circuit(), MixedUnitary([0.8, 0.2], [[1 0; 0 1], GateRX(0.2)]), 1)\n1-qubit circuit with 1 instructions:\n└── MixedUnitary((0.8,Custom([1.0 0.0; 0.0 1.0])),(0.2,RX(0.2))) @ q[1]\n\njulia> @variables x\n1-element Vector{Symbolics.Num}:\n x\n\njulia> g= MixedUnitary([0.9, x], [[1 0; 0 1], [0 1; 1 0]])\nMixedUnitary((0.9, Custom([1.0 0.0; 0.0 1.0])), (x, Custom([0.0 1.0; 1.0 0.0])))\n\njulia> evaluate(g,Dict(x=>.1))\nMixedUnitary((0.9, Custom([1.0 0.0; 0.0 1.0])), (0.1, Custom([0.0 1.0; 1.0 0.0])))\n\njulia> g= MixedUnitary([0.9, 0.1], [[1 0; 0 1], [0 1; 1 x]])\nMixedUnitary((0.9, Custom([1 0; 0 1])), (0.1, Custom([0 1; 1 x])))\n\njulia> evaluate(g,Dict(x=>0))\nMixedUnitary((0.9, Custom([1 0; 0 1])), (0.1, Custom([0 1; 1 0])))\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PauliString","page":"Noise","title":"MimiqCircuitsBase.PauliString","text":"PauliString(paulistr)\n\nN-qubit tensor product of Pauli operators.\n\nThe PauliString gate can represent any N-qubit tensor product of Pauli operators of the form\n\nP_1 otimes P_2 otimes P_3 otimes ldots otimes P_N\n\nwhere each P_i in  I X Y Z  is a Pauli operator, including the identity.\n\nSee also GateID, GateX, GateY, GateZ.\n\nArguments\n\npaulistr: string of length N where each character is either \"I\", \"X\", \"Y\", or \"Z\". The number of qubits is equal to N.\n\nExamples\n\nPauliStrings of any length are supported.\n\njulia> c = push!(Circuit(), PauliString(\"XX\"), 1, 2)\n2-qubit circuit with 1 instructions:\n└── XX @ q[1:2]\n\njulia> push!(c, PauliString(\"IXYZZYXI\"), 1, 2, 3, 4, 5, 6, 7, 8)\n8-qubit circuit with 2 instructions:\n├── XX @ q[1:2]\n└── IXYZZYXI @ q[1:8]\n\nDecomposition\n\nDecomposes into one-qubit Pauli gates.\n\njulia> decompose(PauliString(\"XIYZZ\"))\n5-qubit circuit with 5 instructions:\n├── X @ q[1]\n├── ID @ q[2]\n├── Y @ q[3]\n├── Z @ q[4]\n└── Z @ q[5]\n\n\n\n\n\n","category":"type"},{"location":"library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.@pauli_str-Tuple{Any}","page":"Noise","title":"MimiqCircuitsBase.@pauli_str","text":"macro pauli_str(s)\n\npauli\"\" literal for creating a PauliString gate.\n\nExamples\n\njulia> pauli\"XYYXZ\"\nXYYXZ\n\n\n\n\n\n\n","category":"macro"}]
}
