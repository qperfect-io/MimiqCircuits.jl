<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Noise · MimiqCircuits.jl</title><meta name="title" content="Noise · MimiqCircuits.jl"/><meta property="og:title" content="Noise · MimiqCircuits.jl"/><meta property="twitter:title" content="Noise · MimiqCircuits.jl"/><meta name="description" content="Documentation for MimiqCircuits.jl."/><meta property="og:description" content="Documentation for MimiqCircuits.jl."/><meta property="twitter:description" content="Documentation for MimiqCircuits.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MimiqCircuits.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MimiqCircuits.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">MIMIQ Documentation</a></li><li><a class="tocitem" href="../../quick_start/">Quick start</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../circuits/">Circuits</a></li><li><a class="tocitem" href="../unitary_gates/">Unitary Gates</a></li><li><a class="tocitem" href="../non_unitary_ops/">Non-unitary Operations</a></li><li class="is-active"><a class="tocitem" href>Noise</a><ul class="internal"><li><a class="tocitem" href="#Summary-of-noise-functionality"><span>Summary of noise functionality</span></a></li><li><a class="tocitem" href="#Mathematical-background"><span>Mathematical background</span></a></li><li><a class="tocitem" href="#Building-noise-channels"><span>Building noise channels</span></a></li><li><a class="tocitem" href="#How-to-add-noise"><span>How to add noise</span></a></li><li><a class="tocitem" href="#Running-a-noisy-circuit"><span>Running a noisy circuit</span></a></li></ul></li><li><a class="tocitem" href="../symbolic_ops/">Symbolic Operations</a></li><li><a class="tocitem" href="../statistical_ops/">Statistical Operations</a></li><li><a class="tocitem" href="../special_ops/">Special Operations</a></li><li><a class="tocitem" href="../simulation/">Simulating Circuits</a></li><li><a class="tocitem" href="../remote_execution/">Cloud Execution</a></li><li><a class="tocitem" href="../import_export/">Import &amp; Export Circuits</a></li><li><a class="tocitem" href="../special_topics/">Special Topics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/outline/">Outline</a></li><li><a class="tocitem" href="../../library/mimiqcircuits/">MimiqCircuits</a></li><li><a class="tocitem" href="../../library/mimiqlink/">MimiqLink</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">MimiqCircuitsBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/mimiqcircuitsbase/general/">General functions</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/circuits/">Quantum Circuits and Instructions</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/operations/">Operations</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/standard/">Standard Gates</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/generalized/">Generalized gates</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/other/">Other Operations</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/noise/">Noise</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/operators/">Operators</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/bitstrings/">Bit Strings</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/results/">Quantum Circuit Simulation Results</a></li></ul></li><li><a class="tocitem" href="../../library/internals/">Internals</a></li><li><a class="tocitem" href="../../library/function_index/">Function Index</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Noise</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Noise</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/qperfect-io/MimiqCircuits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/qperfect-io/MimiqCircuits.jl/blob/main/docs/src/manual/noise.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Noisy-simulations-on-MIMIQ"><a class="docs-heading-anchor" href="#Noisy-simulations-on-MIMIQ">Noisy simulations on MIMIQ</a><a id="Noisy-simulations-on-MIMIQ-1"></a><a class="docs-heading-anchor-permalink" href="#Noisy-simulations-on-MIMIQ" title="Permalink"></a></h1><p>Here we explain how to run noisy simulations that mimic the behavior of real quantum computers on MIMIQ. In this section you&#39;ll find:</p><ul><li><a href="#noisy-simulations-on-mimiq">Noisy simulations on MIMIQ</a></li></ul><pre><code class="nohighlight hljs">- [Summary of noise functionality](#summary-of-noise-functionality)
- [Mathematical background](#mathematical-background)
	- [Kraus operators](#kraus-operators)
	- [Evolution with noise](#evolution-with-noise)
- [Building noise channels](#building-noise-channels)
- [How to add noise](#how-to-add-noise)
	- [Adding noise one by one](#adding-noise-one-by-one)
	- [Adding noise to all gates of same type](#adding-noise-to-all-gates-of-same-type)
- [Running a noisy circuit](#running-a-noisy-circuit)</code></pre><h2 id="Summary-of-noise-functionality"><a class="docs-heading-anchor" href="#Summary-of-noise-functionality">Summary of noise functionality</a><a id="Summary-of-noise-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-of-noise-functionality" title="Permalink"></a></h2><p>Custom noise channels:</p><ul><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.Kraus"><code>Kraus</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.MixedUnitary"><code>MixedUnitary</code></a></li></ul><p>Specialized noise channels:</p><ul><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.Depolarizing"><code>Depolarizing</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.Depolarizing1"><code>Depolarizing1</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.Depolarizing2"><code>Depolarizing2</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PauliNoise"><code>PauliNoise</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PauliX"><code>PauliX</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PauliY"><code>PauliY</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PauliZ"><code>PauliZ</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.AmplitudeDamping"><code>AmplitudeDamping</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.GeneralizedAmplitudeDamping"><code>GeneralizedAmplitudeDamping</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PhaseAmplitudeDamping"><code>PhaseAmplitudeDamping</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.ThermalNoise"><code>ThermalNoise</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.ProjectiveNoise"><code>ProjectiveNoise</code></a></li></ul><p>Note that the <a href="../non_unitary_ops/#Reset"><code>Reset</code></a> type operations can also be thought of as noisy operations. Coherent noise can be added by using any of the supported gates (<a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.GATES">MimiqCircuitsBase.GATES</a>).</p><p>Noise channels come with the following methods:</p><ul><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.krausmatrices-Tuple{AbstractKrausChannel}"><code>krausmatrices</code></a> and <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.krausoperators-Tuple{AbstractKrausChannel}"><code>krausoperators</code></a></li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.unitarymatrices-Tuple{AbstractKrausChannel}"><code>unitarymatrices</code></a> and <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.unitarygates-Tuple{AbstractKrausChannel}"><code>unitarygates</code></a> (only for mixed-unitary)</li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.probabilities-Tuple{AbstractKrausChannel}"><code>probabilities</code></a> (only for mixed-unitary)</li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a></li></ul><p>To add noise channels to a circuit you can use:</p><ul><li><a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> (like gates)</li><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.add_noise-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}"><code>add_noise</code></a> or <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.add_noise!-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}"><code>add_noise!</code></a> (add noise to every instance of a gate)</li></ul><p>To generate one sample of a circuit with mixed unitaries use:</p><ul><li><a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.sample_mixedunitaries-Tuple{Circuit}"><code>sample_mixedunitaries</code></a></li></ul><p>See below for further information. You can also run <code>?</code> followed by the given function in the command line (e.g. <code>?Kraus</code>), or using <code>@doc</code> in Jupyter (e.g. <code>@doc Kraus</code>).</p><h2 id="Mathematical-background"><a class="docs-heading-anchor" href="#Mathematical-background">Mathematical background</a><a id="Mathematical-background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-background" title="Permalink"></a></h2><h3 id="Kraus-operators"><a class="docs-heading-anchor" href="#Kraus-operators">Kraus operators</a><a id="Kraus-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Kraus-operators" title="Permalink"></a></h3><p>Noise in a quantum circuit refers to any kind of unwanted interaction of the qubits with the environment (or with itself). Mathematically, this puts us in the framework of <em>open</em> systems and the state of the qubits now needs to be described in terms of a density matrix <span>$\rho$</span>, which fulfills <span>$\rho=\rho^\dagger$</span>, <span>$\mathrm{Tr} \rho = 1$</span>. A quantum operation such as noise can then be described using the <em>Kraus</em> operator representation as</p><p class="math-container">\[	\mathcal{E}(\rho) = \sum_k E_k \rho E_k^\dagger.\]</p><p>We consider only <em>completely positive and trace preserving</em> (CPTP) operations. In this case, the Kraus operators <span>$E_k$</span> can be any matrix as long as the fulfill the completeness relation <span>$\sum_k E_k^\dagger E_k = I$</span>. Note that unitary gates <span>$U$</span> just correspond to a single Kraus operator, <span>$E_1=U$</span>.</p><p>When all Kraus operators are proportional to a unitary matrix, <span>$E_k = \alpha_k U_k$</span>, this is called a <em>mixed-unitary</em> quantum operation and can be written as (<span>$p_k = |\alpha_k|^2$</span>)</p><p class="math-container">\[	\mathcal{E}(\rho) = \sum_k p_k U_k \rho U_k^\dagger.\]</p><p>Such operations are easier to implement as we&#39;ll see below.</p><p>Remarks:</p><ul><li>Unitary gates <span>$U$</span> just correspond to a single Kraus operator, <span>$E_1=U$</span>.</li><li>The number of Kraus operators depends on the noise considered.</li><li>For a given quantum operation <span>$\mathcal{E}$</span> the Kraus operator representation is not unique. One can change the basis of Kraus operators using a unitary matrix <span>$U$</span> as <span>$\tilde{E}_i = \sum_j U_{ij} E_j$</span>.</li></ul><p>We define a <em>noise channel</em> (or <em>Kraus channel</em>) as a quantum operation <span>$\mathcal{E}$</span> described by a set of Kraus operators as given above. A common way of modeling noisy quantum computers is by considering each operation <span>$O$</span> that happens in the circuit as a noisy quantum operation <span>$\mathcal{E}_O$</span>. The full noisy operation can in principle be described using Kraus operators, but usually it is decomposed as <span>$\tilde{O} = \mathcal{E}_2 \circ O \circ \mathcal{E}_1$</span>, where <span>$\mathcal{E}_1$</span> and <span>$\mathcal{E}_2$</span> are noise channels. In the case of gates we usually only consider a noise channel after the gate. Note that one common assumption in this type of noise modeling is that the noise channels of different gates are independent from each other.</p><p>For more details on noise see for example <em>Nielsen and Chuang, Quantum Computation and Quantum Information, Chapter 8</em>.</p><h3 id="Evolution-with-noise"><a class="docs-heading-anchor" href="#Evolution-with-noise">Evolution with noise</a><a id="Evolution-with-noise-1"></a><a class="docs-heading-anchor-permalink" href="#Evolution-with-noise" title="Permalink"></a></h3><p>There are two common ways to evolve the state of the system when acting with Kraus channels as defined above:</p><ol><li><p><strong>Density matrix:</strong> If we use a density matrix to describe the qubits, then a Kraus channel can simply be applied by directly performing the matrix multiplications as <span>$\mathcal{E}(\rho) = \sum_k E_k \rho E_k^\dagger$</span>. The advantage of this approach is that the density matrix contains the full information of the system and we only need to run the circuit once. The disadvantage is that <span>$\rho$</span> requires more memory to be stored (<span>$2^{2N}$</span> as opposed to <span>$2^N$</span> for a state vector) so we can simulate fewer qubits.</p></li><li><p><strong>Quantum trajectories:</strong> This method consists in simulating the evolution of the state vector <span>$|\psi_\alpha \rangle$</span> for a set of iterations <span>$\alpha = 1, \ldots, n$</span>. In each iteration a noise channel is applied by randomly selecting one of the Kraus operators according to some probabilities (see below) and applying that Kraus operator to the state vector. The advantage of this approach is that we need less memory since we work with a state vector. The disadvantage is that we need to run the circuit many times to collect samples (one sample per run).</p></li></ol><p>Currently, MIMIQ only implements the quantum trajectories method.</p><p>The basis for quantum trajectories is that a Kraus channel can be rewritten as</p><p class="math-container">\[	\mathcal{E}(\rho) = \sum_k p_k \tilde{E}_k \rho \tilde{E}_k^\dagger,\]</p><p>where <span>$p_k = \mathrm{Tr}(E_k \rho E_k^\dagger)$</span> and <span>$\tilde{E}_k = E_k / \sqrt{p_k}$</span>. The parameters <span>$p_k$</span> can be interpreted as probabilities since they fulfill <span>$0 \leq p_k \leq 1$</span> and <span>$\sum_k p_k = 1$</span>. In this way, the Kraus channel can be viewed as a linear combination of operations with different Kraus operators weighted by the probabilities <span>$p_k$</span>. Note that the probabilities <span>$p_k$</span> generally depend on the state, so they need to be computed at runtime. The exception is mixed-unitary channels, for which the probabilities are fixed (state-independent), see above.</p><h2 id="Building-noise-channels"><a class="docs-heading-anchor" href="#Building-noise-channels">Building noise channels</a><a id="Building-noise-channels-1"></a><a class="docs-heading-anchor-permalink" href="#Building-noise-channels" title="Permalink"></a></h2><p>You can create noise channels using one of the many functions available, see <a href="#summary-of-noise-functionality">summary</a>. Most of the noise channels take one or more parameters, and the custom channels require passing the Kraus matrices and/or probabilities. Here are some examples of how to build noise channels:</p><pre><code class="language-julia hljs">using MimiqCircuits
p = 0.1    # probability
PauliX(p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PauliX(0.1)</code></pre><pre><code class="language-julia hljs">p, gamma = 0.1, 0.2    # parameters
GeneralizedAmplitudeDamping(p,gamma)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GeneralizedAmplitudeDamping(0.1, 0.2)</code></pre><pre><code class="language-julia hljs">ps = [0.8,0.1,0.1]    # probabilities
paulis = [&quot;II&quot;,&quot;XX&quot;,&quot;YY&quot;]    # Pauli strings
PauliNoise(ps,paulis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PauliNoise((0.8, pauli&quot;II&quot;), (0.1, pauli&quot;XX&quot;), (0.1, pauli&quot;YY&quot;))</code></pre><pre><code class="language-julia hljs">ps = [0.9, 0.1]    # probabilities
unitaries = [[1 0; 0 1], [1 0; 0 -1]]    # unitary matrices
MixedUnitary(ps, unitaries)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MixedUnitary((0.9, Custom([1.0 0.0; 0.0 1.0])), (0.1, Custom([1.0 0.0; 0.0 -1.0])))</code></pre><pre><code class="language-julia hljs">kmatrices = [[1 0; 0 sqrt(0.9)], [0 sqrt(0.1); 0 0]]    # Kraus matrices
Kraus(kmatrices)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Kraus(Operator([1.0 0.0; 0.0 0.948683]), Operator([0.0 0.316228; 0.0 0.0]))</code></pre><p>Check the documentation of each noise channel to understand the conditions that each of the parameters needs to fulfill for the noise channel to be valid.</p><p>In MIMIQ the most important distinction of noise channels is between <em>mixed unitary</em> and general Kraus channels (see <a href="#mathematical-background">mathematical section</a> for definitions). You can use <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a> to check if a channel is mixed unitary or not like this:</p><pre><code class="language-julia hljs">ismixedunitary(PauliX(0.1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">ismixedunitary(AmplitudeDamping(0.1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><p>In both cases you can get the Kraus matrices/operators used to define the given channel by using <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.krausmatrices-Tuple{AbstractKrausChannel}"><code>krausmatrices</code></a> or <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.krausoperators-Tuple{AbstractKrausChannel}"><code>krausoperators</code></a>. For example:</p><pre><code class="language-julia hljs">krausmatrices(ProjectiveNoise(&quot;Z&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Matrix{Int64}}:
 [1 0; 0 0]
 [0 0; 0 1]</code></pre><p>In the case of mixed unitary channels, you can separately obtain the list of probabilities and the list of unitary gates/matrices using <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.probabilities-Tuple{AbstractKrausChannel}"><code>probabilities</code></a> and <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.unitarymatrices-Tuple{AbstractKrausChannel}"><code>unitarymatrices</code></a>  or <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.unitarygates-Tuple{AbstractKrausChannel}"><code>unitarygates</code></a>, respectively.</p><pre><code class="language-julia hljs">unitarymatrices(PauliZ(0.1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Matrix{Float64}}:
 [1.0 -0.0; 0.0 1.0]
 [1.0 0.0; 0.0 -1.0]</code></pre><pre><code class="language-julia hljs">unitarygates(Depolarizing1(0.1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{AbstractGate{1}}:
 ID
 X
 Y
 Z</code></pre><pre><code class="language-julia hljs">probabilities(PauliNoise([0.1,0.9],[&quot;II&quot;,&quot;ZZ&quot;]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×2 Matrix{Float64}:
 0.1  0.9</code></pre><p>In MIMIQ, noise channels can be added at any point in the circuit in order to make any operation noisy. For noisy gates, one would normally add a noise channel after an ideal gate. To model measurement, preparation and reset errors one can simply add noise channels before and/or after the corresponding operation. More information in the next section.</p><h2 id="How-to-add-noise"><a class="docs-heading-anchor" href="#How-to-add-noise">How to add noise</a><a id="How-to-add-noise-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-add-noise" title="Permalink"></a></h2><h3 id="Adding-noise-one-by-one"><a class="docs-heading-anchor" href="#Adding-noise-one-by-one">Adding noise one by one</a><a id="Adding-noise-one-by-one-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-noise-one-by-one" title="Permalink"></a></h3><p>The simplest and most flexible way to add noise to a circuit is by using <code>push!</code>(@ref), the same way that we add gates. Here&#39;s an example of how to create a noisy 5-qubit GHZ circuit:</p><pre><code class="language-julia hljs">c = Circuit()
push!(c, PauliX(0.1), 1:5)    # preparation/reset error since all qubits start in 0

push!(c, GateH(), 1)
push!(c, AmplitudeDamping(0.1), 1)    # 1-qubit noise for GateH

push!(c, GateCX(), 1, 2:5)
push!(c, Depolarizing2(0.1), 1, 2:5)    # 2-qubit noise for GateCX

push!(c, PauliX(0.1), 1:5)    # measurement error. Note it&#39;s added before the measurement
push!(c, Measure(), 1:5, 1:5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-qubit circuit with 25 instructions:
├── PauliX(0.1) @ q[1]
├── PauliX(0.1) @ q[2]
├── PauliX(0.1) @ q[3]
├── PauliX(0.1) @ q[4]
├── PauliX(0.1) @ q[5]
├── H @ q[1]
├── AmplitudeDamping(0.1) @ q[1]
├── CX @ q[1], q[2]
├── CX @ q[1], q[3]
⋮   ⋮
├── PauliX(0.1) @ q[1]
├── PauliX(0.1) @ q[2]
├── PauliX(0.1) @ q[3]
├── PauliX(0.1) @ q[4]
├── PauliX(0.1) @ q[5]
├── M @ q[1], c[1]
├── M @ q[2], c[2]
├── M @ q[3], c[3]
├── M @ q[4], c[4]
└── M @ q[5], c[5]</code></pre><p>Note how we added bit-flip error (<a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.PauliX"><code>PauliX</code></a>) at beginning for state preparation/reset errors and right before measuring for measurement errors.</p><h3 id="Adding-noise-to-all-gates-of-same-type"><a class="docs-heading-anchor" href="#Adding-noise-to-all-gates-of-same-type">Adding noise to all gates of same type</a><a id="Adding-noise-to-all-gates-of-same-type-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-noise-to-all-gates-of-same-type" title="Permalink"></a></h3><p>Usually, when we add noise to a circuit we want to add the same type of noise to each instance of a given gate. For this purpose, instead of adding noise channels one by one you can use <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.add_noise-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}"><code>add_noise</code></a> or <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.add_noise!-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}"><code>add_noise!</code></a> (same but in-place). It takes several parameters:</p><p><code>add_noise(c, g, kraus; before=false, parallel=false)</code></p><p>This function will add the noise channel specified by <code>kraus</code> to every instance of gate <code>g</code> in the circuit <code>c</code>. The optional parameter <code>before</code> (default=<code>false</code>) determines whether to add the noise before or after the operation, and the parameter <code>parallel</code> (default=<code>false</code>) determines whether to add the noise in parallel after/before a block of transversal gates.</p><p>Here is how to construct the same example of a noisy GHZ circuit as before but with <code>add_noise</code>:</p><pre><code class="language-julia hljs">c = Circuit()
push!(c, Reset(), 1:5)
push!(c, GateH(), 1)
push!(c, GateCX(), 1, 2:5)
push!(c, Measure(), 1:5, 1:5)

cnoise = add_noise(c, Reset(), PauliX(0.1); parallel=true)
cnoise = add_noise(cnoise, GateH(), AmplitudeDamping(0.1))
cnoise = add_noise(cnoise, GateCX(), Depolarizing2(0.1); parallel=true)
cnoise = add_noise(cnoise, Measure(), PauliX(0.1); before=true, parallel=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-qubit circuit with 30 instructions:
├── Reset @ q[1]
├── Reset @ q[2]
├── Reset @ q[3]
├── Reset @ q[4]
├── Reset @ q[5]
├── PauliX(0.1) @ q[1]
├── PauliX(0.1) @ q[2]
├── PauliX(0.1) @ q[3]
├── PauliX(0.1) @ q[4]
⋮   ⋮
├── PauliX(0.1) @ q[1]
├── PauliX(0.1) @ q[2]
├── PauliX(0.1) @ q[3]
├── PauliX(0.1) @ q[4]
├── PauliX(0.1) @ q[5]
├── M @ q[1], c[1]
├── M @ q[2], c[2]
├── M @ q[3], c[3]
├── M @ q[4], c[4]
└── M @ q[5], c[5]</code></pre><p>Note that we added a trivial <code>Reset</code> operation at the very beginning just to be able to add the state preparation error with the <code>add_noise</code> functionality. The qubits already start at 0 anyway.</p><p>The <code>add_noise</code> function becomes particularly useful in big circuits with lots of repetitions of gates. For further details check the API documentation of <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.add_noise-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}"><code>add_noise</code></a> and <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.add_noise!-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}"><code>add_noise!</code></a>.</p><h2 id="Running-a-noisy-circuit"><a class="docs-heading-anchor" href="#Running-a-noisy-circuit">Running a noisy circuit</a><a id="Running-a-noisy-circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Running-a-noisy-circuit" title="Permalink"></a></h2><p>Circuits with noise can be run with the same <a href="../../library/mimiqcircuits/#MimiqCircuits.execute"><code>execute</code></a> function as used for circuits without noise, see <a href="../simulation/">simulation</a> and <a href="../remote_execution/">cloud execution</a> pages. Recall that currently noisy simulations will be run using <a href="#evolution-with-noise">quantum trajectories</a>. In this case, when running a circuit with noise for <code>n</code> samples the circuit will internally be run once for every sample. In every run, a different set of random Kraus operators will be selected based on the corresponding probabilities.</p><p>When the noise channel is a mixed unitary channel the unitary operators to be applied can be selected before starting to apply operations on the state. We provide the function <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.sample_mixedunitaries-Tuple{Circuit}"><code>sample_mixedunitaries</code></a> to generate samples of a circuit with mixed unitary noise as follows:</p><pre><code class="language-julia hljs">using Random
rng = MersenneTwister(42)

c = Circuit()
push!(c, Depolarizing1(0.5), 1:5)

# Produce a circuit with either I, X, Y, or Z in place of each depolarizing channel
csampled = sample_mixedunitaries(c; rng=rng, ids=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-qubit circuit with 5 instructions:
├── Y @ q[1]
├── ID @ q[2]
├── ID @ q[3]
├── ID @ q[4]
└── ID @ q[5]</code></pre><p>This function is internally called when executing a circuit, but can also be used outside of execution.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../non_unitary_ops/">« Non-unitary Operations</a><a class="docs-footer-nextpage" href="../symbolic_ops/">Symbolic Operations »</a><div class="flexbox-break"></div><p class="footer-message">Copyright 2021-2024 QPerfect. All rights reserved.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 24 November 2024 19:45">Sunday 24 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
