<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Non-unitary Operations · MimiqCircuits.jl</title><meta name="title" content="Non-unitary Operations · MimiqCircuits.jl"/><meta property="og:title" content="Non-unitary Operations · MimiqCircuits.jl"/><meta property="twitter:title" content="Non-unitary Operations · MimiqCircuits.jl"/><meta name="description" content="Documentation for MimiqCircuits.jl."/><meta property="og:description" content="Documentation for MimiqCircuits.jl."/><meta property="twitter:description" content="Documentation for MimiqCircuits.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MimiqCircuits.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MimiqCircuits.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">MIMIQ Documentation</a></li><li><a class="tocitem" href="../../quick_start/">Quick start</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../circuits/">Circuits</a></li><li><a class="tocitem" href="../unitary_gates/">Unitary Gates</a></li><li class="is-active"><a class="tocitem" href>Non-unitary Operations</a><ul class="internal"><li><a class="tocitem" href="#Measure"><span>Measure</span></a></li><li><a class="tocitem" href="#Reset"><span>Reset</span></a></li><li><a class="tocitem" href="#Measure-Reset"><span>Measure-Reset</span></a></li><li><a class="tocitem" href="#Conditional-logic"><span>Conditional logic</span></a></li><li><a class="tocitem" href="#Operators"><span>Operators</span></a></li></ul></li><li><a class="tocitem" href="../noise/">Noise</a></li><li><a class="tocitem" href="../symbolic_ops/">Symbolic Operations</a></li><li><a class="tocitem" href="../statistical_ops/">Statistical Operations</a></li><li><a class="tocitem" href="../special_ops/">Special Operations</a></li><li><a class="tocitem" href="../simulation/">Simulating Circuits</a></li><li><a class="tocitem" href="../remote_execution/">Cloud Execution</a></li><li><a class="tocitem" href="../import_export/">Import &amp; Export Circuits</a></li><li><a class="tocitem" href="../special_topics/">Special Topics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/outline/">Outline</a></li><li><a class="tocitem" href="../../library/mimiqcircuits/">MimiqCircuits</a></li><li><a class="tocitem" href="../../library/mimiqlink/">MimiqLink</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">MimiqCircuitsBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/mimiqcircuitsbase/general/">General functions</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/circuits/">Quantum Circuits and Instructions</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/operations/">Operations</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/standard/">Standard Gates</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/generalized/">Generalized gates</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/other/">Other Operations</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/noise/">Noise</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/operators/">Operators</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/bitstrings/">Bit Strings</a></li><li><a class="tocitem" href="../../library/mimiqcircuitsbase/results/">Quantum Circuit Simulation Results</a></li></ul></li><li><a class="tocitem" href="../../library/internals/">Internals</a></li><li><a class="tocitem" href="../../library/function_index/">Function Index</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Non-unitary Operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Non-unitary Operations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/qperfect-io/MimiqCircuits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/qperfect-io/MimiqCircuits.jl/blob/main/docs/src/manual/non_unitary_ops.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Non-unitary-Operations"><a class="docs-heading-anchor" href="#Non-unitary-Operations">Non-unitary Operations</a><a id="Non-unitary-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Non-unitary-Operations" title="Permalink"></a></h1><p>Contrary to <a href="../unitary_gates/">unitary gates</a>, non-unitary operations based on measurements make the quantum state collapse. Find in the following sections all the non-unitary operations supported by MIMIQ.</p><ul><li><a href="#non-unitary-operations">Non-unitary Operations</a><ul><li><a href="#measure">Measure</a><ul><li><a href="#mathematical-definition">Mathematical definition</a></li><li><a href="#how-to-use-measurements">How to use measurements</a></li></ul></li><li><a href="#reset">Reset</a></li><li><a href="#measure-reset">Measure-Reset</a></li><li><a href="#conditional-logic">Conditional logic</a><ul><li><a href="#if-statements">If statements</a></li></ul></li><li><a href="#operators">Operators</a><ul><li><a href="#mathematical-definition-1">Mathematical definition</a></li><li><a href="#operators-available-in-mimiq">Operators available in MIMIQ</a></li><li><a href="#how-to-use-operators">How to use operators</a></li></ul></li></ul></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>As a rule of thumb all non-unitary operations can be added to the circuit using the function <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> by giving the index of the targets in the following order: quantum register index -&gt; classical register index. </p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Noise can also be interpreted as a non-unitary operations but will not be treated here, check the <a href="../noise/">noise</a> documentation page to learn more about it.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Once a non-unitary operation is added to your circuit the speed of execution might be reduced. This is because in this case the circuit needs to be re-run for every sample since the final quantum state might be different each time. This is always true except for <a href="#Measure"><code>Measure</code></a> operations placed at the very end of a circuit. To learn more about this head to the <a href="../simulation/#understanding-sampling">simulation</a> page.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Some features of unitary gates are not available for non-unitary operations, for instance, <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.matrix">matrix</a>, <a href="../../library/mimiqcircuitsbase/general/#Symbolics.inverse">inverse</a>, <a href="../../library/mimiqcircuitsbase/general/#MimiqCircuitsBase.power">power</a>, <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.control">control</a>, <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.parallel">parallel</a>.</p></div></div><h2 id="Measure"><a class="docs-heading-anchor" href="#Measure">Measure</a><a id="Measure-1"></a><a class="docs-heading-anchor-permalink" href="#Measure" title="Permalink"></a></h2><h3 id="Mathematical-definition"><a class="docs-heading-anchor" href="#Mathematical-definition">Mathematical definition</a><a id="Mathematical-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-definition" title="Permalink"></a></h3><p>Measurements are defined by a basis of projection operators <span>$P_k$</span>, one for each different possible outcome <span>$k$</span>. The probability <span>$p_k$</span> of measuring outcome <span>$k$</span> is given by the expectation value of <span>$P_k$</span>, that is</p><p class="math-container">\[p_k = \bra{\psi} P_k \ket{\psi}.\]</p><p>If the outcome <span>$k$</span> is observed, the system is left in the state</p><p class="math-container">\[\frac{P_k\ket{\psi}}{\sqrt{p_k}} .\]</p><p>It is common to measure in the Z basis (<span>$P_0=\ket{0}\bra{0}$</span> and <span>$P_1=\ket{1}\bra{1}$</span>), but measurements in other bases are possible too.</p><h3 id="How-to-use-measurements"><a class="docs-heading-anchor" href="#How-to-use-measurements">How to use measurements</a><a id="How-to-use-measurements-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-use-measurements" title="Permalink"></a></h3><p>Available measurement operations: <a href="#Measure"><code>Measure</code></a>, <a href="../../library/mimiqcircuitsbase/general/#MimiqCircuitsBase.MeasureX"><code>MeasureX</code></a>, <a href="../../library/mimiqcircuitsbase/general/#MimiqCircuitsBase.MeasureY"><code>MeasureY</code></a>, <a href="../../library/mimiqcircuitsbase/general/#MimiqCircuitsBase.MeasureZ"><code>MeasureZ</code></a>, <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.MeasureXX"><code>MeasureXX</code></a>, <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.MeasureYY"><code>MeasureYY</code></a>, <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.MeasureZZ"><code>MeasureZZ</code></a>.</p><p>With MIMIQ you can measure the qubits at any point in the circuit (not only at the end of the circuit) using one of the measurement operations (<a href="#Measure"><code>Measure</code></a>...). You can add it to the circuit like gates using <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a>, but you will need to precise both the index for the quantum register (qubit to measure) and classical register (where to store the result):</p><pre><code class="language-julia hljs">using MimiqCircuits # hide
push!(circuit, Measure(), 1, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-qubit circuit with 1 instructions:
└── M @ q[1], c[1]</code></pre><p>This will add a <a href="#Measure">Measure</a> on the first qubit of the quantum register to the <code>circuit</code> and write the result on the first bit of the classical register. Recall that the targets are always ordered as quantum register -&gt; classical register -&gt; z register. To learn more about registers head to the <a href="../circuits/#registers-quantumclassicalz-register">circuit</a> page.  </p><p>You can also use iterators to Measure multiple qubits at once, as for gates:</p><pre><code class="language-julia hljs">push!(Circuit(), Measure(), 1:10, 1:10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-qubit circuit with 10 instructions:
├── M @ q[1], c[1]
├── M @ q[2], c[2]
├── M @ q[3], c[3]
├── M @ q[4], c[4]
├── M @ q[5], c[5]
├── M @ q[6], c[6]
├── M @ q[7], c[7]
├── M @ q[8], c[8]
├── M @ q[9], c[9]
└── M @ q[10], c[10]</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the absence of any non-unitary operations in the circuit, MIMIQ will sample (and, therefore, measure) all the qubits at the end of the circuit by default, see <a href="../simulation/">simulation</a> page.</p></div></div><h2 id="Reset"><a class="docs-heading-anchor" href="#Reset">Reset</a><a id="Reset-1"></a><a class="docs-heading-anchor-permalink" href="#Reset" title="Permalink"></a></h2><p>Available reset operations: <a href="#Reset"><code>Reset</code></a>, <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.ResetX"><code>ResetX</code></a>, <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.ResetY"><code>ResetY</code></a>, <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.ResetZ"><code>ResetZ</code></a>.</p><p>A reset operation consists in measuring the qubits in some basis and then applying an operation conditioned on the measurement outcome to leave the qubits in some pre-defined state. For example, <a href="#Reset">Reset</a> leaves all qubits in <span>$\ket{0}$</span> (by measuring in <span>$Z$</span> and flipping the state if the outcome is <code>1</code>).</p><p>Here is an example of how to add a reset operation to a circuit:</p><pre><code class="language-julia hljs">circuit = Circuit() # hide
push!(circuit, Reset(), 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-qubit circuit with 1 instructions:
└── Reset @ q[1]</code></pre><p>Importantly, even though a reset operation technically measures the qubits, the information is not stored in the classical register, so we only need to specify the qubit register. If you want to store the result, see the <a href="#measure-reset">measure-reset</a> section.</p><p>Note that a reset operation can be technically seen as noise and is described by the same mathematical machinery, see <a href="../noise/">noise</a> page. For this reason, some of the functionality provided by MIMIQ for noise is also available for resets. Here is one example:</p><pre><code class="language-julia hljs">krausoperators(Reset())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{AbstractOperator{1}}:
 P₀(1)
 SigmaMinus(1)</code></pre><h2 id="Measure-Reset"><a class="docs-heading-anchor" href="#Measure-Reset">Measure-Reset</a><a id="Measure-Reset-1"></a><a class="docs-heading-anchor-permalink" href="#Measure-Reset" title="Permalink"></a></h2><p>Available measure-reset operations: <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.MeasureReset"><code>MeasureReset</code></a>, <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.MeasureResetX"><code>MeasureResetX</code></a>, <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.MeasureResetY"><code>MeasureResetY</code></a>, <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.MeasureResetZ"><code>MeasureResetZ</code></a>.</p><p>A measure-reset operation is the same as a reset operation except that we store the result of the measurement, see <a href="#measure">measure</a> and <a href="#reset">reset</a> sections. Because of that, we need to specify both quantum and classical registers when adding it to a circuit:</p><pre><code class="language-julia hljs">circuit = Circuit() # hide
push!(circuit, MeasureReset(), 1, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-qubit circuit with 1 instructions:
└── MR @ q[1], c[1]</code></pre><h2 id="Conditional-logic"><a class="docs-heading-anchor" href="#Conditional-logic">Conditional logic</a><a id="Conditional-logic-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-logic" title="Permalink"></a></h2><h3 id="If-statements"><a class="docs-heading-anchor" href="#If-statements">If statements</a><a id="If-statements-1"></a><a class="docs-heading-anchor-permalink" href="#If-statements" title="Permalink"></a></h3><p>An <em>if</em> statement consists in applying an operation conditional on the value of some classical register. In that sense, it resembles a classical <em>if</em> statement.</p><p>In MIMIQ you can implement it using <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.IfStatement"><code>IfStatement</code></a>, which requires two arguments: an operation to apply and a <a href="../special_topics/#BitString"><code>BitString</code></a> as the condition (see <a href="../special_topics/#bitstring">bitstrings</a> page for more information):</p><pre><code class="language-julia hljs">IfStatement(GateX(), BitString(&quot;111&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">IF(c==111) X</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>At the moment, MIMIQ only allows to pass unitary gates as arguments to an if statement (which makes if statements unitary for now).</p></div></div><p>To add an <a href="../../library/mimiqcircuitsbase/operations/#MimiqCircuitsBase.IfStatement"><code>IfStatement</code></a> to a circuit use the <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}"><code>push!</code></a> function. The first (quantum) indices will determine the qubits to apply the gate to, whereas the last (classical) indices will be used to compare against the condition given. For example:</p><pre><code class="language-julia hljs"># Apply a GateX on qubit 1 if the qubits 2 and 4 are in the state 1 and qubit 3 in the state 0.
push!(circuit, IfStatement(GateX(), bs&quot;101&quot;), 1, 2, 3, 4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-qubit circuit with 1 instructions:
└── IF(c==101) X @ q[1], c[2:4]</code></pre><p>Here, an <code>X</code> gate will be applied to qubit 1, if classical registers 2 and 4 are <code>1</code>, and classical register 3 is <code>0</code>. Of course, if the gate targets more than 1 qubit, then all qubit indices will be specified before the classical registers, as usual (see <a href="../circuits/">circuit</a> page).</p><h2 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h2><h3 id="Mathematical-definition-2"><a class="docs-heading-anchor" href="#Mathematical-definition-2">Mathematical definition</a><a class="docs-heading-anchor-permalink" href="#Mathematical-definition-2" title="Permalink"></a></h3><p>Operators refer to any linear operation on a state. An operator does not need to be unitary, as is the case of a gate. This means that any <span>$2^N \times 2^N$</span> matrix can in principle represent an operator on <span>$N$</span> qubits.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Do not confuse <em>operator</em> with <em>operation</em>. In MIMIQ, the word operation is used as the supertype for all transformations of a quantum state (gates, measurements, statistical operations...), whereas an operator is a sort of generalized gate, a linear tranformation.</p></div></div><h3 id="Operators-available-in-MIMIQ"><a class="docs-heading-anchor" href="#Operators-available-in-MIMIQ">Operators available in MIMIQ</a><a id="Operators-available-in-MIMIQ-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-available-in-MIMIQ" title="Permalink"></a></h3><p>Custom operators: <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.Operator"><code>Operator</code></a></p><p>Special operators: <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.DiagonalOp"><code>DiagonalOp</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.SigmaPlus"><code>SigmaPlus</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.SigmaMinus"><code>SigmaMinus</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Projector0"><code>Projector0</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ProjectorZ0"><code>ProjectorZ0</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Projector1"><code>Projector1</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ProjectorZ1"><code>ProjectorZ1</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ProjectorX0"><code>ProjectorX0</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ProjectorX1"><code>ProjectorX1</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ProjectorY0"><code>ProjectorY0</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ProjectorY1"><code>ProjectorY1</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Projector00"><code>Projector00</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Projector01"><code>Projector01</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Projector10"><code>Projector10</code></a>, <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.Projector11"><code>Projector11</code></a></p><p>Methods available: <a href="../../library/mimiqcircuitsbase/other/#MimiqCircuitsBase.matrix"><code>matrix</code></a>.</p><h3 id="How-to-use-operators"><a class="docs-heading-anchor" href="#How-to-use-operators">How to use operators</a><a id="How-to-use-operators-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-use-operators" title="Permalink"></a></h3><p>Operators cannot be applied to a state directly (it cannot be added to a circuit using <a href="../../library/internals/#Base.push!-Tuple{Circuit, Instruction}">push!</a>), because that would correspond to an unphysical transformation. However, they can be used within other operations such as <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ExpectationValue"><code>ExpectationValue</code></a> or to create custom noise models with <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.Kraus"><code>Kraus</code></a>, see <a href="../noise/">noise</a> and <a href="../statistical_ops/">statistical operations</a> pages.</p><p>Operators can be used to compute expectation values as follows (see also <a href="../../library/mimiqcircuitsbase/operators/#MimiqCircuitsBase.ExpectationValue"><code>ExpectationValue</code></a>):</p><pre><code class="language-julia hljs">using MimiqCircuits
op = SigmaPlus()
ev = ExpectationValue(op)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">⟨SigmaPlus(1)⟩</code></pre><pre><code class="language-julia hljs">push!(Circuit(), ev, 1,1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-qubit circuit with 1 instructions:
└── ⟨SigmaPlus(1)⟩ @ q[1], z[1]</code></pre><p>Similarly, operators can also be used to define non-mixed unitary Kraus channels (see also <a href="../../library/mimiqcircuitsbase/noise/#MimiqCircuitsBase.Kraus"><code>Kraus</code></a>). For example, we can define the amplitude damping channel as follows:</p><pre><code class="language-julia hljs">gamma = 0.1
k1 = DiagonalOp(1, sqrt(1-gamma))    # Kraus operator 1
k2 = SigmaMinus(sqrt(gamma))    # Kraus operator 2
kraus = Kraus([k1,k2])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Kraus(DiagonalOp(1,0.9486832980505138), SigmaMinus(0.31622776601683794))</code></pre><p>This is equivalent to</p><pre><code class="language-julia hljs">gamma = 0.1
ampdamp = AmplitudeDamping(gamma)
krausoperators(ampdamp)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{AbstractOperator{1}}:
 D(1, 0.9486832980505138)
 SigmaMinus(0.31622776601683794)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Whenever possible, using specialized operators, such as <code>DiagonalOp</code> and <code>SigmaMinus</code>, as opposed to custom operators, such as <code>Operator</code>, is generally better for performance.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../unitary_gates/">« Unitary Gates</a><a class="docs-footer-nextpage" href="../noise/">Noise »</a><div class="flexbox-break"></div><p class="footer-message">Copyright 2021-2024 QPerfect. All rights reserved.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 24 November 2024 21:02">Sunday 24 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
