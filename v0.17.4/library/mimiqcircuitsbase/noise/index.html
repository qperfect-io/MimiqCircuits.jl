<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Noise · MimiqCircuits.jl</title><meta name="title" content="Noise · MimiqCircuits.jl"/><meta property="og:title" content="Noise · MimiqCircuits.jl"/><meta property="twitter:title" content="Noise · MimiqCircuits.jl"/><meta name="description" content="Documentation for MimiqCircuits.jl."/><meta property="og:description" content="Documentation for MimiqCircuits.jl."/><meta property="twitter:description" content="Documentation for MimiqCircuits.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="MimiqCircuits.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">MimiqCircuits.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">MIMIQ Documentation</a></li><li><a class="tocitem" href="../../../quick_start/">Quick start</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/installation/">Installation</a></li><li><a class="tocitem" href="../../../manual/overview/">Overview</a></li><li><a class="tocitem" href="../../../manual/circuits/">Circuits</a></li><li><a class="tocitem" href="../../../manual/unitary_gates/">Unitary Gates</a></li><li><a class="tocitem" href="../../../manual/non_unitary_ops/">Non-unitary Operations</a></li><li><a class="tocitem" href="../../../manual/noise/">Noise</a></li><li><a class="tocitem" href="../../../manual/symbolic_ops/">Symbolic Operations</a></li><li><a class="tocitem" href="../../../manual/statistical_ops/">Statistical Operations</a></li><li><a class="tocitem" href="../../../manual/special_ops/">Special Operations</a></li><li><a class="tocitem" href="../../../manual/simulation/">Simulating Circuits</a></li><li><a class="tocitem" href="../../../manual/remote_execution/">Cloud Execution</a></li><li><a class="tocitem" href="../../../manual/import_export/">Import &amp; Export Circuits</a></li><li><a class="tocitem" href="../../../manual/special_topics/">Special Topics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../outline/">Outline</a></li><li><a class="tocitem" href="../../mimiqcircuits/">MimiqCircuits</a></li><li><a class="tocitem" href="../../mimiqlink/">MimiqLink</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">MimiqCircuitsBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../general/">General functions</a></li><li><a class="tocitem" href="../circuits/">Quantum Circuits and Instructions</a></li><li><a class="tocitem" href="../operations/">Operations</a></li><li><a class="tocitem" href="../standard/">Standard Gates</a></li><li><a class="tocitem" href="../generalized/">Generalized gates</a></li><li><a class="tocitem" href="../other/">Other Operations</a></li><li class="is-active"><a class="tocitem" href>Noise</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../bitstrings/">Bit Strings</a></li><li><a class="tocitem" href="../results/">Quantum Circuit Simulation Results</a></li></ul></li><li><a class="tocitem" href="../../internals/">Internals</a></li><li><a class="tocitem" href="../../function_index/">Function Index</a></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li><a class="is-disabled">MimiqCircuitsBase</a></li><li class="is-active"><a href>Noise</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Noise</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/qperfect-io/MimiqCircuits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/qperfect-io/MimiqCircuits.jl/blob/main/docs/src/library/mimiqcircuitsbase/noise.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Noise"><a class="docs-heading-anchor" href="#Noise">Noise</a><a id="Noise-1"></a><a class="docs-heading-anchor-permalink" href="#Noise" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.add_noise!-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}" href="#MimiqCircuitsBase.add_noise!-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}"><code>MimiqCircuitsBase.add_noise!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_noise!(c, g, noise; before=false, parallel=false)</code></pre><p>Add a noise operation <code>noise</code> to every operation <code>g</code> in the circuit <code>c</code>.</p><p>The noise operation <code>noise</code> can be a Kraus channel or a gate and will act on the same qubits as the operation <code>g</code> it is being added to.</p><p>The operations <code>g</code> and <code>noise</code> have to act on the same number of qubits.</p><p><strong>Arguments</strong></p><ul><li><code>c</code>: Circuit.</li><li><code>g</code>: Operation to which noise will be added.</li><li><code>noise</code>: Kraus channel or gate that will be added to each operation <code>g</code>.</li><li><code>before</code>: (optional) Bool, default=<code>false</code>. If <code>before</code> is <code>false</code> then the noise is added right after the operation; if it&#39;s <code>true</code> it&#39;s added right before.</li><li><code>parallel</code>: (optional) Bool, default=<code>false</code>. If <code>parallel</code> is <code>false</code> then the noise is added immediately after/before the operation. If it&#39;s <code>true</code> the function identifies blocks of consecutive transversal operations of type <code>g</code> and adds after each such block a block of transversal noise operations <code>noise</code>. The result of both should be equivalent, it&#39;s only the order of operations that changes.</li></ul><p><strong>Returns</strong></p><p>The circuit <code>c</code> with the noise added in place.</p><p><strong>Examples</strong></p><p>Parallel vs not parallel.</p><pre><code class="language-julia-repl hljs">julia&gt; c = push!(Circuit(), GateH(), 1:3);

julia&gt; add_noise!(c, GateH(), AmplitudeDamping(0.2))
3-qubit circuit with 6 instructions:
├── H @ q[1]
├── AmplitudeDamping(0.2) @ q[1]
├── H @ q[2]
├── AmplitudeDamping(0.2) @ q[2]
├── H @ q[3]
└── AmplitudeDamping(0.2) @ q[3]

julia&gt; c = push!(Circuit(), GateH(), 1:3);

julia&gt; add_noise!(c, GateH(), AmplitudeDamping(0.2); parallel=true)
3-qubit circuit with 6 instructions:
├── H @ q[1]
├── H @ q[2]
├── H @ q[3]
├── AmplitudeDamping(0.2) @ q[1]
├── AmplitudeDamping(0.2) @ q[2]
└── AmplitudeDamping(0.2) @ q[3]</code></pre><p>Parallel will not work if gates aren&#39;t transversal.</p><pre><code class="language-julia-repl hljs">julia&gt; c = push!(Circuit(), GateCZ(), 1, 2:4);

julia&gt; add_noise!(c, GateCZ(), Depolarizing2(0.1); parallel=true)
4-qubit circuit with 6 instructions:
├── CZ @ q[1], q[2]
├── Depolarizing(2,0.1) @ q[1:2]
├── CZ @ q[1], q[3]
├── Depolarizing(2,0.1) @ q[1,3]
├── CZ @ q[1], q[4]
└── Depolarizing(2,0.1) @ q[1,4]</code></pre><p>The <code>before=true</code> option is mostly used for <code>Measure</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; c = push!(Circuit(), Measure(), 1:3, 1:3);

julia&gt; add_noise!(c, Measure(), PauliX(0.1); before=true)
3-qubit circuit with 6 instructions:
├── PauliX(0.1) @ q[1]
├── M @ q[1], c[1]
├── PauliX(0.1) @ q[2]
├── M @ q[2], c[2]
├── PauliX(0.1) @ q[3]
└── M @ q[3], c[3]</code></pre><p>Unitary gates are added in the same way.</p><pre><code class="language-julia-repl hljs">julia&gt; c = push!(Circuit(), GateH(), 1:3);

julia&gt; add_noise!(c, GateH(), GateRX(0.01))
3-qubit circuit with 6 instructions:
├── H @ q[1]
├── RX(0.01) @ q[1]
├── H @ q[2]
├── RX(0.01) @ q[2]
├── H @ q[3]
└── RX(0.01) @ q[3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/noisemodels.jl#L100-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.add_noise-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}" href="#MimiqCircuitsBase.add_noise-Tuple{Circuit, Operation, Union{AbstractGate, AbstractKrausChannel}}"><code>MimiqCircuitsBase.add_noise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_noise(c, g, noise; before=false, parallel=false)</code></pre><p>Add noise operation <code>noise</code> to every operation <code>g</code> in circuit <code>c</code>.</p><p>A copy of <code>c</code> is created and then noise is added to the copy.</p><p>See [<code>add_noise!</code>] for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/noisemodels.jl#L350-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.sample_mixedunitaries-Tuple{Circuit}" href="#MimiqCircuitsBase.sample_mixedunitaries-Tuple{Circuit}"><code>MimiqCircuitsBase.sample_mixedunitaries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_mixedunitaries(c; rng, ids=false)</code></pre><p>Samples one unitary gate for each mixed unitary Kraus channel in the circuit.</p><p>This is possible because for mixed unitary noise channels the probabilities of each Kraus operator are fixed (state-independent).</p><p>Note: This function is internally called (before applying any gate) when executing a circuit with noise using trajectories, but it can also be used to generate samples of circuits without running them.</p><p>See also <a href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a>, <a href="#MimiqCircuitsBase.MixedUnitary"><code>MixedUnitary</code></a>, <a href="#MimiqCircuitsBase.probabilities-Tuple{AbstractKrausChannel}"><code>probabilities</code></a>, and <a href="#MimiqCircuitsBase.unitarygates-Tuple{AbstractKrausChannel}"><code>unitarygates</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>c</code>: Circuit to be sampled.</li><li><code>rng</code>: (optional) Random number generator.</li><li><code>ids</code>: (optional) Boolean, default=<code>false</code>. When the selected Kraus operator is an identity it has no effect on the circuit. The parameter <code>ids</code> decides whether to add it to the circuit (<code>ids=true</code><code>) or not (</code>ids=false`; default). Usually, most of the Kraus operators selected will be identity gates.</li></ul><p><strong>Returns</strong></p><p>A copy of circuit but with every mixed unitary Kraus channel replaced by one of the unitary gates of the channel (or nothing if identity and <code>ids==false</code>).</p><p><strong>Examples</strong></p><p>Gates and non-mixed-unitary Kraus channels remain unchanged.</p><pre><code class="language-julia-repl hljs">julia&gt; using Random

julia&gt; c = push!(Circuit(), GateH(), 1:3);

julia&gt; push!(c, Depolarizing1(0.5), 1:3);

julia&gt; push!(c, AmplitudeDamping(0.5), 1:3)
3-qubit circuit with 9 instructions:
├── H @ q[1]
├── H @ q[2]
├── H @ q[3]
├── Depolarizing(1,0.5) @ q[1]
├── Depolarizing(1,0.5) @ q[2]
├── Depolarizing(1,0.5) @ q[3]
├── AmplitudeDamping(0.5) @ q[1]
├── AmplitudeDamping(0.5) @ q[2]
└── AmplitudeDamping(0.5) @ q[3]

julia&gt; rng = MersenneTwister(42);

julia&gt; sample_mixedunitaries(c; rng=rng, ids=true)
3-qubit circuit with 9 instructions:
├── H @ q[1]
├── H @ q[2]
├── H @ q[3]
├── Y @ q[1]
├── ID @ q[2]
├── ID @ q[3]
├── AmplitudeDamping(0.5) @ q[1]
├── AmplitudeDamping(0.5) @ q[2]
└── AmplitudeDamping(0.5) @ q[3]</code></pre><p>By default identities are not included.</p><pre><code class="language-julia-repl hljs">julia&gt; rng = MersenneTwister(42);

julia&gt; sample_mixedunitaries(c; rng=rng)
3-qubit circuit with 7 instructions:
├── H @ q[1]
├── H @ q[2]
├── H @ q[3]
├── Y @ q[1]
├── AmplitudeDamping(0.5) @ q[1]
├── AmplitudeDamping(0.5) @ q[2]
└── AmplitudeDamping(0.5) @ q[3]</code></pre><p>Different calls to the function generate different results.</p><pre><code class="language-julia-repl hljs">julia&gt; sample_mixedunitaries(c; rng=rng)
3-qubit circuit with 6 instructions:
├── H @ q[1]
├── H @ q[2]
├── H @ q[3]
├── AmplitudeDamping(0.5) @ q[1]
├── AmplitudeDamping(0.5) @ q[2]
└── AmplitudeDamping(0.5) @ q[3]

julia&gt; sample_mixedunitaries(c; rng=rng)
3-qubit circuit with 6 instructions:
├── H @ q[1]
├── H @ q[2]
├── H @ q[3]
├── AmplitudeDamping(0.5) @ q[1]
├── AmplitudeDamping(0.5) @ q[2]
└── AmplitudeDamping(0.5) @ q[3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/samplenoise.jl#L18-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.ProjectiveNoiseX" href="#MimiqCircuitsBase.ProjectiveNoiseX"><code>MimiqCircuitsBase.ProjectiveNoiseX</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProjectiveNoiseX()</code></pre><p>Single qubit projection noise onto a X Pauli basis.</p><p>This channel is defined by the Kraus operators</p><p class="math-container">\[E_1 = |-\rangle \langle-|, \quad E_2 = |+\rangle \langle+|,\]</p><p>Where <span>$\ket{+}$</span> and <span>$\ket{-}$</span> are the eigenstates of Pauli <code>X</code>.</p><p>See also <a href="#MimiqCircuitsBase.ProjectiveNoise"><code>ProjectiveNoise</code></a>, <a href="#MimiqCircuitsBase.ProjectiveNoiseY"><code>ProjectiveNoiseY</code></a>, or <a href="#MimiqCircuitsBase.ProjectiveNoiseZ"><code>ProjectiveNoiseZ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/projectivenoise.jl#L18-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.ProjectiveNoiseY" href="#MimiqCircuitsBase.ProjectiveNoiseY"><code>MimiqCircuitsBase.ProjectiveNoiseY</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProjectiveNoiseY()</code></pre><p>Single qubit projection noise onto a Y Pauli basis.</p><p>This channel is defined by the Kraus operators</p><p class="math-container">\[E_1 = |Y0\rangle \langle Y0|, \quad E_2 = |Y1\rangle \langle Y1|,\]</p><p>Where <span>$\ket{Y0}$</span> and <span>$\ket{Y1}$</span> are the eigenstates of Pauli <code>Y</code>.</p><p>See also <a href="#MimiqCircuitsBase.ProjectiveNoise"><code>ProjectiveNoise</code></a>, <a href="#MimiqCircuitsBase.ProjectiveNoiseX"><code>ProjectiveNoiseX</code></a>, or <a href="#MimiqCircuitsBase.ProjectiveNoiseZ"><code>ProjectiveNoiseZ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/projectivenoise.jl#L41-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.ProjectiveNoiseZ" href="#MimiqCircuitsBase.ProjectiveNoiseZ"><code>MimiqCircuitsBase.ProjectiveNoiseZ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProjectiveNoiseZ()</code></pre><p>Single qubit projection noise onto a Z Pauli basis.</p><p>This channel is defined by the Kraus operators</p><p class="math-container">\[E_1 = |0\rangle \langle Z0|, \quad E_2 = |1\rangle \langle Z1|,\]</p><p>Where <span>$\ket{0}$</span> and <span>$\ket{1}$</span> are the eigenstates of Pauli <code>Z</code>.</p><p>See also <a href="#MimiqCircuitsBase.ProjectiveNoise"><code>ProjectiveNoise</code></a>, <a href="#MimiqCircuitsBase.ProjectiveNoiseX"><code>ProjectiveNoiseX</code></a>, or <a href="#MimiqCircuitsBase.ProjectiveNoiseY"><code>ProjectiveNoiseY</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/projectivenoise.jl#L64-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.ProjectiveNoise" href="#MimiqCircuitsBase.ProjectiveNoise"><code>MimiqCircuitsBase.ProjectiveNoise</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProjectiveNoise(basis)</code></pre><p>Single qubit projection noise onto a Pauli basis.</p><p>This channel is defined by the Kraus operators</p><p class="math-container">\[E_1 = |\alpha\rangle \langle\alpha|, \quad E_2 = |\beta\rangle \langle\beta|,\]</p><p>where the states <span>$|\alpha\rangle$</span> and <span>$|\beta\rangle$</span> are the +1 and -1 eigenstates of a Pauli operator. Specifically, they correspond to <span>$\{ |0\langle, |1\langle \}$</span> (<span>$Z$</span> basis), <span>$\{ |+\langle, |-\langle \}$</span> (<span>$X$</span> basis), or <span>$\{ |y+\langle, |y-\langle \}$</span> (<code>Y</code> basis).</p><p>This operation is similar to measuring in the corresponding basis (<span>$X$</span>, <span>$Y$</span>, or <span>$Z$</span>), except that the outcome of the measurement is not stored, i.e. there&#39;s loss of information.</p><p><strong>Arguments</strong></p><ul><li><code>basis</code>: Symbol, String or Char that selects the Pauli basis, <code>&quot;X&quot;</code>, <code>&quot;Y&quot;</code>, or <code>&quot;Z&quot;</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), ProjectiveNoise(&quot;Z&quot;), 1)
1-qubit circuit with 1 instructions:
└── ProjectiveNoiseZ @ q[1]</code></pre><p>The Kraus matrices are given by:</p><pre><code class="language-julia-repl hljs">julia&gt; krausmatrices(ProjectiveNoise(&quot;X&quot;))
2-element Vector{Matrix{Float64}}:
 [0.5 0.5; 0.5 0.5]
 [0.5 -0.5; -0.5 0.5]

julia&gt; krausmatrices(ProjectiveNoise(&quot;Y&quot;))
2-element Vector{Matrix{ComplexF64}}:
 [0.5 + 0.0im 0.0 - 0.5im; 0.0 + 0.5im 0.5 + 0.0im]
 [0.5 + 0.0im 0.0 + 0.5im; 0.0 - 0.5im 0.5 + 0.0im]

julia&gt; krausmatrices(ProjectiveNoise(&quot;Z&quot;))
2-element Vector{Matrix{Int64}}:
 [1 0; 0 0]
 [0 0; 0 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/projectivenoise.jl#L87-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Kraus" href="#MimiqCircuitsBase.Kraus"><code>MimiqCircuitsBase.Kraus</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Kraus(E)</code></pre><p>Custom <span>$N$</span> qubit Kraus channel specified by a list of Kraus operators.</p><p>A Kraus channel is defined by</p><p class="math-container">\[\mathcal{E}(\rho) = \sum_k E_k \rho E_k^\dagger,\]</p><p>where <span>$E_k$</span> are Kraus operators that need to fulfill <span>$\sum_k E_k^\dagger E_k = I$</span>.</p><p>If the Kraus operators are all proportional to unitaries, use <a href="#MimiqCircuitsBase.MixedUnitary"><code>MixedUnitary</code></a> instead.</p><p>The Kraus matrices are defined in the computational basis in the usual textbook order (the first qubit corresponds to the left-most qubit). For 1 qubit we have <span>$|0\rangle$</span>, <span>$|1\rangle$</span>. For 2 qubits we have <span>$|00\rangle$</span>, <span>$|01\rangle$</span>, <span>$|10\rangle$</span>, <span>$|11\rangle$</span>. See also <a href="../other/#MimiqCircuitsBase.GateCustom"><code>GateCustom</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently only 1 and 2-qubit custom Kraus channels are supported.</p></div></div><p>See also <a href="#MimiqCircuitsBase.MixedUnitary"><code>MixedUnitary</code></a>, <a href="#MimiqCircuitsBase.AbstractKrausChannel"><code>AbstractKrausChannel</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>E</code>: Vector of <span>$2^N \times 2^N$</span> complex matrices or <span>$N$</span> qubit operators. Both can be mixed.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), Kraus([[1 0; 0 sqrt(0.9)], [0 sqrt(0.1); 0 0]]), 1)
1-qubit circuit with 1 instructions:
└── Kraus(Operator([1.0 0.0; 0.0 0.948683]), Operator([0.0 0.316228; 0.0 0.0])) @ q[1]

julia&gt; push!(Circuit(), Kraus([Projector0(), Projector1()]), 1)
1-qubit circuit with 1 instructions:
└── Kraus(Projector0(1), Projector1(1)) @ q[1]

julia&gt; push!(Circuit(), Kraus([[1 0; 0 0], Projector1()]), 1)
1-qubit circuit with 1 instructions:
└── Kraus(Operator([1.0 0.0; 0.0 0.0]), Projector1(1)) @ q[1]

julia&gt; @variables x
1-element Vector{Symbolics.Num}:
 x

julia&gt; g = Kraus([Projector0(), Projector1(x)])
Kraus(Projector0(1), Projector1(x))

julia&gt; evaluate(g,Dict(x=&gt;1))
Kraus(Projector0(1), Projector1(1))

julia&gt; g = Kraus([[1 0; 0 sqrt(0.9)], [0 sqrt(0.1); 0 x]])
Kraus(Operator([1.0 0.0; 0.0 0.948683]), Operator([0 0.316228; 0 x]))

julia&gt; evaluate(g,Dict(x=&gt;0))
Kraus(Operator([1.0 0.0; 0.0 0.948683]), Operator([0 0.316228; 0 0]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/kraus.jl#L18-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.AbstractKrausChannel" href="#MimiqCircuitsBase.AbstractKrausChannel"><code>MimiqCircuitsBase.AbstractKrausChannel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractKrausChannel{N} &lt;: Operation{N,0,0}</code></pre><p>Supertype for all the <span>$N$</span>-qubit Kraus channels.</p><p>A Kraus channel is a quantum operation on a density matrix <span>$\rho$</span> of the form</p><p class="math-container">\[\mathcal{E}(\rho) = \sum_k E_k \rho E_k^\dagger,\]</p><p>where <span>$E_k$</span> are Kraus operators that need to fulfill <span>$\sum_k E_k^\dagger E_k \leq I$</span>.</p><p><strong>Special properties:</strong></p><ul><li><p><a href="../../internals/#MimiqCircuitsBase.isCPTP-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>isCPTP</code></a>: A Kraus channel a completely positive and trace preserving (CPTP) operation when <span>$\sum_k E_k^\dagger E_k = I$</span>. Currently, all noise channels are CPTP.</p></li><li><p><a href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a>: A Kraus channel is called a mixed unitary channel when the Kraus operators <span>$E_k$</span> are each proportional to a unitary matrix <span>$U_k$</span>, i.e. when <span>$\mathcal{E}(\rho) = \sum_k p_k U_k \rho U_k^\dagger$</span> with some probabilities <span>$0\leq p_k \leq 1$</span> that add up to 1 and <span>$U_k^\dagger U_k = I$</span>.</p></li></ul><p>See also <a href="#MimiqCircuitsBase.krausmatrices-Tuple{AbstractKrausChannel}"><code>krausmatrices</code></a>, <a href="#MimiqCircuitsBase.unitarymatrices-Tuple{AbstractKrausChannel}"><code>unitarymatrices</code></a>, <a href="#MimiqCircuitsBase.probabilities-Tuple{AbstractKrausChannel}"><code>probabilities</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L18-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.cumprobabilities-Tuple{AbstractKrausChannel}" href="#MimiqCircuitsBase.cumprobabilities-Tuple{AbstractKrausChannel}"><code>MimiqCircuitsBase.cumprobabilities</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cumprobabilities(mixedunitarychannel)</code></pre><p>Cumulative sum of probabilities of a mixed unitary Kraus channel.</p><p>A mixed unitary channel is written as <span>$\sum_k p_k U_k \rho U_k^\dagger$</span>, where <span>$p_k$</span> are the probabilities.</p><p>An error is returned for Kraus channels with <code>ismixedunitary(krauschannel)==false</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>if the Kraus channel is parametric, the cumprobabilities are wrapped in a <code>Symbolics.Num</code> object. To manipulate expressions use the <code>Symbolics</code> package.</p></div></div><p>See also <a href="#MimiqCircuitsBase.probabilities-Tuple{AbstractKrausChannel}"><code>probabilities</code></a>, <a href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cumprobabilities(Depolarizing1(0.1))
4-element Vector{Symbolics.Num}:
                0.9
 0.9333333333333333
 0.9666666666666667
                1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L143-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel" href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>MimiqCircuitsBase.ismixedunitary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ismixedunitary(krauschannel)</code></pre><p>Whether the quantum operation is a mixed unitary channel.</p><p>This is the case when all the Kraus operators <span>$E_k$</span> are proportional to a unitary <span>$U_k$</span>, i.e. <span>$\mathcal{E}(\rho) = \sum_k p_k U_k \rho U_k^\dagger$</span> with some probabilities <span>$0\leq p_k \leq 1$</span> that add up to 1 and <span>$U_k^\dagger U_k = I$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ismixedunitary(PauliX(0.1))
true

julia&gt; ismixedunitary(AmplitudeDamping(0.1))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L60-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.krausmatrices-Tuple{AbstractKrausChannel}" href="#MimiqCircuitsBase.krausmatrices-Tuple{AbstractKrausChannel}"><code>MimiqCircuitsBase.krausmatrices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">krausmatrices(krauschannel)</code></pre><p>Kraus matrices associated to the given Kraus channel.</p><p>A mixed unitary channel is written as <span>$\sum_k p_k U_k \rho U_k^\dagger$</span>, where <span>$U_k$</span> are the unitary matrices returned by this function.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>if the Kraus channel is parametric, the matrix elements are wrapped in a <code>Symbolics.Num</code> object. To manipulate expressions use the <code>Symbolics</code> package.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; krausmatrices(AmplitudeDamping(0.1))
2-element Vector{Matrix{Float64}}:
 [1.0 0.0; 0.0 0.9486832980505138]
 [0.0 0.31622776601683794; 0.0 0.0]</code></pre><p>For mixed unitary channels the Kraus matrices are the unitary matrices times the square root of the probabilities.</p><pre><code class="language-julia-repl hljs">julia&gt; krausmatrices(PauliX(0.2))
2-element Vector{Matrix{Symbolics.Num}}:
 [0.8944271909999159 -0.0; 0.0 0.8944271909999159]
 [0.0 0.4472135954999579; 0.4472135954999579 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L201-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.krausoperators-Tuple{AbstractKrausChannel}" href="#MimiqCircuitsBase.krausoperators-Tuple{AbstractKrausChannel}"><code>MimiqCircuitsBase.krausoperators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">krausoperators(kraus)</code></pre><p>Kraus operators associated to the given Kraus channel.</p><p>See also <a href="#MimiqCircuitsBase.krausmatrices-Tuple{AbstractKrausChannel}"><code>krausmatrices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; krausoperators(PauliX(0.2))
2-element Vector{Operator{1}}:
 Operator([0.8944271909999159 -0.0; 0.0 0.8944271909999159])
 Operator([0.0 0.4472135954999579; 0.4472135954999579 0.0])

julia&gt; krausoperators(AmplitudeDamping(0.1))
2-element Vector{AbstractOperator{1}}:
 D(1, 0.9486832980505138)
 SigmaMinus(0.31622776601683794)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L269-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.probabilities-Tuple{AbstractKrausChannel}" href="#MimiqCircuitsBase.probabilities-Tuple{AbstractKrausChannel}"><code>MimiqCircuitsBase.probabilities</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">probabilities(mixedunitarychannel)</code></pre><p>Probabilities of each Kraus operator for mixed unitary Kraus channels.</p><p>A mixed unitary channel is written as <span>$\sum_k p_k U_k \rho U_k^\dagger$</span>, where <span>$p_k$</span> are the probabilities.</p><p>An error is returned for Kraus channels with <code>ismixedunitary(krauschannel)==false</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>if the Kraus channel is parametric, the probabilities are wrapped in a <code>Symbolics.Num</code> object. To manipulate expressions use the <code>Symbolics</code> package.</p></div></div><p>See also <a href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a>, <a href="#MimiqCircuitsBase.unitarymatrices-Tuple{AbstractKrausChannel}"><code>unitarymatrices</code></a>, and <a href="#MimiqCircuitsBase.krausmatrices-Tuple{AbstractKrausChannel}"><code>krausmatrices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; probabilities(PauliX(0.1))
2-element Vector{Symbolics.Num}:
 0.9
 0.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L87-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.squaredkrausoperators-Tuple{AbstractKrausChannel}" href="#MimiqCircuitsBase.squaredkrausoperators-Tuple{AbstractKrausChannel}"><code>MimiqCircuitsBase.squaredkrausoperators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">squaredkrausoperators(kraus)</code></pre><p>Square of of Kraus operators (<span>$O^\dagger O$</span>) associated to the given Kraus channel.</p><p>See also <a href="#MimiqCircuitsBase.krausoperators-Tuple{AbstractKrausChannel}"><code>krausoperators</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; squaredkrausoperators(AmplitudeDamping(0.1))
2-element Vector{AbstractOperator{1}}:
 D(1, 0.8999999999999999)
 P₁(0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L300-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.unitarygates-Tuple{AbstractKrausChannel}" href="#MimiqCircuitsBase.unitarygates-Tuple{AbstractKrausChannel}"><code>MimiqCircuitsBase.unitarygates</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitarygates(krauschannel)</code></pre><p>Unitary gates associated to the given mixed unitary Kraus channel.</p><p>A mixed unitary channel is written as <span>$\sum_k p_k U_k \rho U_k^\dagger$</span>, where <span>$U_k$</span> are the unitary operators returned by this function.</p><p>An error is returned for Kraus channels with <code>ismixedunitary(krauschannel)==false</code>.</p><p>See also <a href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a>, <a href="#MimiqCircuitsBase.unitarymatrices-Tuple{AbstractKrausChannel}"><code>unitarymatrices</code></a>, and <a href="#MimiqCircuitsBase.krausmatrices-Tuple{AbstractKrausChannel}"><code>krausmatrices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unitarygates(PauliNoise([0.9,0.1],[&quot;II&quot;,&quot;XX&quot;]))
2-element Vector{PauliString{2}}:
 II
 XX</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L380-L400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.unitarymatrices-Tuple{AbstractKrausChannel}" href="#MimiqCircuitsBase.unitarymatrices-Tuple{AbstractKrausChannel}"><code>MimiqCircuitsBase.unitarymatrices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitarymatrices(mixedunitarychannel)</code></pre><p>Unitary matrices associated to the given mixed unitary Kraus channel.</p><p>A mixed unitary channel is written as <span>$\sum_k p_k U_k \rho U_k^\dagger$</span>, where <span>$U_k$</span> are the unitary matrices.</p><p>An error is returned for Kraus channels with <code>ismixedunitary(krauschannel)==false</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>if the Kraus channel is parametric, the matrix elements are wrapped in a <code>Symbolics.Num</code> object. To manipulate expressions use the <code>Symbolics</code> package.</p></div></div><p>See also <a href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a>, <a href="#MimiqCircuitsBase.probabilities-Tuple{AbstractKrausChannel}"><code>probabilities</code></a>, and <a href="#MimiqCircuitsBase.krausmatrices-Tuple{AbstractKrausChannel}"><code>krausmatrices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unitarymatrices(PauliX(0.2))
2-element Vector{Matrix}:
 [1.0 -0.0; 0.0 1.0]
 [0 1; 1 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L318-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.unwrappedcumprobabilities-Tuple{AbstractKrausChannel}" href="#MimiqCircuitsBase.unwrappedcumprobabilities-Tuple{AbstractKrausChannel}"><code>MimiqCircuitsBase.unwrappedcumprobabilities</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unwrappedcumprobabilities(mixedunitarychannel)</code></pre><p>Cumulative sum of probabilities associated to the specified mixed unitary Kraus channel without the <code>Symbolics.Num</code> wrapper.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If any of the noise channel&#39;s parameters is symbolic, an error is thrown.</p></div></div><p>See <a href="#MimiqCircuitsBase.cumprobabilities-Tuple{AbstractKrausChannel}"><code>cumprobabilities</code></a> for more information.</p><pre><code class="language-julia-repl hljs">julia&gt; unwrappedcumprobabilities(Depolarizing1(0.1))
4-element Vector{Float64}:
 0.9
 0.9333333333333333
 0.9666666666666667
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L179-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.unwrappedkrausmatrices-Tuple{AbstractKrausChannel}" href="#MimiqCircuitsBase.unwrappedkrausmatrices-Tuple{AbstractKrausChannel}"><code>MimiqCircuitsBase.unwrappedkrausmatrices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unwrappedkrausmatrices(krauschannel)</code></pre><p>Returns the Kraus matrices associated to the specified Kraus channel without the <code>Symbolics.Num</code> wrapper.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If any of the noise channel&#39;s parameters is symbolic, an error is thrown.</p></div></div><p>See <a href="#MimiqCircuitsBase.krausmatrices-Tuple{AbstractKrausChannel}"><code>krausmatrices</code></a> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unwrappedkrausmatrices(AmplitudeDamping(0.1))
2-element Vector{Matrix{Float64}}:
 [1.0 0.0; 0.0 0.9486832980505138]
 [0.0 0.31622776601683794; 0.0 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L245-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.unwrappedprobabilities-Tuple{AbstractKrausChannel}" href="#MimiqCircuitsBase.unwrappedprobabilities-Tuple{AbstractKrausChannel}"><code>MimiqCircuitsBase.unwrappedprobabilities</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unwrappedprobabilities(mixedunitarychannel)</code></pre><p>Probabilities associated to the specified mixed unitary Kraus channel without the <code>Symbolics.Num</code> wrapper.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If any of the noise channel&#39;s parameters is symbolic, an error is thrown.</p></div></div><p>See <a href="#MimiqCircuitsBase.probabilities-Tuple{AbstractKrausChannel}"><code>probabilities</code></a> for more information.</p><pre><code class="language-julia-repl hljs">julia&gt; unwrappedprobabilities(PauliX(0.1))
2-element Vector{Float64}:
 0.9
 0.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L123-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.unwrappedunitarymatrices-Tuple{AbstractKrausChannel}" href="#MimiqCircuitsBase.unwrappedunitarymatrices-Tuple{AbstractKrausChannel}"><code>MimiqCircuitsBase.unwrappedunitarymatrices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unwrappedunitarymatrices(krauschannel)</code></pre><p>Returns the unitary Kraus matrices associated to the mixed unitary Kraus channel without the <code>Symbolics.Num</code> wrapper.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If any of the noise channel&#39;s parameters is symbolic, an error is thrown.</p></div></div><p>See <a href="#MimiqCircuitsBase.unitarymatrices-Tuple{AbstractKrausChannel}"><code>unitarymatrices</code></a> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unwrappedunitarymatrices(PauliX(0.2))
2-element Vector{Matrix}:
 [1.0 -0.0; 0.0 1.0]
 [0 1; 1 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/krauschannel.jl#L356-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Amplitude" href="#MimiqCircuitsBase.Amplitude"><code>MimiqCircuitsBase.Amplitude</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Amplitude(bs::BitString)</code></pre><p>Operation to get amplitude of a state vector element.</p><p>The operation gets the quantum state&#39;s amplitude (which is a complex number) corresponding to the state defined by the  bitstring <code>bs</code> in the computational basis and stores it in a z-register.</p><p>See <a href="../../../manual/special_topics/#BitString"><code>BitString</code></a>.</p><p><strong>Examples</strong></p><p>When defining a circuit, only the z-register to store the result needs to be specified.</p><pre><code class="language-julia-repl hljs">julia&gt; Amplitude(BitString(&quot;001&quot;))
Amplitude(bs&quot;001&quot;)

julia&gt; c = push!(Circuit(),Amplitude(BitString(&quot;001&quot;)), 1)
0-qubit circuit with 1 instructions:
└── Amplitude(bs&quot;001&quot;) @ z[1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/amplitude.jl#L18-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.DiagonalOp" href="#MimiqCircuitsBase.DiagonalOp"><code>MimiqCircuitsBase.DiagonalOp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiagonalOp(a,b)</code></pre><p>One-qubit diagonal operator.</p><p>The corresponding matrix</p><p class="math-container">\[\begin{pmatrix}
    a &amp; 0\\
    0 &amp; b
\end{pmatrix}\]</p><p>is parametrized by complex numbers <code>a</code> and <code>b</code>.</p><p>See also <a href="../other/#MimiqCircuitsBase.Operator"><code>Operator</code></a>, <a href="../operators/#MimiqCircuitsBase.Projector0"><code>Projector0</code></a>, <a href="../operators/#MimiqCircuitsBase.Projector1"><code>Projector1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; DiagonalOp(1,0.5)
D(1, 0.5)

julia&gt; push!(Circuit(), ExpectationValue(DiagonalOp(1,0.5)), 1, 2)
1-qubit circuit with 1 instructions:
└── ⟨D(1,0.5)⟩ @ q[1], z[2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/operators/diagonals.jl#L18-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.AmplitudeDamping" href="#MimiqCircuitsBase.AmplitudeDamping"><code>MimiqCircuitsBase.AmplitudeDamping</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AmplitudeDamping(γ)</code></pre><p>One-qubit amplitude damping noise channel.</p><p>This channel is defined by the Kraus operators</p><p class="math-container">\[E_1 =
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; \sqrt{1-\gamma}
\end{pmatrix}
,\quad
E_2 =
\begin{pmatrix}
    0 &amp; \sqrt{\gamma} \\
    0 &amp; 0
\end{pmatrix},\]</p><p>where <span>$\gamma \in [0,1]$</span>.</p><p>Physically, it corresponds to an energy gain/loss process, such as spontaneous emission.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), AmplitudeDamping(0.1), 1)
1-qubit circuit with 1 instructions:
└── AmplitudeDamping(0.1) @ q[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/ampdamping.jl#L18-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.GeneralizedAmplitudeDamping" href="#MimiqCircuitsBase.GeneralizedAmplitudeDamping"><code>MimiqCircuitsBase.GeneralizedAmplitudeDamping</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneralizedAmplitudeDamping(p,γ)</code></pre><p>One-qubit generalized amplitude damping noise channel.</p><p>This channel is defined by the Kraus operators</p><p class="math-container">\[E_1 =
\sqrt{p}
\begin{pmatrix}
    1 &amp; 0 \\
    0 &amp; \sqrt{1-\gamma}
\end{pmatrix}
,\quad
E_2 =
\sqrt{p}
\begin{pmatrix}
    0 &amp; \sqrt{\gamma} \\
    0 &amp; 0
\end{pmatrix}
,\quad
E_3 =
\sqrt{1-p}
\begin{pmatrix}
    \sqrt{1-\gamma} &amp; 0 \\
    0 &amp; 1
\end{pmatrix}
,\quad
E_4 =
\sqrt{1-p}
\begin{pmatrix}
    0 &amp; 0 \\
    \sqrt{\gamma} &amp; 0
\end{pmatrix},\]</p><p>where <span>$\gamma, p \in [0,1]$</span>.</p><p>Physically, it corresponds to a combination of spontaneous emission and spontaneous absorption with probabilities <span>$p$</span> and <span>$1-p$</span>, respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), GeneralizedAmplitudeDamping(0.1, 0.3), 1)
1-qubit circuit with 1 instructions:
└── GeneralizedAmplitudeDamping(0.1,0.3) @ q[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/ampdamping.jl#L90-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.PhaseAmplitudeDamping" href="#MimiqCircuitsBase.PhaseAmplitudeDamping"><code>MimiqCircuitsBase.PhaseAmplitudeDamping</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseAmplitudeDamping(p,γ,β)</code></pre><p>One-qubit phase amplitude damping noise channel.</p><p>This channel is defined by:</p><p class="math-container">\[\mathcal{E}(\rho) =
\begin{pmatrix}
    (1-\gamma)\rho_{00}+\gamma p &amp; (1-2\beta)\sqrt{1-\gamma}\rho_{01} \\
    (1-2\beta)\sqrt{1-\gamma}\rho_{10} &amp; (1-\gamma)\rho_{11} + (1-p)\gamma
\end{pmatrix}\]</p><p>Here, <span>$p, \gamma, \beta \in [0,1]$</span>.</p><p>This channel is equivalent to a <code>GeneralizedAmplitudeDamping(p,γ)</code> channel (see <a href="#MimiqCircuitsBase.GeneralizedAmplitudeDamping"><code>GeneralizedAmplitudeDamping</code></a>), followed by a <code>PauliZ(β)</code> channel (see <a href="#MimiqCircuitsBase.PauliZ"><code>PauliZ</code></a>).</p><p>Use <a href="#MimiqCircuitsBase.krausmatrices-Tuple{AbstractKrausChannel}"><code>krausmatrices</code></a> to see a Kraus matrix representation of the channel.</p><p>See also <a href="#MimiqCircuitsBase.AmplitudeDamping"><code>AmplitudeDamping</code></a>, <a href="#MimiqCircuitsBase.GeneralizedAmplitudeDamping"><code>GeneralizedAmplitudeDamping</code></a>, and <a href="#MimiqCircuitsBase.ThermalNoise"><code>ThermalNoise</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), PhaseAmplitudeDamping(0.1, 0.2, 0.3), 1)
1-qubit circuit with 1 instructions:
└── PhaseAmplitudeDamping(0.1,0.2,0.3) @ q[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/phaseampdamping.jl#L18-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.ThermalNoise" href="#MimiqCircuitsBase.ThermalNoise"><code>MimiqCircuitsBase.ThermalNoise</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThermalNoise(T₁, T₂, t, nₑ)</code></pre><p>One-qubit thermal noise channel.</p><p>The thermal noise channel is equivalent to the <a href="#MimiqCircuitsBase.PhaseAmplitudeDamping"><code>PhaseAmplitudeDamping</code></a> channel, but it is parametrized instead as</p><p class="math-container">\[\mathcal{E}(\rho) =
\begin{pmatrix}
    e^{-\Gamma_1 t}\rho_{00}+(1-n_e)(1-e^{-\Gamma_1 t}) &amp; e^{-\Gamma_2 t}\rho_{01} \\
    e^{-\Gamma_2 t}\rho_{10} &amp; e^{-\Gamma_1 t}\rho_{11} + n_e(1-e^{-\Gamma_1 t})
\end{pmatrix}\]</p><p>where <span>$\Gamma_1=1/T_1$</span> and <span>$\Gamma_2=1/T_2$</span>, and the parameters must fulfill <span>$T_1 \geq 0$</span>, <span>$T_2 \leq 2 T_1$</span>, <span>$t \geq 0$</span>, and <span>$0 \leq n_e \leq 1$</span>.</p><p>These parameters can be related to the ones used to define the <a href="#MimiqCircuitsBase.PhaseAmplitudeDamping"><code>PhaseAmplitudeDamping</code></a> channel through <span>$p = 1-n_e$</span>, <span>$\gamma = 1-e^{-\Gamma_1 t}$</span>, and <span>$\beta = \frac{1}{2}(1-e^{-(\Gamma_2-\Gamma_1/2)t})$</span>.</p><p>See also <a href="#MimiqCircuitsBase.PhaseAmplitudeDamping"><code>PhaseAmplitudeDamping</code></a>, <a href="#MimiqCircuitsBase.AmplitudeDamping"><code>AmplitudeDamping</code></a>, and <a href="#MimiqCircuitsBase.GeneralizedAmplitudeDamping"><code>GeneralizedAmplitudeDamping</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>T₁</code>: Longitudinal relaxation rate.</li><li><code>T₂</code>: Transversal relaxation rate.</li><li><code>t</code>: Time duration of gate.</li><li><code>nₑ</code>: Excitation fraction when in thermal equilibrium with the environment.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), ThermalNoise(0.5, 0.6, 1.2, 0.3), 1)
1-qubit circuit with 1 instructions:
└── ThermalNoise(0.5,0.6,1.2,0.3) @ q[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/phaseampdamping.jl#L119-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Depolarizing" href="#MimiqCircuitsBase.Depolarizing"><code>MimiqCircuitsBase.Depolarizing</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Depolarizing(N,p)</code></pre><p><span>$N$</span> qubit depolarizing noise channel.</p><p>The Kraus operators for the depolarizing channel are given by</p><p class="math-container">\[E_1 = \sqrt{1-p} I_N, \quad E_i = \sqrt{p/(4^N-1)} P_i\]</p><p>where <span>$p\in [0,1]$</span> is a probability, and <span>$P_i` is an$</span>N<span>$-qubit Pauli string operator, i.e. a tensor product of one-qubit Pauli operators (see [`Paulistring`](@ref)). There is exactly one Kraus operator$</span>E<em>{i&gt;1}<span>$for each distinct combination of Pauli operators$</span>P</em>i<span>$, except for the$</span>N<span>$-qubit identity$</span>I_N = I\otimes I \otimes I \otimes...``</p><p>For example, for one qubit we have 3 operators <span>$P_i \in \{X,Y,Z\}$</span>, and for two qubits we have 15 operators <span>$P_i \in \{ I\otimes X, I\otimes Y, I\otimes Z, X\otimes I, Y\otimes I, Z\otimes I, X\otimes X, X\otimes Y, X\otimes Z, Y\otimes X, Y\otimes Y, Y\otimes Z, Z\otimes X, Z\otimes Y, Z\otimes Z \}$</span>. Use <a href="#MimiqCircuitsBase.unitarygates-Tuple{AbstractKrausChannel}"><code>unitarygates</code></a> to see this.</p><p>This channel is a mixed unitary channel, see <a href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a>, and is a special case of <a href="#MimiqCircuitsBase.PauliNoise"><code>PauliNoise</code></a>.</p><p>See also <a href="#MimiqCircuitsBase.PauliString"><code>PauliString</code></a> and <a href="#MimiqCircuitsBase.PauliNoise"><code>PauliNoise</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>N</code>: Number of qubits.</li><li><code>p</code>: Probability of error, i.e. of not applying identity.</li></ul><p><strong>Examples</strong></p><p>Depolarizing channels can be defined for any <span>$N$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), Depolarizing(1, 0.1), 1)
1-qubit circuit with 1 instructions:
└── Depolarizing(1,0.1) @ q[1]

julia&gt; push!(Circuit(), Depolarizing(5, 0.1), 1, 2, 3, 4, 5)
5-qubit circuit with 1 instructions:
└── Depolarizing(5,0.1) @ q[1:5]</code></pre><p>For one and two qubits you can use the shorthand notation:</p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), Depolarizing1(0.1), 1)
1-qubit circuit with 1 instructions:
└── Depolarizing(1,0.1) @ q[1]

julia&gt; push!(Circuit(), Depolarizing2(0.1), 1, 2)
2-qubit circuit with 1 instructions:
└── Depolarizing(2,0.1) @ q[1:2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/depolarizing.jl#L18-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Depolarizing1" href="#MimiqCircuitsBase.Depolarizing1"><code>MimiqCircuitsBase.Depolarizing1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Depolarizing1(p) Doc TODO</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/depolarizing.jl#L137-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.Depolarizing2" href="#MimiqCircuitsBase.Depolarizing2"><code>MimiqCircuitsBase.Depolarizing2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Depolarizing2(p) Doc TODO</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/depolarizing.jl#L141-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.PauliNoise" href="#MimiqCircuitsBase.PauliNoise"><code>MimiqCircuitsBase.PauliNoise</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PauliNoise(p, paulistrings)</code></pre><p><span>$N$</span> qubit Pauli noise channel specified by a list of probabilities and Pauli gates.</p><p>A Pauli channel is defined by</p><p class="math-container">\[\mathcal{E}(\rho) = \sum_k p_k P_k \rho P_k,\]</p><p>where <span>$0 \leq p_k \leq 1$</span> and <span>$P_k$</span> are Pauli string operators, defined as tensor products of one-qubit Pauli operators (see <a href="#MimiqCircuitsBase.PauliString"><code>PauliString</code></a>) The probabilities must fulfill <span>$\sum_k p_k = 1$</span>.</p><p>This channel is a mixed unitary channel, see <a href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a>.</p><p>See also <a href="#MimiqCircuitsBase.Depolarizing"><code>Depolarizing</code></a>, <a href="#MimiqCircuitsBase.PauliX"><code>PauliX</code></a>, <a href="#MimiqCircuitsBase.PauliY"><code>PauliY</code></a>, <a href="#MimiqCircuitsBase.PauliZ"><code>PauliZ</code></a>, which are special cases of PauliNoise.</p><p><strong>Arguments</strong></p><ul><li><code>p</code>: Vector of probabilities that must add up to 1.</li><li><code>paulistrings</code>: Vector of strings, each one of length <span>$N$</span> and with each character being either <code>&quot;I&quot;</code>, <code>&quot;X&quot;</code>, <code>&quot;Y&quot;</code>, or <code>&quot;Z&quot;</code>. The number of qubits is equal to <span>$N$</span>.</li></ul><p>The vectors <code>p</code> and <code>paulistrings</code> must have the same length.</p><p><strong>Examples</strong></p><p>PauliNoise channels can be defined for any number of qubits, and for any number of Pauli strings.</p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), PauliNoise([0.8, 0.1, 0.1], [&quot;I&quot;,&quot;X&quot;,&quot;Y&quot;]), 1)
1-qubit circuit with 1 instructions:
└── PauliNoise((0.8,pauli&quot;I&quot;),(0.1,pauli&quot;X&quot;),(0.1,pauli&quot;Y&quot;)) @ q[1]

julia&gt; push!(Circuit(), PauliNoise([0.9, 0.1], [&quot;XY&quot;,&quot;II&quot;]), 1, 2)
2-qubit circuit with 1 instructions:
└── PauliNoise((0.9,pauli&quot;XY&quot;),(0.1,pauli&quot;II&quot;)) @ q[1:2]

julia&gt; push!(Circuit(), PauliNoise([0.5, 0.2, 0.2, 0.1], [&quot;IXIX&quot;,&quot;XYXY&quot;,&quot;ZZZZ&quot;,&quot;IXYZ&quot;]), 1, 2, 3, 4)
4-qubit circuit with 1 instructions:
└── PauliNoise((0.5,pauli&quot;IXIX&quot;),(0.2,pauli&quot;XYXY&quot;),(0.2,pauli&quot;ZZZZ&quot;),(0.1,pauli&quot;IXYZ&quot;)) @ q[1:4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/pauli.jl#L18-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.PauliX" href="#MimiqCircuitsBase.PauliX"><code>MimiqCircuitsBase.PauliX</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PauliX(p)</code></pre><p>One-qubit Pauli X noise channel (bit flip error).</p><p>This channel is defined by the Kraus operators</p><p class="math-container">\[E_1 = \sqrt{1-p}\,I, \quad E_2 = \sqrt{p}\,X,\]</p><p>where <span>$0 \leq p \leq 1$</span>.</p><p>This channel is a mixed unitary channel, see <a href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a>, and is a special case of <a href="#MimiqCircuitsBase.PauliNoise"><code>PauliNoise</code></a>.</p><p><code>PauliX(p)</code> is the same as <code>PauliNoise([1-p,p],[&quot;I&quot;,&quot;X&quot;])</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), PauliX(0.1), 1)
1-qubit circuit with 1 instructions:
└── PauliX(0.1) @ q[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/pauli.jl#L156-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.PauliY" href="#MimiqCircuitsBase.PauliY"><code>MimiqCircuitsBase.PauliY</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PauliY(p)</code></pre><p>One-qubit Pauli Y noise channel (bit-phase flip error).</p><p>This channel is determined by the Kraus operators</p><p class="math-container">\[E_1 = \\sqrt{1-p}\,I, \\quad E_2 = \sqrt{p}\,Y,\]</p><p>where <span>$0\\leq p \\leq 1$</span>.</p><p>This channel is a mixed unitary channel, see <a href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a>, and is a special case of <a href="#MimiqCircuitsBase.PauliNoise"><code>PauliNoise</code></a>.</p><p><code>PauliY(p)</code> is the same as <code>PauliNoise([1-p,p],[&quot;I&quot;,&quot;Y&quot;])</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), PauliY(0.1), 1)
1-qubit circuit with 1 instructions:
└── PauliY(0.1) @ q[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/pauli.jl#L217-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.PauliZ" href="#MimiqCircuitsBase.PauliZ"><code>MimiqCircuitsBase.PauliZ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PauliZ(p)</code></pre><p>One-qubit Pauli Z noise channel (phase flip error).</p><p>This channel is determined by the Kraus operators</p><p class="math-container">\[E_1 = \sqrt{1-p}\,I, \quad E_2 = \sqrt{p}\,Z,\]</p><p>where <span>$0 \leq p \leq 1$</span>.</p><p>This channel is a mixed unitary channel, see <a href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a>, and is a special case of <a href="#MimiqCircuitsBase.PauliNoise"><code>PauliNoise</code></a>.</p><p><code>PauliZ(p)</code> is the same as <code>PauliNoise([1-p,p],[&quot;I&quot;,&quot;Z&quot;])</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), PauliZ(0.1), 1)
1-qubit circuit with 1 instructions:
└── PauliZ(0.1) @ q[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/standard/pauli.jl#L277-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.MixedUnitary" href="#MimiqCircuitsBase.MixedUnitary"><code>MimiqCircuitsBase.MixedUnitary</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MixedUnitary(p,U)</code></pre><p>Custom <span>$N$</span> qubit mixed unitary channel specified by a list of unitary gates and a list of probabilities that add up to 1.</p><p>A mixed unitary noise channel is defined by</p><p class="math-container">\[\mathcal{E}(\rho) = \sum_k p_k U_k \rho U_k^\dagger,\]</p><p>where <span>$0\leq p_k \leq 1$</span> and <span>$U_k$</span> are unitary matrices. The probabilities must fulfill <span>$\sum_k p_k = 1$</span>.</p><p>If your Kraus matrices are not all proportional to unitaries, use <a href="#MimiqCircuitsBase.Kraus"><code>Kraus</code></a> instead.</p><p>The Kraus matrices are defined in the computational basis in the usual textbook order (the first qubit corresponds to the left-most qubit). For 1 qubit we have <span>$|0\rangle$</span>, <span>$|1\rangle$</span>. For 2 qubits we have <span>$|00\rangle$</span>, <span>$|01\rangle$</span>, <span>$|10\rangle$</span>, <span>$|11\rangle$</span>. See also <a href="../other/#MimiqCircuitsBase.GateCustom"><code>GateCustom</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently only 1 and 2-qubit custom MixedUnitary channels are supported.</p></div></div><p>See also <a href="#MimiqCircuitsBase.Kraus"><code>Kraus</code></a>, <a href="#MimiqCircuitsBase.ismixedunitary-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractKrausChannel"><code>ismixedunitary</code></a>, <a href="#MimiqCircuitsBase.AbstractKrausChannel"><code>AbstractKrausChannel</code></a>, and <a href="../operations/#MimiqCircuitsBase.RescaledGate"><code>RescaledGate</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>p</code>: Vector of probabilities, must be positive real numbers and add up to 1.</li><li><code>U</code>: Vector of either complex-valued <span>$2^N \times 2^N$</span> matrices or unitary gates acting on <span>$N$</span> qubits. Both can be mixed.</li></ul><p>The length of the vectors <code>p</code> and <code>U</code> must be equal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!(Circuit(), MixedUnitary([0.9, 0.1], [[1 0; 0 1], [0 1; 1 0]]), 1)
1-qubit circuit with 1 instructions:
└── MixedUnitary((0.9,Custom([1.0 0.0; 0.0 1.0])),(0.1,Custom([0.0 1.0; 1.0 0.0]))) @ q[1]

julia&gt; push!(Circuit(), MixedUnitary([0.8, 0.2], [GateID(), GateRX(0.2)]), 1)
1-qubit circuit with 1 instructions:
└── MixedUnitary((0.8,ID),(0.2,RX(0.2))) @ q[1]

julia&gt; push!(Circuit(), MixedUnitary([0.8, 0.2], [[1 0; 0 1], GateRX(0.2)]), 1)
1-qubit circuit with 1 instructions:
└── MixedUnitary((0.8,Custom([1.0 0.0; 0.0 1.0])),(0.2,RX(0.2))) @ q[1]

julia&gt; @variables x
1-element Vector{Symbolics.Num}:
 x

julia&gt; g= MixedUnitary([0.9, x], [[1 0; 0 1], [0 1; 1 0]])
MixedUnitary((0.9, Custom([1.0 0.0; 0.0 1.0])), (x, Custom([0.0 1.0; 1.0 0.0])))

julia&gt; evaluate(g,Dict(x=&gt;.1))
MixedUnitary((0.9, Custom([1.0 0.0; 0.0 1.0])), (0.1, Custom([0.0 1.0; 1.0 0.0])))

julia&gt; g= MixedUnitary([0.9, 0.1], [[1 0; 0 1], [0 1; 1 x]])
MixedUnitary((0.9, Custom([1 0; 0 1])), (0.1, Custom([0 1; 1 x])))

julia&gt; evaluate(g,Dict(x=&gt;0))
MixedUnitary((0.9, Custom([1 0; 0 1])), (0.1, Custom([0 1; 1 0])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/noisechannels/mixedunitary.jl#L18-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.PauliString" href="#MimiqCircuitsBase.PauliString"><code>MimiqCircuitsBase.PauliString</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PauliString(paulistr)</code></pre><p><span>$N$</span>-qubit tensor product of Pauli operators.</p><p>The PauliString gate can represent any <span>$N$</span>-qubit tensor product of Pauli operators of the form</p><p class="math-container">\[P_1 \otimes P_2 \otimes P_3 \otimes \ldots \otimes P_N,\]</p><p>where each <span>$P_i \in \{ I, X, Y, Z \}$</span> is a Pauli operator, including the identity.</p><p>See also <a href="../standard/#MimiqCircuitsBase.GateID"><code>GateID</code></a>, <a href="../standard/#MimiqCircuitsBase.GateX"><code>GateX</code></a>, <a href="../standard/#MimiqCircuitsBase.GateY"><code>GateY</code></a>, <a href="../standard/#MimiqCircuitsBase.GateZ"><code>GateZ</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>paulistr</code>: string of length <span>$N$</span> where each character is either <code>&quot;I&quot;</code>, <code>&quot;X&quot;</code>, <code>&quot;Y&quot;</code>, or <code>&quot;Z&quot;</code>. The number of qubits is equal to <span>$N$</span>.</li></ul><p><strong>Examples</strong></p><p>PauliStrings of any length are supported.</p><pre><code class="language-julia-repl hljs">julia&gt; c = push!(Circuit(), PauliString(&quot;XX&quot;), 1, 2)
2-qubit circuit with 1 instructions:
└── XX @ q[1:2]

julia&gt; push!(c, PauliString(&quot;IXYZZYXI&quot;), 1, 2, 3, 4, 5, 6, 7, 8)
8-qubit circuit with 2 instructions:
├── XX @ q[1:2]
└── IXYZZYXI @ q[1:8]</code></pre><p><strong>Decomposition</strong></p><p>Decomposes into one-qubit Pauli gates.</p><pre><code class="language-julia-repl hljs">julia&gt; decompose(PauliString(&quot;XIYZZ&quot;))
5-qubit circuit with 5 instructions:
├── X @ q[1]
├── ID @ q[2]
├── Y @ q[3]
├── Z @ q[4]
└── Z @ q[5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/generalized/paulistrings.jl#L18-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MimiqCircuitsBase.@pauli_str-Tuple{Any}" href="#MimiqCircuitsBase.@pauli_str-Tuple{Any}"><code>MimiqCircuitsBase.@pauli_str</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">macro pauli_str(s)</code></pre><p><code>pauli&quot;&quot;</code> literal for creating a <code>PauliString</code> gate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pauli&quot;XYYXZ&quot;
XYYXZ
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qperfect-io/MimiqCircuitsBase.jl/blob/v0.13.3/src/operations/generalized/paulistrings.jl#L152-L165">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../other/">« Other Operations</a><a class="docs-footer-nextpage" href="../operators/">Operators »</a><div class="flexbox-break"></div><p class="footer-message">Copyright 2021-2024 QPerfect. All rights reserved.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 24 November 2024 21:02">Sunday 24 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
