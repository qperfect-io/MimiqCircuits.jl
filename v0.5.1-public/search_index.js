var documenterSearchIndex = {"docs":
[{"location":"about/#About","page":"About","title":"About","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"MIMIQ Circuits uses highly efficient compression schemes to exactly simulate large quantum circuits with hundreds of qubits and provides approximate simulations for high entanglement circuits exceeding NISQ performance. It is ideal for learning how to design more complex quantum algorithms, optimizing quantum protocols to take full advantage of next generation hardware and for moving towards a quantum advantage in your quantum applications.","category":"page"},{"location":"about/#Computing-Paradigm","page":"About","title":"Computing Paradigm","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"At QPerfect, we strive to seamlessly integrate with your existing workflows. We provide user-friendly Julia or Python libraries that enable you to construct quantum circuits and connect to our remote services. Regardless of whether you prefer scripting, Jupyter notebooks, or Pluto notebooks, our approach ensures a fast and frictionless experience.","category":"page"},{"location":"about/#How-It-Works","page":"About","title":"How It Works","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Using MIMIQ Circuits is a straightforward process. You can leverage our open-source libraries to connect to our remote services and unlock the full potential of quantum circuit simulations. Here's a high-level overview of the process:","category":"page"},{"location":"about/","page":"About","title":"About","text":"Circuit Design: Leverage our comprehensive libraries to construct intricate quantum circuits effortlessly. Our libraries offer a set of functions and tools for defining and manipulating quantum circuits.\nJob Request: Once your circuit is ready, submit a job request to our remote services using the Python or Julia libraries. This request contains the circuit information along with any specific simulation parameters.\nSimulation and Execution: Our robust remote infrastructure takes charge and performs the quantum circuit simulation using powerful cloud based computational resources.\nResult Retrieval: After the simulation completes, you can retrieve the results through the Julia/Python libraries or via a web interface.","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/#Installation-instructions","page":"Getting Started","title":"Installation instructions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Julia is required to use MimiqCircuits.jl. If you do not have it on your system, please refer to the official website. We recommend to install Julia via the juliaup tool, which will manage updates and multiple versions of Julia on the same system automatically.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To install the latest version of MimiqCircuitsBase.jl, use the Julia's built-in package manager (accessed by pressing ] in the Julia REPL command prompt).","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Before installing the package itself, since we didn't add it to the public Julia General registry, make sure to have installed QPerfect's own package registry.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n(v1.9) pkg> registry update\n(v1.9) pkg> registry add https://github.com/qperfect-io/QPerfectRegistry.git\n(v1.9) pkg> add MimiqCircuits","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nThe ] registry update command will make sure, if this is your first time starting up Julia, to install and download the Julia General registry, where most packages are registered.","category":"page"},{"location":"getting_started/#Jupyter","page":"Getting Started","title":"Jupyter","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If you want to use Jupyter, you need to install the Julia Jupyter kernel. This can be easily accomplished by running the following command in the julia session:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n(v1.9) pkg> add IJulia","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Optionally, in order to make use of visualization utilities and functionalities, especially in Jupyter notebooks, it is recommanded to install the MimiqVisual.jl package, chich contain the extra support for visualization:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n(v1.9) pkg> add MimiqVisual","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"With these steps completed, you are now ready to explore the features and capabilities of MIMIQ Circuits within your Python virtual environment. Happy coding!","category":"page"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/outline/#Library-Outline","page":"Contents","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"using MimiqCircuits ","category":"page"},{"location":"basics/#Basic-Concepts","page":"Basics","title":"Basic Concepts","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"This section provides an overview of how the circuit simulation works in our framework.","category":"page"},{"location":"basics/#Quantum-Circuit","page":"Basics","title":"Quantum Circuit","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"A quantum circuit is a sequence of quantum gates and operations acting on qubits, the basic units of quantum information.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Every computation, in MIMIQ Circuits starts with the construction of a quantum circuit. You can construct the circuit using the tools provided by the \"MimiqCircuits\" library, including gates and various quantum operations. Once you have built the circuit, you can proceed with the simulation.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"A simple circuit with 4 Hadamard gates on 4 different qubits is given by","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"c = Circuit()\nfor i in 1:4\n    push!(c, GateH(), i)\nend","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"or simply","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"c = Circuit()\npush!(c, GateH(), 1:4)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"We are using a @ notation to indicates that a quantum operation, in this case a Hadamard gate H, is applied to one or many qubits. Hadamard gates are single qubit gates, so they can be applied only to one qubit at a time (e.g. H @ q0 in the example). In this notation we indicate with q0, q1, q2... qubits or quantum bit targets and with c0, c1, c2, ... classical bit targets.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"note: Note\nIndexing of targets is different between Julia and Python. Julia indices starts from 1, while Python indices start from 0. Pay extra attention when translating code from Python or to Julia and vice versa (e.g. when importing code from other frameworks).","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Quantum circuits can be easily manipulated in MimiqCircuits. Some common operations include:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Adding gates or quantum operations (e.g. with push!(circuit, operation, targets...)),","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"c = Circuit()\npush!(c, GateH(), 1)\npush!(c, GateCX(), 1, 2)\npush!(c, GateRX(π / 4), 2)\npush!(c, GateCH(), 2, 1)\npush!(c, Barrier(2), 1, 2)\npush!(c, Measure(), 1, 1)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Taking the inverse of a circuit or any other object (with inverse(op or circuit))","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"c = let c = Circuit()\n    push!(c, GateH(), 1:2)\n    push!(c, GateCRX(π / 4), 1, 2)\n    push!(c, GateS(), 1)\n    c\nend\ncinv = inverse(c)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Appending a circuit to another (with append!(circuit, other))","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"c = let c = Circuit()\n    push!(c, GateH(), 1:4)\nend\nc1 = let c = Circuit()\n    push!(c1, GateCH(), 1, 2:4)\nend\nappend!(c, c1)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"For a full list of functions see MimiqCircuitsBase.Circuit.","category":"page"},{"location":"basics/#Bit-States","page":"Basics","title":"Bit States","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"We define bit states as the computational states of a multi qubit system in which each qubit state is determined. These states are often indicated by the notation","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"ket01001010cdots\nequiv\nket0ket1ket0ket0ket1ket0ket1ket0cdots","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Each bit state is fully specified a string of zeros and ones, and hence they are sometimes also referred to as \"bitstrings\".","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"The set of all the possible bit states form an complete and orthogonal basis for the quantum state of a multiqubit system, meaning that an arbitrary quantum state of such system can be written as a sum over bit states with complex coefficients.  For example, for a 2 qubit system:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"ketpsi =\nc_0 ket00 + c_1 ket10 + c_2 ket01 + c_3 ket11\nqquad\nforall c_0 c_1 c_2 c_3 sum_0^3 c_i^2 = 1","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"MimiqCircuits provides users with a set of utilities to handle, construct and manipulate bit states. ","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Few things you can do with BitState:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Create a bit state for a :mathN-qubit system (:math:N=4 in the example)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"x = BitState(4)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Create a bit state from a list of nonzero qubits, or from an integer (converting from its binary representation)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"x = BitState(10, [1,3,8])\ny = BitState(10, 5)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Create a bit state using a generator function (lambda function in this case):","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"x = BitState(10) do i\n    iseven(x)\nend","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Convert a BitState to a string, index or integer (remember in Julia,","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"indices starts from 1)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"bs = BitState(10, 534)\nto01(bs)\nbitstate_to_index(bs)\nbitstate_to_integer(bs)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Get the state of each qubit, the list of nonzero qubits, or even iterate over the qubits","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"bs = BitState(10, 534)\nbs[10]\nnonzeros(bs)\nfor i in bs\n    print(i)\nend","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Besides accessing the quantum state amplitudes corresponding to different bit states, with MIMIQ Circuits, you also have the flexibility to sample the final state in much the same way as is the case for a real quantum computer. ","category":"page"},{"location":"basics/#Executing-the-Circuit","page":"Basics","title":"Executing the Circuit","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"The simulation of a circuit is then performed via the MimiqCircuits.execute function, which start a remote job on the MIMIQ Remote Services. When a job is completed, results can be retrieved by the MimiqCircuits.getresults function. Upon execution, you can specify the algorithm used in the simulation, the number of samples to be performed or the bit states for which the amplitudes should be computed.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"A simulation performs the computation","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"ketpsi = U ket000cdots","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"The starting state is always the one where all the qubits are in the ket0 state. After the circuit execution, the final state ketpsi is used for extracting amplitudes and for sampling.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Below we show a graphical representation of the circuit execution.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"(Image: Circuit execution example)","category":"page"},{"location":"basics/#Sampling","page":"Basics","title":"Sampling","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"Sampling is performed by applying a measurements operation to the final state on each and every qubit. With MIMIQ Circuits many samples can be obtained very efficiently without necessarily recomputing the whole circuit. The number of samples to obtain is specified through the samples keyword argument when executing a job.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"note: Note\nThe maximum number of samples a user can request is of 2^16","category":"page"},{"location":"basics/#Amplitudes","page":"Basics","title":"Amplitudes","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"Amplitudes corresponding to the bit states specified when submitting a simulation, are computed just before the sampling process, right after having applied the circuit provided by the user.","category":"page"},{"location":"basics/#Classical-Registries-and-Mid-Circuit-Measurements","page":"Basics","title":"Classical Registries and Mid-Circuit Measurements","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"At present, MIMIQ Circuits does not support classical registers or measurements in the middle of the circuit. However, we are continuously working to enhance our framework with the plan to introduce these features in a coming update.","category":"page"},{"location":"library/internals/","page":"Private","title":"Private","text":"Private types and functions","category":"page"},{"location":"library/internals/","page":"Private","title":"Private","text":"Documentation for MimiqCircuits.jl's internal interface.","category":"page"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [MimiqCircuits]\nPublic  = false","category":"page"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [MimiqCircuitsBase]\nPublic  = false","category":"page"},{"location":"library/internals/#MimiqCircuitsBase.fromdict","page":"Private","title":"MimiqCircuitsBase.fromdict","text":"fromdict(object, dict)\n\nReturns the given object from the serialized JSON dictionary.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#MimiqCircuitsBase.todict","page":"Private","title":"MimiqCircuitsBase.todict","text":"todict(circuit)\ntodict(instruction)\ntodict(operation)\n\n\n\n\n\n","category":"function"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [MimiqLink]\nPublic  = false","category":"page"},{"location":"library/internals/#MimiqLink.DEFAULT_INTERVAL","page":"Private","title":"MimiqLink.DEFAULT_INTERVAL","text":"const DEFAULT_INTERVAL\n\nDefault refresh interval for tokens (in seconds)\n\n\n\n\n\n","category":"constant"},{"location":"library/internals/#MimiqLink.QPERFECT_CLOUD","page":"Private","title":"MimiqLink.QPERFECT_CLOUD","text":"const QPERFECT_CLOUD\n\nFallback address for the QPerfect Cloud services\n\n\n\n\n\n","category":"constant"},{"location":"library/internals/#MimiqLink.Connection","page":"Private","title":"MimiqLink.Connection","text":"struct Connection\n\nConnection with the MIMIQ Services.\n\nAttributes\n\nuri: the URI of the connected instance\ntokens_channel: channel updated with the latest refreshed token\nrefresher: task that refreshes the token on a configured interval\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqLink.Execution","page":"Private","title":"MimiqLink.Execution","text":"struct Execution\n\nStructure referring to an execution on the MIMIQ Services.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqLink.Tokens","page":"Private","title":"MimiqLink.Tokens","text":"struct Tokens\n\nStore access and refresh tokens\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#MimiqLink.connect","page":"Private","title":"MimiqLink.connect","text":"connect([; url=https://mimiq.qperfect.io])\nconnect(token[; url=https://mimiq.qperfect.io])\nconnect(username, password[; url=https://mimiq.qperfect.io])\n\nEstablish a connection to the MIMIQ Services.\n\nA refresh process will be spawned in the background to refresh the access credentials. An active connection can be closed by using the close(connection) method. As an example:\n\nconnection = connect(\"john.doe@example.com\", \"johnspassword\")\nclose(connection)\n\nwarning: Warning\nThe first method will open a login page in the default browser and ask for your email and password. This method is encouraged, as it will avoid saving your password as plain text in your scripts or notebooks.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#MimiqLink.loadtoken","page":"Private","title":"MimiqLink.loadtoken","text":"loadtoken([filename])\n\nEstablish a connection to the MIMIQ Services by loading the credentials from a JSON file.\n\nArguments\n\nfilename: file where to load the credentials (default: qperfect.json)\n\nnote: Note\n\n\nThe credentials are usually valid only for a small amount of time, so you may need to regenerate them from time to time.\n\nExample\n\njulia> savetoken(\"myqperfectcredentials.json\")\n\njulia> connection = loadtoken(\"myqperfectcredentials.json\")\n\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#MimiqLink.refresh-Tuple{MimiqLink.Tokens, URIs.URI}","page":"Private","title":"MimiqLink.refresh","text":"refresh(tokens, uri)\n\nRefresh the tokens at the given uri / instance of MIMIQ.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#MimiqLink.savetoken","page":"Private","title":"MimiqLink.savetoken","text":"savetoken([filename][; uri=\"https://mimiq.qperfect.io/api\"])\n\nEstablish a connection to the MIMIQ Services and save the credentials in a JSON file.\n\nArguments\n\nfilename: file where to save the credentials (default: qperfect.json)\n\nKeyword arguments\n\nuri: the uri of the MIMIQ Services (default: https://mimiq.qperfect.io/api)\n\nExample\n\njulia> savetoken(\"myqperfectcredentials.json\")\n\njulia> connection = loadtoken(\"myqperfectcredentials.json\")\n\n\n\n\n\n\n","category":"function"},{"location":"#MimiqCircuits.jl-Documentation","page":"Home","title":"MimiqCircuits.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIMIQ Circuits is a quantum computing framework and high performance simulator developed by QPerfect that allows you to develop and run your quantum algorithms beyond the limits of today's noisy intermediate scale quantum (NISQ) computers.","category":"page"},{"location":"#Alpha-Release","page":"Home","title":"Alpha Release","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIMIQ Circuits is currently in the alpha stage and open to test for early adopters. We are continuously refining and enhance our tools so we value any feedback you may have to ensure that MIMIQ Circuits meets and exceeds your expectations. If you want access to MIMIQ Circuits, we encourage you register on our website.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Embark on this quantum computing journey with us during the beta stage of MIMIQ Circuits, and take part in the large scale quantum revolution!","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for MimiqCircuits.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs.","category":"page"},{"location":"library/public/#Modules","page":"Public","title":"Modules","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuits]\nPrivate = false\nPages   = [\"MimiqCircuits.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuits.execute-Tuple{Connection, Circuit}","page":"Public","title":"MimiqCircuits.execute","text":"execute(connection, circuit[; kwargs...])\n\nExecute a quantum circuit on the MIMIQ remote services.\n\nThe circuit is applied to the zero state and the resulting state is measured via sampling. Optionally amplitudes corresponding to few selected bit states (or bitstrings) can be returned from the computation.\n\nKeyword Arguments\n\nlabel::String: mnemonic name to give to the simulation, will be visible on the web interface\nalgorithm: algorithm to use by the compuation. By default \"auto\" will select the fastest algorithm between \"statevector\" or \"mps\".\nnsamples::Integer: number of times to sample the circuit (default: 1000, maximum: 2^16)\nbitstates::Vector{BitState}: list of bit states to compute the amplitudes for (default: BitState[])\ntimelimit: number of seconds before the computation is stopped (default: 300 seconds or 5 minutes)\nbonddim::Int64: bond dimension for the MPS algorithm (default: 256, maximum: 4096)\nseed::Int64: a seed for running the simulation (default: random seed)\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuits.getinputs-Tuple{Connection, Execution}","page":"Public","title":"MimiqCircuits.getinputs","text":"getinputs(connection, execution)\n\nReturns the circuit and parameters for the given execution.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuits.getresults-Tuple{Connection, Execution}","page":"Public","title":"MimiqCircuits.getresults","text":"getresults(connection, execution; kwargs...)\n\nBlock until the given execution is finished and return the results.\n\nKeyword Arguments\n\ninterval: time interval in seconds to check for job completion (default: 10)\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuits.printreport-Tuple{Results}","page":"Public","title":"MimiqCircuits.printreport","text":"printreport(res::MimiqCircuits.Results; kwargs...)\n\nPrint a report on the MIMIQ simulation results res\n\nKeyword Arguments\n\nmax_outcomes: the maximum number of unique measurement outcomes to display (default 8)\n\n\n\n\n\n","category":"method"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"MimiqCircuitsBase.jl\"]","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqLink]\nPrivate = false\nPages   = [\"MimiqLink.jl\"]","category":"page"},{"location":"library/public/#MimiqLink.MimiqLink","page":"Public","title":"MimiqLink.MimiqLink","text":"module MimiqLink end\n\nThis module contains convenience tools to establish and keep up a connection to the QPerfect MIMIQ services, both remote or on premises.\n\nIt allows for three different connection modes: via login page, via token, via credentials\n\nLogin Page\n\nThis method will open a browser pointing to a login page. The user will be asked to insert username/email and password.\n\njulia> using MimiqLink\n\njulia> connection = MimiqLink.connect()\n\noptionally an address for the MIMIQ services can be specified\n\njulia> connection = MimiqLink.connect(uri = \"http://127.0.0.1/api\")\n\nToken\n\nThis method will allow the user to save a token file (by login via a login page), and then load it also from another julia session.\n\njulia> using MimiqLink\n\njulia> MimiqLink.savetoken(uri = \"http://127.0.0.1/api\")\n\nthis will save a token in the qperfect.json file in the current directory. In another julia session is then possible to do:\n\njulia> using MimiqLink\n\njulia> connection = MimiqLink.loadtoken(\"path/to/my/qperfect.json\")\n\nCredentials\n\nThis method will allow users to access by directly use their own credentials.\n\nWARNING it is strongly discuraged to use this method. If files with credentials will be shared the access to the qperfect account might be compromised.\n\njulia> using MimiqLink\n\njulia> connection = MimiqLink.connect(\"me@mymail.com\", \"myweakpassword\")\n\njulia> MimiqLink.connect(\"me@mymail.com\", \"myweakpassword\"; uri = \"http://127.0.0.1/api\")\n\n\n\n\n\n","category":"module"},{"location":"library/public/#Quantum-Circuits-and-Instructions","page":"Public","title":"Quantum Circuits and Instructions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"instruction.jl\", \"circuit.jl\", \"circuit_extras.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.Instruction","page":"Public","title":"MimiqCircuitsBase.Instruction","text":"struct Instruction{N,M,T<:Operation}\n\nElement of a quantum circuit, representing a N-qubit gate applied to N targets\n\nParameters\n\ngate::T actual gate represented\nqtargets::NTuple{N, Int64} indices specifying the quantum bits on which the instruction is applied\nctargets::NTuple{N, Int64} indices specifying the classical bits on which the instruction is applied\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.getbit","page":"Public","title":"MimiqCircuitsBase.getbit","text":"getbit(instruction, i)\n\nReturns the i-th target classical bit of an instruction.\n\nSee also getbits, getqubit, getqubits,\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.getbits","page":"Public","title":"MimiqCircuitsBase.getbits","text":"getbits(instruction)\n\nReturns all the classical bits to which the instruction is applied.\n\nSee also getbit, getqubits, getqubit,\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.getoperation-Tuple{Instruction}","page":"Public","title":"MimiqCircuitsBase.getoperation","text":"getoperation(getoperation)\n\nReturns the quantum operation associated to the given gate instruction.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.getqubit","page":"Public","title":"MimiqCircuitsBase.getqubit","text":"getqubit(instruction, i)\n\nReturns the i-th target qubit of an instruction.\n\nSee also getqubits, getbit, getbits,\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.getqubits","page":"Public","title":"MimiqCircuitsBase.getqubits","text":"getqubits(instruction)\n\nReturns all the quantum bits to which the instruction is applied.\n\nSee also getqubit, getbits, getbit,\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.gettarget","page":"Public","title":"MimiqCircuitsBase.gettarget","text":"gettarget(instruction, i)\n\nReturns the i-th target qubit of an instruction.\n\n!!!warn     Deprecated in favor of getqubit and getbit\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.gettargets","page":"Public","title":"MimiqCircuitsBase.gettargets","text":"gettargets(instruction)\n\nReturns all the quantum qubits to which the instruction is applied.\n\n!!!warn     Deprecated in favor of getqubits and getbits\n\n\n\n\n\n","category":"function"},{"location":"library/public/#MimiqCircuitsBase.Circuit","page":"Public","title":"MimiqCircuitsBase.Circuit","text":"struct Circuit\n\nRepresentation of a quantum circuit as a vector of gates applied to the qubits.\n\nParameters\n\ngates::Vector{Instruction} vector of quantum instructions (see Instruction)\n\nExample iteration\n\ncircuit = Circuit()\n# add gates to circuit\n\nfor (; operation, targets) in circuit\n    # do something with the gate and its targets\n    # e.g.\nend\n\n(here the iteration parameters should be called operation and targets to proper destructure a Instruction)\n\nGate types\n\nSingle qubit gates (basic): GateX, GateY, GateZ, GateH, GateS, GateSDG, GateT, GateTDG, GateSX, GateSXDG, GateID\nSingle qubit gates (parametric): GateRX, GateRY, GateRZ, GateP, GateR, GateU\nTwo qubit gates (basic): GateCX, GateCY, GateCZ, GateCH, GateSWAP, GateISWAP, GateISWAPDG\nTwo qubit gates (parametric): GateCP, GateCRX, GateCRY, GateCRZ, GateCU\nCustom gate (currently only for 1 and 2 qubit gates): GateCustom\n\nSpecial operations\n\nBarrier, Reset, Measure\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Operations","page":"Public","title":"Operations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"operation.jl\"]","category":"page"},{"location":"library/public/#Gates","page":"Public","title":"Gates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"gate.jl\"]","category":"page"},{"location":"library/public/#Single-qubit-gates","page":"Public","title":"Single qubit gates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"singlequbit.jl\", \"singlequbitpar.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.GateH","page":"Public","title":"MimiqCircuitsBase.GateH","text":"struct GateH <: Gate{1}\n\nSingle qubit Hadamard gate.\n\nMatrix Representation\n\noperatorname H = frac1sqrt2\nbeginpmatrix\n    1  1 \n    1  -1\nendpmatrix\n\nExamples\n\njulia> matrix(GateH())\n2×2 Matrix{Float64}:\n 0.707107   0.707107\n 0.707107  -0.707107\n\njulia> push!(Circuit(), GateH(), 1)\n1-qubit circuit with 1 gates:\n└── H @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateID","page":"Public","title":"MimiqCircuitsBase.GateID","text":"struct GateID <: Gate{1}\n\nSingle qubit Identity gate\n\nMatrix Representation\n\noperatornameI =\nbeginpmatrix\n    1  0 \n    0  1\nendpmatrix\n\nExamples\n\njulia> matrix(GateID())\n2×2 Matrix{Float64}:\n 1.0  -0.0\n 0.0   1.0\n\njulia> push!(Circuit(), GateID(), 1)\n1-qubit circuit with 1 gates:\n└── ID @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateS","page":"Public","title":"MimiqCircuitsBase.GateS","text":"struct GateS <: Gate{1}\n\nSingle qubit S gate (or Phase gate).\n\nSee also GateSDG\n\nMatrix Representation\n\noperatorname S =\nbeginpmatrix\n    1  0 \n    0  i\nendpmatrix\n\nExamples\n\njulia> matrix(GateS())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+1.0im\n\njulia> push!(Circuit(), GateS(), 1)\n1-qubit circuit with 1 gates:\n└── S @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateSDG","page":"Public","title":"MimiqCircuitsBase.GateSDG","text":"struct GateSDG <: Gate{1}\n\nSingle qubit S-dagger gate (conjugate transpose of the S gate).\n\nSee also GateS\n\nMatrix Representation\n\noperatorname S^dagger =\nbeginpmatrix\n    1  0 \n    0  -i\nendpmatrix\n\nExamples\n\njulia> matrix(GateSDG())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0-1.0im\n\njulia> push!(Circuit(), GateSDG(), 1)\n1-qubit circuit with 1 gates:\n└── SDG @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateSX","page":"Public","title":"MimiqCircuitsBase.GateSX","text":"struct GateSX <: Gate{1}\n\nSingle qubit √X gate.\n\nSee also GateSXDG, GateX\n\nMatrix Representation\n\nsqrtoperatornameX = frac12\nbeginpmatrix\n    1+i  1-i \n    1-i  1+i\nendpmatrix\n\nExamples\n\njulia> matrix(GateSX())\n2×2 Matrix{ComplexF64}:\n 0.5+0.5im  0.5-0.5im\n 0.5-0.5im  0.5+0.5im\n\njulia> push!(Circuit(), GateSX(), 1)\n1-qubit circuit with 1 gates:\n└── SX @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateSXDG","page":"Public","title":"MimiqCircuitsBase.GateSXDG","text":"struct GateSXDG <: Gate{1}\n\nSingle qubit √X-dagger gate (conjugate transpose of the √X gate)\n\nSee also GateSX, GateX\n\nMatrix Representation\n\nsqrtoperatornameX^dagger = frac12\nbeginpmatrix\n    1-i  1+i \n    1+i  1-i\nendpmatrix\n\nExamples\n\njulia> matrix(GateSXDG())\n2×2 Matrix{ComplexF64}:\n 0.5-0.5im  0.5+0.5im\n 0.5+0.5im  0.5-0.5im\n\njulia> push!(Circuit(), GateSXDG(), 1)\n1-qubit circuit with 1 gates:\n└── SXDG @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateT","page":"Public","title":"MimiqCircuitsBase.GateT","text":"struct GateT <: Gate{1}\n\nSingle qubit T gate.\n\nSee also GateTDG\n\nMatrix Representation\n\noperatorname T =\nbeginpmatrix\n    1  0 \n    0  exp(fracipi4)\nendpmatrix\n\nExamples\n\njulia> matrix(GateT())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.707107+0.707107im\n\njulia> push!(Circuit(), GateT(), 1)\n1-qubit circuit with 1 gates:\n└── T @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateTDG","page":"Public","title":"MimiqCircuitsBase.GateTDG","text":"struct GateTDG <: Gate{1}\n\nSingle qubit T-dagger gate (conjugate transpose of the T gate).\n\nSee also GateT\n\nMatrix Representation\n\noperatorname T^dagger =\nbeginpmatrix\n    1  0 \n    0  exp(frac-ipi4)\nendpmatrix\n\nExamples\n\njulia> matrix(GateTDG())\n2×2 Matrix{ComplexF64}:\n 1.0+0.0im       0.0+0.0im\n 0.0+0.0im  0.707107-0.707107im\n\njulia> push!(Circuit(), GateTDG(), 1)\n1-qubit circuit with 1 gates:\n└── TDG @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateX","page":"Public","title":"MimiqCircuitsBase.GateX","text":"struct GateX <: Gate{1}\n\nSingle qubit Pauli-X gate.\n\nMatrix Representation\n\noperatorname X =\nbeginpmatrix\n    0  1 \n    1  0\nendpmatrix\n\nExamples\n\njulia> matrix(GateX())\n2×2 Matrix{Float64}:\n 0.0   1.0\n 1.0  -0.0\n\njulia> push!(Circuit(), GateX(), 1)\n1-qubit circuit with 1 gates:\n└── X @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateY","page":"Public","title":"MimiqCircuitsBase.GateY","text":"struct GateY <: Gate{1}\n\nSingle qubit Pauli-Y gate.\n\nMatrix Representation\n\noperatorname Y =\nbeginpmatrix\n    0  -i \n    i  0\nendpmatrix\n\nExamples\n\njulia> matrix(GateY())\n2×2 Matrix{ComplexF64}:\n 0.0+0.0im  -0.0-1.0im\n 0.0+1.0im  -0.0+0.0im\n\njulia> push!(Circuit(), GateY(), 1)\n1-qubit circuit with 1 gates:\n└── Y @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateZ","page":"Public","title":"MimiqCircuitsBase.GateZ","text":"struct GateZ <: Gate{1}\n\nSingle qubit Pauli-Z gate.\n\nMatrix Representation\n\noperatorname Z =\nbeginpmatrix\n    1  0 \n    0  -1\nendpmatrix\n\nExamples\n\njulia> matrix(GateZ())\n2×2 Matrix{Float64}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> push!(Circuit(), GateZ(), 1)\n1-qubit circuit with 1 gates:\n└── Z @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Two-qubit-gates","page":"Public","title":"Two-qubit gates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"twoqubit.jl\", \"twoqubitpar.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.GateCH","page":"Public","title":"MimiqCircuitsBase.GateCH","text":"struct GateCH <: Gate{2}\n\nTwo qubit Controlled-Hadamard gate.\n\nMatrix Representation\n\noperatornameCH = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  frac1sqrt2  frac1sqrt2 \n    0  0  frac1sqrt2  -frac1sqrt2\nendpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCH())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0        0.0\n 0.0  1.0  0.0        0.0\n 0.0  0.0  0.707107   0.707107\n 0.0  0.0  0.707107  -0.707107\n\njulia> push!(Circuit(), GateCH(), 1, 2)\n2-qubit circuit with 1 gates:\n└── CH @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCS","page":"Public","title":"MimiqCircuitsBase.GateCS","text":"struct GateCS <: Gate{2}\n\nTwo qubit Controlled-S gate.\n\nMatrix Representation\n\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  i\nendpmatrix\n\nExamples\n\njulia> matrix(GateCS())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im\n\njulia> push!(Circuit(), GateCS(), 1, 2)\n2-qubit circuit with 1 gates:\n└── CS @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCSDG","page":"Public","title":"MimiqCircuitsBase.GateCSDG","text":"struct GateCSDG <: Gate{2}\n\nTwo qubit CS-dagger gate.\n\nMatrix Representation\n\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  i\nendpmatrix\n\nExamples\n\njulia> matrix(GateCSDG())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im\n\njulia> push!(Circuit(), GateCSDG(), 1, 2)\n2-qubit circuit with 1 gates:\n└── CSDG @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCSX","page":"Public","title":"MimiqCircuitsBase.GateCSX","text":"struct GateCSX <: Gate{2}\n\nTwo qubit Controlled-SX gate. (Control on second qubit)\n\nMatrix Representation\n\nbeginpmatrix\n    1  0  0  0 \n    0  frac1+isqrt2  0  frac1-isqrt2 \n    0  0  1  0 \n    0  frac1-isqrt2  0  frac1+isqrt2\nendpmatrix\n\nExamples\n\njulia> matrix(GateCSX())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.5+0.5im  0.0+0.0im  0.5-0.5im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.5-0.5im  0.0+0.0im  0.5+0.5im\n\njulia> push!(Circuit(), GateCSX(), 1, 2)\n2-qubit circuit with 1 gates:\n└── CSX @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCSXDG","page":"Public","title":"MimiqCircuitsBase.GateCSXDG","text":"struct GateCSXDG <: Gate{2}\n\nTwo qubit CSX-dagger gate. (Control on second qubit)\n\nMatrix Representation\n\nbeginpmatrix\n    1  0  0  0 \n    0  frac1-isqrt2  0  frac1+isqrt2 \n    0  0  1  0 \n    0  frac1+isqrt2  0  frac1-isqrt2\nendpmatrix\n\nExamples\n\njulia> matrix(GateCSXDG())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.5-0.5im  0.0+0.0im  0.5+0.5im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.5+0.5im  0.0+0.0im  0.5-0.5im\n\njulia> push!(Circuit(), GateCSXDG(), 1, 2)\n2-qubit circuit with 1 gates:\n└── CSXDG @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCX","page":"Public","title":"MimiqCircuitsBase.GateCX","text":"struct GateCX <: Gate{2}\n\nTwo qubit Controlled-X gate (or CNOT).\n\nMatrix Representation\n\noperatornameCX =\nbeginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\nendpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCX())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0   0.0\n 0.0  1.0  0.0   0.0\n 0.0  0.0  0.0   1.0\n 0.0  0.0  1.0  -0.0\n\n\njulia> push!(Circuit(), GateCX(), 1, 2)\n2-qubit circuit with 1 gates:\n└── CX @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCY","page":"Public","title":"MimiqCircuitsBase.GateCY","text":"struct GateCY <: Gate{2}\n\nTwo qubit Controlled-Y gate.\n\nMatrix Representation\n\noperatornameCY = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  -i \n    0  0  i  0\nendpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCY())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  -0.0-1.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  -0.0+0.0im\n\njulia> push!(Circuit(), GateCY(), 1, 2)\n2-qubit circuit with 1 gates:\n└── CY @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCZ","page":"Public","title":"MimiqCircuitsBase.GateCZ","text":"struct GateCZ <: Gate{2}\n\nTwo qubit Controlled-Z gate.\n\nMatrix Representation\n\noperatornameCZ = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\nendpmatrix\n\nBy convention we refer to the first qubit as the control qubit and the second qubit as the target.\n\nExamples\n\njulia> matrix(GateCZ())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0   0.0\n 0.0  1.0  0.0   0.0\n 0.0  0.0  1.0   0.0\n 0.0  0.0  0.0  -1.0\n\njulia> push!(Circuit(), GateCZ(), 1, 2)\n2-qubit circuit with 1 gates:\n└── CZ @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateDCX","page":"Public","title":"MimiqCircuitsBase.GateDCX","text":"struct GateDCX <: Gate{2}\n\nTwo qubit double-CNOT (Control on first qubit and then second) OR DCX gate.\n\nMatrix Representation\n\nbeginpmatrix\n    1  0  0  0 \n    0  0  0  1 \n    0  1  0  0 \n    0  0  1  0\nendpmatrix\n\nExamples\n\njulia> matrix(GateDCX())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n\njulia> push!(Circuit(), GateDCX(), 1, 2)\n2-qubit circuit with 1 gates:\n└── DCX @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateDCXDG","page":"Public","title":"MimiqCircuitsBase.GateDCXDG","text":"struct GateDCXDG <: Gate{2}\n\nTwo qubit DCX-dagger gate.\n\nMatrix Representation\n\nbeginpmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  0  0  1 \n    0  1  0  0\nendpmatrix\n\nExamples\n\njulia> matrix(GateDCXDG())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n 0.0  1.0  0.0  0.0\n\njulia> push!(Circuit(), GateDCXDG(), 1, 2)\n2-qubit circuit with 1 gates:\n└── DCXDG @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateECR","page":"Public","title":"MimiqCircuitsBase.GateECR","text":"struct GateECR <: Gate{2}\n\nTwo qubit ECR echo gate.\n\nMatrix Representation\n\nbeginpmatrix\n    0  frac1sqrt2   0  fracisqrt2  \n    frac1sqrt2  0  frac-isqrt2  0 \n    0  fracisqrt2  0  fracisqrt2  \n    frac-isqrt2  0  frac1sqrt2   0 \nendpmatrix\n\nExamples\n\njulia> matrix(GateCSX())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.5+0.5im  0.0+0.0im  0.5-0.5im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.5-0.5im  0.0+0.0im  0.5+0.5im\n\njulia> push!(Circuit(), GateCSX(), 1, 2)\n2-qubit circuit with 1 gates:\n└── CSX @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateISWAP","page":"Public","title":"MimiqCircuitsBase.GateISWAP","text":"struct GateISWAP <: Gate{2}\n\nTwo qubit ISWAP gate.\n\nSee also GateISWAPDG, GateSWAP.\n\nMatrix Representation\n\noperatornameISWAP = frac1sqrt2\nbeginpmatrix\n    1  0  0  0 \n    0  0  i  0 \n    0  i  0  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> matrix(GateISWAP())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+1.0im  0.0+0.0im\n 0.0+0.0im  0.0+1.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im\n\njulia> push!(Circuit(), GateISWAP(), 1, 2)\n2-qubit circuit with 1 gates:\n└── ISWAP @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateISWAPDG","page":"Public","title":"MimiqCircuitsBase.GateISWAPDG","text":"struct GateISWAPDG <: Gate{2}\n\nTwo qubit ISWAP-dagger gate (conjugate transpose of ISWAP)\n\nSee also GateISWAP, GateSWAP\n\nMatrix Representation\n\noperatornameISWAP^dagger = frac1sqrt2\nbeginpmatrix\n    1  0  0  0 \n    0  0  -i  0 \n    0  -i  0  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> matrix(GateISWAPDG())\n4×4 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0-1.0im  0.0+0.0im\n 0.0+0.0im  0.0-1.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im\n\njulia> push!(Circuit(), GateISWAPDG(), 1, 2)\n2-qubit circuit with 1 gates:\n└── ISWAPDG @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateSWAP","page":"Public","title":"MimiqCircuitsBase.GateSWAP","text":"struct GateSWAP <: Gate{2}\n\nTwo qubit SWAP gate.\n\nSee also GateISWAP\n\nMatrix Representation\n\noperatornameSWAP = frac1sqrt2\nbeginpmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  1  0  0 \n    0  0  0  1\nendpmatrix\n\nExamples\n\njulia> matrix(GateSWAP())\n4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> push!(Circuit(), GateSWAP(), 1, 2)\n2-qubit circuit with 1 gates:\n└── SWAP @ q1, q2\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Multi-qubit","page":"Public","title":"Multi-qubit","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"multiqubit.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.GateCCX","page":"Public","title":"MimiqCircuitsBase.GateCCX","text":"struct GateCCX <: Gate{3}\n\nC₂X (or C₂NOT) 3-qubits gate. Where the first two qubits are used as controls.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.GateCSWAP","page":"Public","title":"MimiqCircuitsBase.GateCSWAP","text":"struct GateCSWAP <: Gate{3} end\n\n3-qubits control SWAP gate where the first qubit is the control.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Custom-gates","page":"Public","title":"Custom gates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"custom.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.GateCustom","page":"Public","title":"MimiqCircuitsBase.GateCustom","text":"struct GateCustom{N,T} <: Gate{N}\n\nN qubit gate specified by a 2^N times 2^N matrix with elements of type T.\n\nUse this to construct your own gates based on unitary matrices. Currently only N=1,2 (M=2,4) are recognised.\n\nMIMIQ uses textbook convention for specifying gates.\n\nOne qubit gate matrices are defined in the basis 0rangle, 1rangle e.g.,\n\noperatornameZ =\nbeginpmatrix\n    10\n    0-1\nendpmatrix\n\nTwo qubit gate matrices are defined in the basis 00rangle, 01rangle>, 10rangle, 11rangle where the left-most qubit is the first to appear in the target list e.g.,\n\noperatornameCNOT =\nbeginpmatrix\n    1000\n    0100\n    0001\n    0010\nendpmatrix\n\njulia> CNOT = [1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]\n4×4 Matrix{Int64}:\n 1  0  0  0\n 0  1  0  0\n 0  0  0  1\n 0  0  1  0\n\njulia> # CNOT gate with control on q1 and target on q2\n\njulia> Instruction(GateCustom(CNOT), 1, 2)\nGateCustom([1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0]) @ q1, q2\n\n# Examples\n\n\njldoctest julia> g = GateCustom([1 0; 0 1]) Custom([1.0 0.0; 0.0 1.0])\n\njulia> push!(Circuit(), g, 1) 1-qubit circuit with 1 gates: └── Custom([1.0 0.0; 0.0 1.0]) @ q1 ```\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Non-unitary-operations","page":"Public","title":"Non-unitary operations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"reset.jl\", \"measure.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.Reset","page":"Public","title":"MimiqCircuitsBase.Reset","text":"struct Reset <: Operation{1}\n\nQuantum operation that resets the status of one qubit to the ket0 state.\n\nExamples\n\njulia> push!(Circuit(), Reset(), 1)\n2-qubit circuit with 1 gates:\n└── Reset @ q1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Measure","page":"Public","title":"MimiqCircuitsBase.Measure","text":"struct Measure <: Operation{1}\n\nSingle qubit measurement operation in the computational basis\n\nThis operation is non-reversible\n\nExamples\n\nMeasure project the qubit state and optionally store the result of the measurement for that qubit in a classical register.\n\nTo just apply the measurement on qubit 1 and discard the result, do:\n\njulia> push!(Circuit(), Measure(), 1)\n2-qubit circuit with 1 gates:\n└── Measure @ q1\n\nIn order to store the result on the 2nd bit, call:\n\njulia> push!(Circuit(), Measure(), 1 => 2)\n2-qubit circuit with 1 gates:\n└── Measure @ q1, c1\n\n\n\n\n\n","category":"type"},{"location":"library/public/#No-ops","page":"Public","title":"No-ops","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"barrier.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.Barrier","page":"Public","title":"MimiqCircuitsBase.Barrier","text":"struct Barrier <: Operation{1}\n\nA barrier is a special operation that does not affect the quantum state or the execution of a circuit, but it prevents compression or optimization operation from being applied across it.\n\nExamples\n\njulia> push!(Circuit(), Barrier(), 1)\n2-qubit circuit with 1 gates:\n└── Barrier @ q1\n\njulia> push!(Circuit(), Barrier(), 1:4...)\n2-qubit circuit with 1 gates:\n└── Barrier @ q1, q2, q3, q4\n\njulia> push!(Circuit(), Barrier(), 1:4)\n2-qubit circuit with 1 gates:\n├── Barrier @ q1\n├── Barrier @ q2\n├── Barrier @ q3\n└── Barrier @ q4\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Composite-operations","page":"Public","title":"Composite operations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"ifstatement.jl\", \"control.jl\", \"parallel.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.IfStatement","page":"Public","title":"MimiqCircuitsBase.IfStatement","text":"struct IfStatement{N,M} <: Operation{N,M}\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Control","page":"Public","title":"MimiqCircuitsBase.Control","text":"struct Control{N,M,L,T<:Operation{M,0}} <: Operation{L,0} end\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.Parallel","page":"Public","title":"MimiqCircuitsBase.Parallel","text":"struct Parallel{N,M,L,T<:Operation{M,0}} <: Operation{L,0} end\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Bit-States","page":"Public","title":"Bit States","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [MimiqCircuitsBase]\nPrivate = false\nPages   = [\"bitstates.jl\"]","category":"page"},{"location":"library/public/#MimiqCircuitsBase.BitState","page":"Public","title":"MimiqCircuitsBase.BitState","text":"struct BitState\n\nRepresentation of the quantum state of a quantum register with definite values for each qubit.\n\nExamples\n\njulia> BitState(16)\n16-qubit BitState with 0 non-zero qubits:\n└── |0000000000000000⟩\n\njulia> bs = BitState(16, [1,2,3,4])\n16-qubit BitState with 4 non-zero qubits:\n├── |1111000000000000⟩\n└── non-zero qubits: [1, 2, 3, 4]\n\njulia> bs[10] = 1\n1\n\njulia> bs\n16-qubit BitState with 5 non-zero qubits:\n├── |1111000001000000⟩\n└── non-zero qubits: [1, 2, 3, 4, 10]\n\njulia> c = Circuit()\nempty circuit\n\njulia> push!(c, GateX(), 8)\n8-qubit circuit with 1 gates:\n└── X @ q8\n\njulia> BitState(c, [1,3,5,8])\n8-qubit BitState with 4 non-zero qubits:\n├── |10101001⟩\n└── non-zero qubits: [1, 3, 5, 8]\n\njulia> bitstate_to_integer(bs)\n527\n\njulia> typeof(ans)\nBigInt\n\njulia> bitstate_to_integer(bs, Int64)\n527\n\njulia> typeof(ans)\nInt64\n\nThere are many different ways to get bit states:\n\njulia> bs = BitState(30, 2344574)\n30-qubit BitState with 13 non-zero qubits:\n├── |011111100110001111000100000000⟩\n└── non-zero qubits: [2, 3, 4, 5, 6, 7, 10, 11, 15, 16, 17, 18, 22]\n\njulia> ones(BitState, 10) # or also trues(BitState, 10)\n10-qubit BitState with 10 non-zero qubits:\n├── |1111111111⟩\n└── non-zero qubits: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\njulia> zeros(BitState, 10) # or also falses(BitState, 10)\n10-qubit BitState with 0 non-zero qubits:\n└── |0000000000⟩\n\njulia> BitState(16) do i\n           iseven(i)\n       end\n16-qubit BitState with 8 non-zero qubits:\n├── |0101010101010101⟩\n└── non-zero qubits: [2, 4, 6, 8, 10, 12, 14, 16]\n\n\n\n\n\n","category":"type"},{"location":"library/public/#MimiqCircuitsBase.bits-Tuple{BitState}","page":"Public","title":"MimiqCircuitsBase.bits","text":"bits(bitstate)\n\nGet the underlying bit array of a bit state.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.bitstate_to_index-Tuple{BitState}","page":"Public","title":"MimiqCircuitsBase.bitstate_to_index","text":"bitstate_to_index(bitstate)\n\nConvert a bit state into the corresponding index.\n\nThis is useful for indexing, for example, a vector of states.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.bitstate_to_integer-Union{Tuple{BitState}, Tuple{T}, Tuple{BitState, Type{T}}} where T","page":"Public","title":"MimiqCircuitsBase.bitstate_to_integer","text":"bitstate_to_integer(bitstate[, T])\n\nConvert a bit state into its corresponding integer.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.nonzeros-Tuple{BitState}","page":"Public","title":"MimiqCircuitsBase.nonzeros","text":"nonzeros(bitstate)\n\nReturn the indices of the non-zero qubits in a bit state.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.to01-Tuple{BitState}","page":"Public","title":"MimiqCircuitsBase.to01","text":"to01(bitstate[, endianess=:big])\n\nConverts a BitState into a string of 0 and 1 characters. Optionally endianess can be specified, which can be either :big or :little.\n\nExamples\n\njulia> to01(bs\"10011\")\n\"10011\"\n\njulia> to01(bs\"10011\"; endianess=:big)\n\"10011\"\n\njulia> to01(bs\"10011\"; endianess=:little)\n\"11001\"\n\n\n\n\n\n","category":"method"},{"location":"library/public/#MimiqCircuitsBase.@bs_str-Tuple{Any}","page":"Public","title":"MimiqCircuitsBase.@bs_str","text":"macro bs_str(s)\n\nConvert a string into a bit state.\n\nExamples\n\njulia> bs\"101011\"\n6-qubit BitState with 4 non-zero qubits:\n├── |101011⟩\n└── non-zero qubits: [1, 3, 5, 6]\n\n\n\n\n\n","category":"macro"}]
}
